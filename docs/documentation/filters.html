<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Collision Filters | Jitter2 </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Collision Filters | Jitter2 ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/notgiven688/jitterphysics2/blob/main/docfx/docs/documentation/filters.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="collision-filters">Collision Filters</h1>

<p>There are three types of collision filters: <code>world.DynamicTree.Filter</code>, <code>world.BroadPhaseFilter</code>, and <code>world.NarrowPhaseFilter</code>.</p>
<h2 id="dynamic-tree-filter">Dynamic tree filter</h2>
<p>The <code>world.DynamicTree.Filter</code></p>
<pre><code class="lang-cs">public Func&lt;IDynamicTreeProxy, IDynamicTreeProxy, bool&gt; Filter { get; set; }
</code></pre>
<p>is the earliest filter applied during <code>world.Step</code> and is set by default to <code>World.DefaultDynamicTreeFilter</code>:</p>
<pre><code class="lang-cs">public static bool DefaultDynamicTreeFilter(IDynamicTreeProxy proxyA, IDynamicTreeProxy proxyB)
{
    if (proxyA is RigidBodyShape rbsA &amp;&amp; proxyB is RigidBodyShape rbsB)
    {
        return rbsA.RigidBody != rbsB.RigidBody;
    }

    return true;
}
</code></pre>
<p>This filters out collisions between shapes that belong to the same body.
The dynamic tree will ignore these collisions, and no potential pairs will be created.</p>
<p>For soft bodies, another collision filter is typically used (defined in <code>SoftBodies.DynamicTreeCollisionFilter.Filter</code>), which also filters out collisions between shapes belonging to the same soft body.</p>
<h2 id="broad-phase-filter">Broad phase filter</h2>
<p>By default <code>world.BroadPhaseFilter</code></p>
<pre><code class="lang-cs">public IBroadPhaseFilter? BroadPhaseFilter { get; set; }
</code></pre>
<p>is <code>null</code>. It is used to filter out collisions that passed broad phase collision detectionâ€”that is, after the <code>DynamicTree</code> has added the collision to the <code>PotentialPair</code> hash set.</p>
<p>This can be useful if custom collision proxies are added to <code>world.DynamicTree</code>.
Since the world only knows how to handle collisions between <code>RigidBodyShape</code>s, a filter must handle the detected collision (implement custom collision response code and filter out the collision) such that no <code>InvalidCollisionTypeException</code> is thrown.
The soft body implementation is based on this kind of filter (see <code>SoftBodies.BroadPhaseCollisionFilter</code>).</p>
<h3 id="example-collision-groups">Example: Collision groups</h3>
<p>Collision groups can be implemented using a broad phase filter.
In this example, there are two teams: team blue and team red.
A filter that disregards all collisions between team members of different colors:</p>
<pre><code class="lang-cs">public class TeamFilter : IBroadPhaseFilter
{
    public class TeamMember { }
    
    public static TeamMember TeamRed = new();
    public static TeamMember TeamBlue = new();
    
    public bool Filter(Shape shapeA, Shape shapeB)
    {
        if (shapeA.RigidBody.Tag is not TeamMember || shapeB.RigidBody.Tag is not TeamMember)
        {
            // Handle collision normally if at least one body is not a member of any team
            return true;
        }

        // There is no collision between team red and team blue.
        return shapeA.RigidBody.Tag == shapeB.RigidBody.Tag;
    }
}
</code></pre>
<p>The <code>TeamFilter</code> class can then be instantiated and assigned to <code>world.BroadPhaseFilter</code>:</p>
<pre><code class="lang-cs">world.BroadPhaseFilter = new TeamFilter();
...
bodyA.Tag = TeamFilter.TeamBlue;
bodyB.Tag = TeamFilter.TeamRed;
bodyC.Tag = TeamFilter.TeamRed;
</code></pre>
<h2 id="narrow-phase-filter">Narrow phase filter</h2>
<p>The <code>world.NarrowPhaseFilter</code></p>
<pre><code class="lang-cs">public INarrowPhaseFilter? NarrowPhaseFilter { get; set; }
</code></pre>
<p>operates similarly.
However, this callback is called after narrow phase collision detection, meaning detailed collision information (such as normal, penetration depth, and collision points) is available at this stage.
The filter can not only exclude collisions but also modify collision information.</p>
<p>The default narrow phase collision filter is assigned to an instance of <code>TriangleEdgeCollisionFilter</code>, which filters out so-called 'internal edges' for <code>TriangleShape</code>s.
These internal edges typically cause collision artifacts when rigid bodies slide over the edges of connected triangles forming static geometry.
This problem is also known as 'ghost collisions'.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/notgiven688/jitterphysics2/blob/main/docfx/docs/documentation/filters.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
