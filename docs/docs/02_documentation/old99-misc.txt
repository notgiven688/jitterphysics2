---
sidebar_position: 99
---

# Misc

Let's discuss the changes in more detail and make some additional remarks.

## Coordinates

The first bigger change is the addition of this helper function:

```cs
static Matrix4x4 GetRayLibTransformMatrix(RigidBody body)
{
    JMatrix ori = body.Orientation;
    JVector pos = body.Position;

    return new Matrix4x4(ori.M11, ori.M12, ori.M13, pos.X,
                         ori.M21, ori.M22, ori.M23, pos.Y,
                         ori.M31, ori.M32, ori.M33, pos.Z,
                         0, 0, 0, 1.0f);
}
```

raylib uses the Matrix4x4 structures provided by the System.Net.Numerics namespace to store the transformation matrix of a mesh. In Jitter the orientation is stored in a 3-by-3 matrix and the translation by a 3-component column vector. The method converts the Jitter representation to the raylib one.

:::tip JMatrix representation in memory

`JMatrix` is a 3x3 matrix, stored in column major order, i.e. the order of elements in memory is given by

```cs
[StructLayout(LayoutKind.Explicit, Size = 36)]
public struct JMatrix
{
    [FieldOffset(0)] public float M11;
    [FieldOffset(4)] public float M21;
    [FieldOffset(8)] public float M31;
    [FieldOffset(12)] public float M12;
    //(...)
}
```
Columns can be accessed efficiently by `matrix.GetColumn(int index)`.

:::

:::tip Coordinate system

`JVector` is a column vector. Multiplying a matrix by a vector (`JVector.Transform(..)`)
follows the usual definition. Jitter also uses standard right-hand convention. The y-axis (2nd component)
is usually assumed to be the "up"-axis, e.g. the default gravity in Jitter is `(0, -9.81, 0)`.

:::

## Initializing the world

The world class is initialized by the innocent looking `World world = new ();`, which is actually equivalent to the call to the overloaded constructor

```cs
// initialize jitter physics world
World world = new (numBodies: 32768, numContacts: 65536, numConstraints: 32768);
```

Jitter uses its own memory management system for performance reasons. Some restrictions in this system
require us to specify the maximum number of bodies, contacts and constraints to be defined a-priori.
In the example above Jitter allocates 32768 + 65536 + 32768 = 131072 pointers on the heap which usually 
take 64 bit each. Therefore in this example 1024 KB get allocated immediately. The actual memory for the objects is then
allocated dynamically when needed during runtime. For example a constraint in Jitter
is actually fixed to 256 byte, adding all 32768 constraints to the world would then take up 6.8 MB of additional memory. These numbers may seem small compared to the available amount of RAM on today's machines but you have to keep in mind that a CPU-caches are orders of magnitude smaller - staying within the CPU cache is a garant for performance gain.

The world class holds all physical objects of a simulation. 