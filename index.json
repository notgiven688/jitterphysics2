{
  "docs/changelog.html": {
    "href": "docs/changelog.html",
    "title": "Changelog | Jitter2",
    "summary": "Changelog Jitter 2.7.8 (2026-01-18) Fixed degraded tree quality for large proxies in DynamicTree. Added JQuaternion.Lerp, JQuaternion.Slerp, JQuaternion.Dot, and JQuaternion.Inverse methods for quaternion interpolation and math. Added JTriangle.GetCenter, JTriangle.GetNormal, JTriangle.GetArea, JTriangle.GetBoundingBox, and JTriangle.ClosestPoint helper methods. Added JBoundingBox.Disjoint and JBoundingBox.Contains methods (also in TreeBox). Added World.GetArbiter(id0, id1) to retrieve existing arbiters without creating new ones. Improved XML documentation throughout the codebase. Fixed CalculateMassInertia in TransformedShape returning incorrect values. Fixed normalization bug in TriangleEdgeCollisionFilter. Fixed validation in SphereShape radius setter. Fixed a bug in speculative contact implementation. Improved TriangleMesh. Added option to build directly from vertices and indices. Added overloads for Span throughout the engine (in TriangleMesh, ShapeHelper, PointCloudShape, ConvexHullShape). Jitter 2.7.7 (2026-01-08) Added vector.UnsafeAs<T> and JVector.UnsafeFrom<T>. Same for JQuaternion. Added world.PreSubStep and world.PostSubStep events. Jitter 2.7.6 (2025-12-18) Removed World.Capacity. Number of entities in World no longer has to be specified in advance. Fixed a bug in TwistAngle. Added WeldJoint. Exposed more properties in ConeLimit. Jitter 2.7.5 (2025-11-16) Improved cost heuristic for DynamicTree. Jitter 2.7.4 (2025-10-29) Add MotionType property to RigidBody instances. Bodies might me Dynamic, Static or Kinematic. Static bodies with non-zero velocity are no longer supported, kinematic bodies must be used instead. The contact graph information is used to optimize the memory layout for contacts (ReorderContacts step). This makes the solver more cache friendly. Reduced overhead of CheckDeactivation step in the engine. Jitter 2.7.3 (2025-10-19) Improved multi-threading performance. Jitter 2.7.2 (2025-09-21) Reduced GC in DynamicTree.Optimize. Default to LocalRayCast if body is not set for RigidBodyShape. Added wakeup parameter to AddForce overloads for finer activation state control. Added generic ICloneableShape<T> interface for type-safe shape cloning. Jitter 2.7.1 (2025-06-28) Added RigidBody.EnableGyroscopicForces to include gyroscopic forces. Jitter 2.7.0 (2025-06-14) Dropped .NET7 support Added JQuaternion.ToAxisAngle method Renamed JBBox to JBoundingBoxand TreeBBox to TreeBox. Various smaller API changes. Jitter 2.6.7 (2025-06-09) Introduced SIMD accelerated TreeBBox for DynamicTree. Jitter 2.6.6 (2025-05-31) Implicit conversion for JVector and JQuaternion from tuples, e.g. cube.Position = (1, 2, 3);. Added PreStep and PostStep to World.Timings. Added NarrowPhase.Sweep overload which calculates time of impact (TOI) for rotating shapes. RegisterContact no longer requires a penetration and a speculative parameter. Bugfix: MathHelper.RotationQuaternion, fixed wrong/not normalized quaternion generation for large dt. Added an additional normal out-parameter to NarrowPhase.Distance. Renamed JVector.TransposedTransform(in JVector vector, in JQuaternion quat) to ConjugatedTransform. Added Anchor1 and Anchor2 properties to BallSocket. Bugfix: Skipping degenerate triangles in TriangleMesh now works correctly. Jitter 2.6.5 (2025-05-21) Rigid bodies now activate on velocity or force changes. Removed FatTriangleShape. Renamed 'Active' to 'ActiveCount' and add span-based accessors in ReadOnlyPartitionedSet. Fixed bug in TriangleEdgeCollisionFilter. Jitter 2.6.4 (2025-05-19) Breaking Change: Triangle winding order in TriangleMesh is now counter-clockwise (CCW) for front-facing triangles. If you're using TriangleMesh, swap the vertex order to maintain correct normal orientation. Added JTriangle.RayIntersect method. Renamed ConvexHullIntersection to CollisionManifold. Modified support function for BoxShape. Jitter 2.6.3 (2025-05-17) Aligned rigid bodies (RigidBodyData) to a 64-byte boundary (reduce false sharing). Bugfix in speculative contacts. Jitter 2.6.2 (2025-05-06) Use Generics in NarrowPhase.cs (avoid boxing for structs implementing the ISupportMappable interface). Added special code paths in Contact.cs for static bodies (avoid unnecessary cache line invalidation). Added PredictPosition, PredictOrientation and PredictPose to RigidBody. Added CreateFromAxisAngle and Normalize methods in JQuaternion. Jitter 2.6.1 (2025-04-24) Bugfix in TriangleEdgeCollisionFilter for speculative contacts. Jitter 2.6.0 (2025-04-24) Added SampleHull and MakeHull to ShapeHelper. Fixed hill climbing getting stuck for ConvexHullShapes. Added SIMD support for PointCloudShapes. Added option to ignore degenerated triangles in TriangleMesh. Made thickness parameter mandatory in FatTriangleShape. Added Fisher-Yates shuffle to DynamicTree.Optimize. Optimized TriangleEdgeCollisionFilter. Jitter 2.5.9 (2025-04-17) Use CollideEpsilon 1e-5 in MPREPA. Fixed a bug in ShardedDictionary. Jitter 2.5.8 (2025-04-16) Fixed DynamicTree.Optimize messing up collision pairs. Refactored SoftBody.cs Improved TriangleEdgeCollisionFilter. Further reduced GC. Jitter 2.5.7 (2025-04-06) Fixed possible crash when dynamically making bodies static. Improved memory footprint and reduced GC. Added Logger as a replacement for Trace. Jitter 2.5.6 (2025-03-08) Fixed concurrency bug in world.GetArbiter. Jitter 2.5.5 (2025-03-02) Added implicit conversion operators for System.Numerics Vector3 and Quaternion. Replaced Trace.WriteLine with Trace.Information, Warning, Error. Jitter 2.5.4 (2025-02-08) Renamed JAngle.Radiant to JAngle.Radian. Renamed namespace Jitter2.UnmanagedMemory to Jitter2.Unmanaged. Fixed body.AddShape(IEnumerable<RigidBodyShape> shapes) for one-time-use iterators. Smaller improvements in XML-documentation. Jitter 2.5.3 (2025-01-12) DynamicTree, Optimize takes a delegate now. Fixed TriangleShape ray cast not returning a normalized normal. Removed the CollisionHelper class. Renamed ActiveList and UnmanagedActiveList to PartitionedSet and PartitionedBuffer, respectively. Various smaller improvements (ToString() overloads, IEquality<T> implementations, XML-documentation) Jitter 2.5.2 (2025-01-08) Added enumeration method to DynamicTree and made PairHashSet internal. Breaking Change: Removed UseFullEPASolver option. Further improved simulation performance under high lock contention scenarios. Jitter 2.5.1 (2024-12-31) Bugfix in PairHashSet. Jitter 2.5.0 (2024-12-23) Better utilization of multi core systems. Bugfix in collision detection (possible NaN values). Jitter 2.4.9 (2024-12-18) Huge improvements for the DynamicTree implementation. Jitter 2.4.8 (2024-11-27) Add option to build in double precision mode. Made Constraint constructor public to allow for custom constraints. Jitter 2.4.7 (2024-11-18) Breaking Change: Dropped .NET6 support, added .NET9. SIMD for contacts. Contact manifold overflow fix. Changed default damping. Improved auxiliary contact points. Minor API changes. Jitter 2.4.6 (2024-10-28) Breaking Change: Jitter world is now constructed using World.Capacity. Breaking Change: World.RayCast moved to World.DynamicTree.RayCast. Breaking Change: Renamed NumberSubsteps to SubstepCount. Added split impulses. Breaking Change: SolverIterations property is now a tuple. Several smaller improvements in the API. Jitter 2.4.5 (2024-10-07) Added new methods to NarrowPhase: Distance and Overlap. Breaking Change: Renamed NarrowPhase.SweepTest to NarrowPhase.Sweep. Breaking Change: Renamed NarrowPhase.GJKEPA to NarrowPhase.Collision. Made PointTest, Raycast and SweepTest to use new SimplexSolver and SimplexSolverAB implementations. Fixed normal in GJKEPA for separating case. Jitter 2.4.4 (2024-09-14) Implemented fixes and workarounds for using Jitter with a debugger attached. Jitter 2.4.3 (2024-08-31) Correct corner case beeing wrong in MPR collision detection due to typo (bug fix). FatTriangleShape level did not properly take transformations into account (bug fix). Jitter 2.4.2 (2024-08-26) Added FatTriangleShape to give triangles thickness which can be useful for static triangle meshes. Removal from potential pairs in DynamicTree ignores filters from now on (bug fix). Use sweep tests for speculative contacts, vastly improving simulation quality in this scenario. Breaking Change: Redefinition of NarrowPhase.SweepTest results. Improved TriangleEdgeCollisionFilter. Jitter 2.4.1 (2024-08-21) Improved TriangleEdgeCollisionFilter. Implemented analytical box and sphere ray casting. Made Restitution and Friction public in Contact. Improved DynamicTree interface. Added Debug.Asserts in ActiveList. Marked ArbiterKey as readonly. Added enumerator to PairHashSet. Changed ShapeHelper.MakeHull to take a generic of type ICollection. Jitter 2.4.0 (2024-08-10) Improved TrimPotentialPairs logic. Optimized quaternion vector transformation. Extended functionality of ContactData.UsageMask. Breaking Change: Overhauled the shape system. Regular shapes (box, sphere, capsule, ...) now derive from RigidBodyShape. Some method signatures changed slightly, e.g. ray casting. Improved exceptions. Added ReferenceFrameAttribute. Jitter 2.3.1 (2024-06-02) ReadOnly wrappers (ReadOnlyList, ReadOnlyHashset) are now structs. Shapes with very small dimensions might have close to zero or zero mass/inertia. Creating rigid bodies from them now throws an exception (use body.AddShape(shape, setMassInertia: false) to not use the shape's mass properties). Added BeginCollide and EndCollide events per body. Jitter 2.3.0 (2024-05-20) Added RigidBody.RemoveShape overload to remove multiple shapes at once. Marked Rigid.ClearShapes deprecated. Breaking Change: Use JQuaternion for orientations. Sorry for the API break. Jitter 2.2.1 (2024-04-29) Add optional activate parameter to world.AddShape. Add NarrowPhase.SweepTest. EPA collision detection: various improvements. Improve exit condition for RayCast and PointTest. Remove redundant ArgumentException for zero mass shapes. Handle zero time steps. Throw ArgumentException for negative time steps. Add joint base class to joint classes. Jitter 2.2.0 (2024-01-02) Breaking Change: Renamed Raycast to RayCast. world.Remove(world.NullBody) does now remove all shapes, constraints and contacts associated with NullBody. world.AddShape(shape) respects the activation state of the associated rigid body. Most notable: performance improvement when directly adding TriangleShapes to world.NullBody for static geometry. Performance improvements for ConvexHullShape. Improved termination condition in GJKEPA collision detection. Jitter 2.1.1 (2023-12-17) Fixed O(n^2) problem in TriangleMesh due to hash collisions. WorldBoundingBox of Shape is now updated even if no RigidBody is attached. Jitter 2.1.0 (2023-12-10) Added debug drawing for rigid bodies (RigidBody.DebugDraw). Fixed a bug in CalculateMassInertia within TransformedShape.cs. Improved ray casting performance and introduced NarrowPhase.PointTest. Breaking Change: Inverted behavior of BroadPhaseCollisionFilter. Breaking Change: Inverted definition of damping factors in RigidBody.Damping (0 = no damping, 1 = immediate halt). Added RigidBody.SetMassInertia overload to enable setting the inverse inertia to zero. An exception is now thrown when a body's mass is set to zero. Fixed a bug in the friction handling in Contact.cs. Jitter 2.0.1 (2023-10-28) Fixed a bug in contact initialization which affected soft body physics. Jitter 2.0.0 (2023-10-22) Initial stable Release."
  },
  "docs/documentation/bodies.html": {
    "href": "docs/documentation/bodies.html",
    "title": "Rigid Bodies | Jitter2",
    "summary": "Rigid Bodies Rigid bodies represent the main entity of the dynamics system of the engine. Creating a body Rigid bodies are associated to an instance of the World class. They can be created like this: var world = new World(); var body = world.CreateRigidBody(); Adding shapes Multiple shapes can be added to a rigid body, for example: body.AddShape([new SphereShape(radius: 2), new BoxShape(size: 1)]); Shapes determine how bodies collide with each other. Warning Creating many bodies at once When calling body.AddShape(shape), the shape is registered in the collision system of the engine and immediately added to the spatial tree structure (DynamicTree) for efficient broad-phase collision detection. Registering many objects at \\((0, 0, 0)\\) must be prevented by specifying the rigid body position, before adding shapes. Warning Passing the same instance to multiple bodies Passing the same instance of a shape to multiple bodies is not allowed in Jitter and will throw an exception. In Jitter, the sphere shape is defined so that its geometric center aligns with the (local) coordinate system's center at \\((0, 0, 0)\\). The same holds for all basic primitives (sphere, box, capsule, cone, cylinder). After adding a shape to Jitter the mass properties (mass and inertia) of the associated rigid body are calculated accordingly. Jitter assumes unit density for the calculations. Adding just a sphere body.AddShape(new SphereShape(radius: 1)); will result in a body with the textbook inertia and mass of a unit-density sphere of radius one. Of course, the mass properties of the body can be set directly, using body.SetMassInertia. Setting setMassProperties: false in body.AddShape(...) prevents Jitter from using the shapes' mass properties. In Jitter the position of the rigid body has to align with the center of mass. So in the local reference frame of the body, the center of mass is \\((0, 0, 0)\\). Shapes or combinations of shapes must be translated accordingly. Debugging shapes The RigidBody class offers the body.DebugDraw(IDebugDrawer drawer) method which creates a triangle hull for each shape added to the body and calls the drawer.DrawTriangle method in the provided IDebugDrawer implementation. The coordinates of the triangles are in world space and can be drawn to debug the collision shape of the rigid body. Warning body.DebugDraw performance Every call to body.DebugDraw the triangle hulls are generated on the fly. Since this is a slow operation the method should only be called for debugging purposes. Gravity The gravity for the world can be set using world.Gravity. The property body.AffectedByGravity can be used to disable gravity for individual bodies. Damping Jitter uses a very simple damping system to slow rigid bodies down. This improves simulation stability and also resembles mechanical systems 'losing' energy in the real world. In Jitter there is a linear and an angular damping factor for each body which can be set using body.Damping. With each world.Step, Jitter multiplies the angular and linear velocity of each rigid body by \\(1-\\gamma\\), where \\(\\gamma\\) is the damping factor. For performance reasons there is no time dependency for the damping system. As a result, bodies in a simulation with smaller timesteps experience greater damping. Speculative contacts Speculative contacts can be utilized to prevent fast and small objects from tunneling through thin objects. An object moving quickly enough might 'miss' a collision since the distance traveled between two frames exceeds the thickness of another object. Speculative contacts can be enabled on a per-body basis using body.EnableSpeculativeContacts. The world.SpeculativeRelaxationFactor and world.SpeculativeVelocityThreshold can be adjusted to fine-tune speculative contacts for specific use cases. However, it should be noted that an accurate simulation of fast-moving objects is only possible using smaller time steps. Speculative contacts may involve a trade-off of less accurate collision detection and response. Friction and Restitution Friction and restitution coefficients may be set through body.Friction and body.Restitution. For a collision of two bodies with different coefficients the maximum value of each body is taken. Collide events An instance of RigidBody provides two events: BeginCollide and EndCollide. These events are triggered whenever an arbiter (Contact) is created or removed which involves the rigid body. By default, arbiters are created between colliding shapes. For example, the BeginCollide event can be used to modify the coefficient of friction of a contact: body.BeginCollide += BodyOnBeginCollide; private void BodyOnBeginCollide(Arbiter arb) { arb.Handle.Data.Friction = 0.0f; } Activation/Deactivation A rigid body is always assigned to an island. Islands are formed by bodies which are pairwise interacting with each other trough contacts or constraints. Different islands are not interacting with each other in any way. Active rigid bodies may be marked for deactivation by the world once their angular and linear velocity remain below the thresholds defined in body.DeactivationThreshold for a period defined by body.DeactivationTime. If all bodies within an island are marked for deactivation the whole island gets deactivated. The simulation cost for inactive bodies is effectively zero. Islands (and their associated bodies) might get waken up, as soon as a collision with an active body is registered. Using body.SetActivationState, the user can reset the internal deactivation time clock for the rigid body. It will not immediately change the activation state of the body (body.IsActive). Jitter will then in the next world.Step consider this body and it's connected island for activation or deactivation. Calling e.g. body.SetActivationState(false) on a falling body with a velocity greater than body.DeactivationThreshold will have no effect. Static bodies Static bodies (body.BodyType == BodyType.Static) have infinite mass and therefore are not affected by collisions or constraints. They also do not join islands. Static bodies do not generate collisions with other static or inactive bodies. Because of this, the position of static bodies should not be altered while in contact with other bodies. Kinematic bodies In Jitter kinematic bodies (body.BodyType == BodyType.Kinematic) are bodies which can have a velocity and therefore change their position. They act similar to static bodies during collisions - their velocity is not changed when colliding with a regular body. They do take part in collision islands. Caution Kinematic bodies Having an unstoppable object colliding with a static (immovable object) or another unstoppable object might crash the solver. It must be ensured that no contact points are generated in such cases."
  },
  "docs/documentation/constraints.html": {
    "href": "docs/documentation/constraints.html",
    "title": "Constraints | Jitter2",
    "summary": "Constraints Constraints constraint various degrees of freedom of rigid bodies. In Jitter, constraints always act between two bodies. A joint is a collection of multiple constraints, so it may act on multiple bodies. Default constraints Default constraints available are: AngularMotor, BallSocket, ConeLimit, DistanceLimit, FixedAngle, HingeAngle, LinearMotor, PointOnLine, PointOnPlane, TwistAngle, SpringConstraint Available joints: HingeJoint, PrismaticJoint, UniversalJoint, Weld Creating constraints Similar to rigid bodies but unlike shapes, constraints are instantiated through a create method in the world class: var constraint = world.CreateConstraint<ConstraintType>(body1, body2); Jitter allocates and assigns unmanaged memory to constraints internally, allowing them to be used like regular classes. The solver interacts with unmanaged memory structures of type ConstraintData (256 bytes) or SmallConstraintData (128 bytes), depending on whether constraint.IsSmallConstraint is set. Small constraints are designed for simpler constraints with a smaller memory footprint, such as spring constraints for soft bodies. Caution Constraint Initialization For all default constraints in Jitter, constraint.Initialize must be called once after world.CreateConstraint. Example: Hinge joint A swinging door may be implemented by a combination of two constraints: A HingeAngle constraint which removes two degrees of angular freedom (i.e. the bodies can only rotate around a single axis), and a BallSocket constraint removing all three degrees of freedom (there is no translation possible): var hingeAngle = world.CreateConstraint<HingeAngle>(body1, body2); hingeAngle.Initialize(hingeAxis, AngularLimit.Full); var ballSocket = world.CreateConstraint<BallSocket>(body1, body2); ballSocket.Initialize(hingeCenter); Alternatively the HingeJoint might be used for convenience: var hinge = new HingeJoint(world, body1, body2, hingeCenter, hingeAxis); Fixed constraints To constrain a rigid body relative to world space, use world.NullBody as one of the bodies. For example, to keep a capsule upright, a constraint can be set up as follows: var upright = world.CreateConstraint<HingeAngle>(capsule, world.NullBody); upright.Initialize(JVector.UnitY, AngularLimit.Full); Softness and Bias For most constraints a softness and bias value can be set. These values define how strict the constraint limits are enforced. Softer constraints might improve simulation stability but do not fully enforce the constraint limits. The softness and bias parameters can be tweaked for optimal results. Better constraint behaviour can also be archived by sub-stepping, see world.Step. Enable/Disable constraints Constraints can be temporarily enabled or disables using constraint.IsEnabled."
  },
  "docs/documentation/dynamictree.html": {
    "href": "docs/documentation/dynamictree.html",
    "title": "Dynamic tree | Jitter2",
    "summary": "Dynamic tree The dynamic tree in Jitter holds instances which implement the IDynamicTreeProxy interface. The main task of the tree is to efficiently determine if a proxy's axis-aligned bounding box is overlapping with the axis-aligned bounding box of any other proxy in the world. In a naive implementation this requires \\(\\mathcal{O}\\left(n\\right)\\) operations (checking for an overlap with every of the \\(n-1\\) entities). The tree structure does accelerate this to \\(\\mathcal{O}\\left(\\mathrm{log}(n)\\right)\\). Since proxies are dynamic and can move, the tree must be continuously updated. To less frequently trigger updates, entities are enclosed within slightly larger bounding boxes than their actual size. This bounding box extension is defined by the Velocity property of the IDynamicTreeProxy interface. Adding proxies Jitter automatically registers all shapes added to a rigid body (body.AddShape) with the world.DynamicTree. However, users are free to add own implementations of IDynamicTreeProxy to the world's tree, using tree.AddProxy. In this case the user has to implement a BroadPhaseFilter and register it (using world.BroadPhaseFilter) to handle any collisions with the custom proxy, otherwise an InvalidCollisionTypeException is thrown. Enumerate Overlaps The tree implementation in Jitter needs to be updated using tree.Update. This is done automatically for the dynamic tree owned by the world class (world.DynamicTree). Internally UpdateWorldBoundingBox is called for the active proxies implementing the IUpdatableBoundingBox interface and the internal book-keeping of overlapping pairs is updated. Overlaps may be queried using tree.EnumerateOverlaps. Querying the tree All tree proxies that overlap a given axis aligned box can be queried public void Query<T>(T hits, in JBBox box) where T : ICollection<IDynamicTreeProxy> as well as all proxies which overlap with a ray public void Query<T>(T hits, JVector rayOrigin, JVector rayDirection) where T : ICollection<IDynamicTreeProxy> Custom queries can easily be implemented. An implementation which queries all proxies which have an overlap with a single point can be implemented like this: var stack = new Stack<int>(); stack.Push(tree.Root); while (stack.TryPop(out int id)) { ref DynamicTree.Node node = ref tree.Nodes[id]; if (node.ExpandedBox.Contains(point)) { if (node.IsLeaf) { Console.WriteLine($'{node.Proxy} contains {point}.'); } else { stack.Push(node.Left); stack.Push(node.Right); } } } Ray casting All proxies in the tree which implement the IRayCastable interface can be raycasted. This includes all shapes: public bool RayCast(JVector origin, JVector direction, RayCastFilterPre? pre, RayCastFilterPost? post, out IDynamicTreeProxy? proxy, out JVector normal, out float lambda) The pre- and post-filters can be used to discard hits during the ray cast. Jitter shoots a ray from the origin into the specified direction. The function returns true if a hit was found. It also reports the point of collision which is given by $$$ \\mathbf{hit} = \\mathbf{origin} + \\lambda{},\\times,\\mathbf{direction}, \\quad \\textrm{with} \\quad \\lambda \\in [0,\\infty). $$$ The returned normal is the normalized surface normal at the hit point."
  },
  "docs/documentation/filters.html": {
    "href": "docs/documentation/filters.html",
    "title": "Collision Filters | Jitter2",
    "summary": "Collision Filters There are three types of collision filters in Jitter: world.DynamicTree.Filter, world.BroadPhaseFilter and world.NarrowPhaseFilter. Dynamic tree filter The world.DynamicTree.Filter public Func<IDynamicTreeProxy, IDynamicTreeProxy, bool> Filter { get; set; } is the earliest filter applied during a world.Step and set by default to World.DefaultDynamicTreeFilter: public static bool DefaultDynamicTreeFilter(IDynamicTreeProxy proxyA, IDynamicTreeProxy proxyB) { if (proxyA is RigidBodyShape rbsA && proxyB is RigidBodyShape rbsB) { return rbsA.RigidBody != rbsB.RigidBody; } return true; } This filters out collisions between shapes that belong to the same body. The dynamic tree will ignore these collisions, and no potential pairs will be created. For soft bodies, another collision filter is typically used (defined in SoftBodies.DynamicTreeCollisionFilter.Filter), which also filters out collisions between shapes belonging to the same soft body. Broad phase filter By default world.BroadPhaseFilter public IBroadPhaseFilter? BroadPhaseFilter { get; set; } is null. It is used to filter out collisions that passed broad phase collision detection - that is, after the DynamicTree has added the collision to the PotentialPair hash set. This can be useful if custom collision proxies got added to world.DynamicTree. Since the Jitter world only knows how to handle collisions between RigidBodyShapes, a filter must handle the detected collision (i.e. implement custom collision response code and filter out the collision) such that no InvalidCollisionTypeException is thrown. Jitter's soft body implementation is based on this kind of filter (see SoftBodies.BroadPhaseCollisionFilter). Example: Collision groups Collision groups might be easily implemented using a broad phase filter. In this example, there are two 'teams', team blue and team red. A filter that disregards all collisions between team members (rigid bodies) of different colors is implemented: public class TeamFilter : IBroadPhaseFilter { public class TeamMember { } public static TeamMember TeamRed = new(); public static TeamMember TeamBlue = new(); public bool Filter(Shape shapeA, Shape shapeB) { if (shapeA.RigidBody.Tag is not TeamMember || shapeB.RigidBody.Tag is not TeamMember) { // Handle collision normally if at least one body is not a member of any team return true; } // There is no collision between team red and team blue. return shapeA.RigidBody.Tag == shapeB.RigidBody.Tag; } } The TeamFilter class can then be instantiated and assigned to world.BroadPhaseFilter, ensuring that rigid bodies of different colors will not interact: world.BroadPhaseFilter = new TeamFilter(); ... bodyA.Tag = TeamFilter.TeamBlue; bodyB.Tag = TeamFilter.TeamRed; bodyC.Tag = TeamFilter.TeamRed; Narrow phase filter The world.NarrowPhaseFilter public INarrowPhaseFilter? NarrowPhaseFilter { get; set; } operates similarly. However, this callback is called after narrow phase collision detection, meaning detailed collision information (such as normal, penetration depth, and collision points) is available at this stage. The filter can not only exclude collisions but also modify collision information. The default narrow phase collision filter in Jitter is assigned to an instance of TriangleEdgeCollisionFilter, which filters out so-called 'internal edges' for TriangleShapes. These internal edges typically cause collision artifacts when rigid bodies slide over the edges of connected triangles forming static geometry. In the literature, this problem is also known as 'ghost collisions'."
  },
  "docs/documentation/shapes.html": {
    "href": "docs/documentation/shapes.html",
    "title": "Shapes | Jitter2",
    "summary": "Shapes Shapes in Jitter define how the rigid body collides with other objects. Shapes implement the ISupportMappable interface and are always convex. They can be passed to static methods defined in the NarrowPhase class for collision detection. They also implement the IDynamicTreeEntry interface and can therefore be added to the DynamicTree class: When a shape is added to a rigid body this is done automatically (world.DynamicTree). Note Concave Shapes A concave shape can be represented by combining multiple convex shapes on a single rigid body. Third-party libraries for 'convex decomposition' can be used to generate convex hulls from arbitrary meshes. Default types The inheritance hierarchy for the default shapes in Jitter is shown here: Shape ├── RigidBodyShape │ ├── BoxShape │ ├── CapsuleShape │ ├── ConeShape │ ├── ConvexHullShape │ ├── CylinderShape │ ├── PointCloudShape │ ├── TransformedShape │ └── TriangleShape └── SoftBodyShape ├── SoftBodyTetrahedron └── SoftBodyTriangle Most shapes are self-explanatory (additional details are in the API documentation), while some specifics are outlined below. ConvexHullShape The constructor of the ConvexHullShape takes a list of triangles. public ConvexHullShape(List<JTriangle> triangles) The triangles provided must form a convex hull. The validity of the convex shape is not checked. Invalid shapes can lead to glitched collisions and/or non-terminating algorithms during collision detection. The triangles are used to construct an internal acceleration structure that speeds up collision detection for this shape through hill-climbing. The convexHullShape.Clone() method can be used to clone the shape: The internal data structure is then used for both shapes. PointCloudShape The PointCloudShape is very similar to the ConvexHullShape. The constructor takes a list of vertices. public PointCloudShape(List<JVector> vertices) The vertices do not need to form a convex hull; however, collision detection will 'shrink-wrap' these vertices, so the final collision shape is convex. For example, passing the 8 vertices of a cube to the constructor generates a cube shape; adding a 9th vertex at the cube's center has no effect. Warning Number of vertices PointCloudShapes should only be used for a small to moderate number of vertices (\\(\\approx{}300\\)). Larger numbers of vertices can negatively impact performance. ConvexHullShapes are the better choice for more complex hulls. TransformedShape The TransformedShape takes another shape as input and transforms it. public TransformedShape(RigidBodyShape shape, in JVector translation, in JMatrix transform) Any affine transformation is possible. The wrapped shape might be translated, rotated, scaled and sheared. For example, a sphere shape could be transformed into an ellipsoid. TriangleShape The TriangleShape has no volume. It is mostly used for static geometry, although it can be added to non-static bodies. The TriangleShape is constructed with a TriangleMesh and an index. public TriangleShape(TriangleMesh mesh, int index) A TriangleMesh.Triangle stores information about neighbour triangles. This information is used in the TriangleEdgeCollisionFilter (enabled by default) to resolve collision artifacts that occur when shapes slide over the edges between connected triangles. These edges are often referred to as 'internal edges' and can cause major problems when adding level geometry to a game. SoftBodyShape The vertices of the SoftBodyShape are represented by rigid bodies. The shapes (triangle and tetrahedron) are dynamically defined by the position of the vertices. A SoftBodyShape is not added to a body. Custom shapes Custom shapes can easily be implemented in Jitter. A shape is defined by its support function - which can be looked up or derived. The following example demonstrates implementing a half-sphere (symmetry axis aligned with the y-axis) with a radius of one in Jitter. public class HalfSphereShape : RigidBodyShape { public override void SupportMap(in JVector direction, out JVector result) { const float centerOfMassOffset = 3.0f / 8.0f; if (direction.Y >= 0.0f) { result = JVector.Normalize(direction); } else { JVector pDir = new JVector(direction.X, 0.0f, direction.Z); float pDirSq = pDir.LengthSquared(); if (pDirSq < 1e-12f) result = JVector.Zero; else result = (1.0f / MathF.Sqrt(pDirSq)) * pDir; } // shift, such that (0, 0, 0) is the center of mass result.Y -= centerOfMassOffset; } public override void GetCenter(out JVector point) { point = JVector.Zero; } } Mass properties and bounding boxes are automatically calculated from the support map using methods in the ShapeHelper class. Performance can be optimized by providing overrides directly in the shape class: public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBBox box) public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) public override bool LocalRayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda) The ShapeHelper class can also be used to generate a triangle mesh representation of the shape (or any class implementing ISupportMappable), via public static IEnumerable<JTriangle> MakeHull(ISupportMappable support, int subdivisions = 3)"
  },
  "docs/documentation/world.html": {
    "href": "docs/documentation/world.html",
    "title": "Jitter World | Jitter2",
    "summary": "Jitter World An instance of the Jitter World class contains all entities in the physics simulation and provides the World.Step method to advance the simulation by a single time step. World.Step Forward the world by a single time step using Step(float dt, bool multiThread = true) Time step size Note Units in Jitter The unit system of Jitter is not explicitly defined. The engine utilizes 32-bit floating-point arithmetic and is optimized for objects with a size of 1 [len_unit]. For example, the collision system uses length thresholds on the order of 1e-04 [len_unit]. It assumes a unit density of 1 [mass_unit/len_unit³] for the mass properties of shapes. Consequently, the default mass of a unit cube is 1 [mass_unit]. The default value for gravity in Jitter is 9.81 [len_unit/time_unit²], which aligns with the gravitational acceleration on Earth in metric units (m/s²). Therefore, it is reasonable to use metric units (kg, m, s) when conceptualizing these values. The smaller the time step size, the more stable the simulation. Timesteps larger then \\(\\mathrm{dt}=1/60\\,\\mathrm{s}\\) are not adviced. It is also recommend to use fixed time steps. Typical code accumulates delta times and calls world.Step only at fixed time intervals, as shown in the following example. private float accumulatedTime = 0.0f; public void FixedTimeStep(float dt, int maxSteps = 4) { const float fixedStep = 1.0f / 100.0f; int steps = 0; accumulatedTime += dt; while (accumulatedTime > fixedStep) { world.Step(fixedStep, multiThread); accumulatedTime -= fixedStep; // we can not keep up with the real time, i.e. the simulation // is running slower than the real time is passing. if (++steps >= maxSteps) return; } } Multithreading Jitter employs its own thread pool (Parallelization.ThreadPool) to distribute tasks across multiple threads, potentially processed by multiple cores. Jitter utilizes the thread pool when the world.Step method is invoked with the multiThread argument set to true. By default Jitter spawns ThreadPool.ThreadCountSuggestion\\(-1\\) additional threads, where the suggestion is caculated by public const float ThreadsPerProcessor = 0.9f; public static int ThreadCountSuggestion => Math.Max((int)(Environment.ProcessorCount * ThreadsPerProcessor), 1); The number of worker threads managed by the thread pool can be adjusted using ChangeThreadCount(int numThreads). A singleton pattern is used here, as demonstrated below: ThreadPool.Instance.ChangeThreadCount(4); This adjusts the number of additional (with respect to the main thread) worker threads to \\(4-1=3\\). The world.ThreadModel property may be used to keep the thread pool in a tight loop waiting for work to be processed after world.Step has been run (ThreadModelType.Persistent), or to yield threads afterwards (ThreadModelType.Regular). The latter option is recommend to free processing power for other code, such as rendering. Solver Iterations Jitter employs an iterative solver to solve contacts and constraints. The number of iterations can be raised to improve simulation quality (world.SolverIterations). world.SolverIterations = (solver: 6, relaxation: 4); Jitter solves physical contacts (and constraints) on the velocity level ('solver iterations'). Jitter also adds velocities to rigid bodies to resolve unphysical interpenetrations of bodies. These additional velocities add unwanted energy to the system which can be removed by an additional relaxation phase after integrating the new positions from these velocities. The number of iterations in the relaxation phase ('relaxation iterations') is specified here as well. The runtime for solving contacts and constraints scales linearly with the number of iterations. Substep Count The time step can be divided into smaller steps, defined by world.SubstepCount. These smaller time steps are solved similiar to a regular full steps, however collision information is not updated. Each sub step is solved with the number of solver iterations specified in world.SolverIterations. For example world.SubstepCount = 4; world.SolverIterations = (solver: 2, relaxation: 1); does perform \\(12\\) solver iterations in total for each call to world.Step. The runtime is slower than a single regular step with \\(12\\) iterations but this approach enhances the stability of the simulation. Substepping is excellent for enhancing the overall quality of constraints, stabilizing large stacks of objects, and simulating large mass ratios (like heavy objects resting on light objects) with greater accuracy. Auxiliary Contacts Jitter employs a technique termed 'auxiliary contacts', where additional contacts are generated for the general case where two flat surfaces of shapes are in contact. These additional contacts are calculated within one frame, generating the full contact manifold in a 'single pass' and preventing jitter commonly encountered with incrementally constructed collision manifolds. The world.EnableAuxiliaryContactPoints property can be used to enable or disable the usage of auxiliary contact point generation. Rigid Bodies All rigid bodies registered with the world can be accessed using world.RigidBodies where RigidBodies is of type ReadOnlyActiveList<RigidBody>. The bodies are in no particular order and maybe reordered during calls to world.Step. Raw Data RigidBodies, Arbiters, and (Small)Constraints are regular C# classes that reside on the managed heap. However, these objects are linked to their unmanaged counterparts: RigidBodyData, ContactData, and (Small)ConstraintData which can be accessed using: world.RawData Jitter relocates native structures so that active objects are stored in contiguous memory, enabling efficient access by the iterative solver. Caution Raw Memory Access Accessing raw memory is generally not required when utilizing the standard functionalities of Jitter. Although reading the raw data of objects is generally safe, modifying data can corrupt the internal state of the engine. Warning Accessing Removed Entities Instances of RigidBody, Arbiter, and Constraint store some of their data in unmanaged memory, which is automatically freed once the entities are removed (world.Remove) from the world. These entities must not be used any longer, i.e., their functions and properties must not be called or accessed, otherwise, a NullReferenceException is thrown."
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Welcome | Jitter2",
    "summary": "Welcome You will find tutorials and documentation here. Work in progress. You can help by editing or adding new content."
  },
  "docs/tutorials/boxes/hello-world.html": {
    "href": "docs/tutorials/boxes/hello-world.html",
    "title": "Hello World | Jitter2",
    "summary": "Hello World We will now add physics to the scene. We do this by creating a new instance of the World class and adding several rigid bodies to it. Replace the content of Program.cs with the following code (marked lines indicate the additions to the source code): using System.Numerics; using Raylib_cs; using Jitter2; using Jitter2.Collision.Shapes; using Jitter2.Dynamics; using Jitter2.LinearMath; using static Raylib_cs.Raylib; static Matrix4x4 GetRayLibTransformMatrix(RigidBody body) { JMatrix ori = JMatrix.CreateFromQuaternion(body.Orientation); JVector pos = body.Position; return new Matrix4x4(ori.M11, ori.M12, ori.M13, pos.X, ori.M21, ori.M22, ori.M23, pos.Y, ori.M31, ori.M32, ori.M33, pos.Z, 0, 0, 0, 1.0f); } static Texture2D GenCheckedTexture(int size, int checks, Color colorA, Color colorB) { Image imageMag = GenImageChecked(size, size, checks, checks, colorA, colorB); Texture2D textureMag = LoadTextureFromImage(imageMag); UnloadImage(imageMag); return textureMag; } const int NumberOfBoxes = 12; // set a hint for anti-aliasing SetConfigFlags(ConfigFlags.Msaa4xHint); // initialize a 1200x800 px window with a title InitWindow(1200, 800, \"BoxDrop example\"); // dynamically create a plane model Texture2D texture = GenCheckedTexture(10, 1, Color.LightGray, Color.Gray); Model planeModel = LoadModelFromMesh(GenMeshPlane(10, 10, 10, 10)); SetMaterialTexture(ref planeModel, 0, MaterialMapIndex.Diffuse, ref texture); // dynamically create a box model texture = GenCheckedTexture(2, 1, Color.White, Color.Magenta); Mesh boxMesh = GenMeshCube(1, 1, 1); Material boxMat = LoadMaterialDefault(); SetMaterialTexture(ref boxMat, MaterialMapIndex.Diffuse, texture); // initialize the Jitter physics world World world = new (); world.SubstepCount = 4; // add a body representing the plane RigidBody planeBody = world.CreateRigidBody(); planeBody.AddShape(new BoxShape(10)); planeBody.Position = new JVector(0, -5, 0); planeBody.MotionType = MotionType.Static; // add NumberOfBoxes cubes for(int i = 0; i < NumberOfBoxes; i++) { RigidBody body = world.CreateRigidBody(); body.AddShape(new BoxShape(1)); body.Position = new JVector(0, i * 2 + 0.5f, 0); } // create a camera Camera3D camera = new () { Position = new Vector3(-20.0f, 8.0f, 10.0f), Target = new Vector3(0.0f, 4.0f, 0.0f), Up = new Vector3(0.0f, 1.0f, 0.0f), FovY = 45.0f, Projection = CameraProjection.Perspective }; // 100 fps target SetTargetFPS(100); // simple render loop while (!WindowShouldClose()) { BeginDrawing(); ClearBackground(Color.Blue); BeginMode3D(camera); DrawModel(planeModel, Vector3.Zero, 1.0f, Color.White); world.Step(1.0f / 100.0f, true); foreach(var body in world.RigidBodies) { if (body == planeBody || body == world.NullBody) continue; // do not draw this DrawMesh(boxMesh, boxMat, GetRayLibTransformMatrix(body)); } EndMode3D(); DrawText($\"{GetFPS()} fps\", 10, 10, 20, Color.White); EndDrawing(); } CloseWindow(); Running your program, you should now see a few boxes dynamically falling onto the ground."
  },
  "docs/tutorials/boxes/project-setup.html": {
    "href": "docs/tutorials/boxes/project-setup.html",
    "title": "Project Setup | Jitter2",
    "summary": "Project Setup In this project we will use Raylib and Jitter to implement a simple scene of boxes falling to the ground. Requirements Install the .NET 10 SDK. Ensure that dotnet is correctly set up by executing the following command: dotnet --version Create a New Console Application and Add Jitter and Raylib First, create a new directory named \"BoxDrop\" and navigate into it: mkdir BoxDrop && cd BoxDrop Next, create a new console application in this directory and add Raylib-cs and Jitter2: dotnet new console dotnet add package Raylib-cs --version 6.1.1 dotnet add package Jitter2 You have completed the setup. If you now execute the following command: dotnet run Your console should display: \"Hello, World!\"."
  },
  "docs/tutorials/boxes/render-loop.html": {
    "href": "docs/tutorials/boxes/render-loop.html",
    "title": "Render Loop | Jitter2",
    "summary": "Render Loop The first thing we need to do is to familiarize ourselves a bit with Raylib_cs. Replace the content of Program.cs with the following code: using System.Numerics; using Raylib_cs; using static Raylib_cs.Raylib; static Texture2D GenCheckedTexture(int size, int checks, Color colorA, Color colorB) { Image imageMag = GenImageChecked(size, size, checks, checks, colorA, colorB); Texture2D textureMag = LoadTextureFromImage(imageMag); UnloadImage(imageMag); return textureMag; } // set a hint for anti-aliasing SetConfigFlags(ConfigFlags.Msaa4xHint); // initialize a 1200x800 px window with a title InitWindow(1200, 800, \"BoxDrop example\"); // dynamically create a plane model Texture2D texture = GenCheckedTexture(10, 1, Color.LightGray, Color.Gray); Model planeModel = LoadModelFromMesh(GenMeshPlane(10, 10, 10, 10)); SetMaterialTexture(ref planeModel, 0, MaterialMapIndex.Diffuse, ref texture); // create a camera Camera3D camera = new () { Position = new Vector3(-20.0f, 8.0f, 10.0f), Target = new Vector3(0.0f, 4.0f, 0.0f), Up = new Vector3(0.0f, 1.0f, 0.0f), FovY = 45.0f, Projection = CameraProjection.Perspective }; // 100 fps target SetTargetFPS(100); // simple render loop while (!WindowShouldClose()) { BeginDrawing(); ClearBackground(Color.Blue); BeginMode3D(camera); DrawModel(planeModel, Vector3.Zero, 1.0f, Color.White); EndMode3D(); DrawText($\"{GetFPS()} fps\", 10, 10, 20, Color.White); EndDrawing(); } CloseWindow(); Running your program should now display a plane: We will add some physically simulated boxes in the next chapter."
  },
  "docs/tutorials/teapots/aftermath.html": {
    "href": "docs/tutorials/teapots/aftermath.html",
    "title": "Aftermath | Jitter2",
    "summary": "Aftermath PointCloudShape vs ConvexHullShape In this example, we used the PointCloudShape to simulate a rigid body with a convex hull. As the name suggests, this shape only requires a set of points — they don't need to lie exactly on a convex surface. By design, Jitter treats the convex hull of these points as the actual shape for collision detection. Although the algorithm used here is brute-force, it can be extremely fast: the data is stored in a linear memory layout, and SIMD instructions are used to accelerate the support function. Because of this, PointCloudShape is usually the best choice for quickly and efficiently adding simple convex geometry to your simulation. The ConvexHullShape, on the other hand, is intended for more complex and detailed convex models. Unlike PointCloudShape, this shape requires a precomputed convex hull provided as a list of triangles (List<JTriangle>). Jitter does not generate this for you — you'll need to use third-party tools like Blender or dedicated convex hull libraries. The input mesh must be strictly convex for collision detection to work correctly. Internally, ConvexHullShape uses a hill-climbing algorithm to compute the support function. While this approach is algorithmically more efficient than brute-force, the performance benefits only become noticeable with larger shapes. As a general rule of thumb, ConvexHullShape starts to outperform PointCloudShape at around 300 vertices or more."
  },
  "docs/tutorials/teapots/hello-world.html": {
    "href": "docs/tutorials/teapots/hello-world.html",
    "title": "Hello World | Jitter2",
    "summary": "Hello World Creating the PointCloudShape We can now create a PointCloudShape from the sampled vertices: // find a few points on the convex hull of the teapot. var vertices = ShapeHelper.SampleHull(allVertices, subdivisions: 3); // use these points to create a PointCloudShape. var pointCloudShape = new PointCloudShape(vertices); However, we need to be a bit careful here. If we add this shape to a rigid body as-is, the body may not behave as intuitively expected. This is because the center of mass of a rigid body is always located at (0, 0, 0) in its local coordinate frame. If you open teapot.obj in a model editor, you'll notice that the model is not centered around the origin. To correct this, we either need to center the model manually in a model editor—or, more conveniently, use the Shift property of PointCloudShape to align the center of mass with the origin: // find a few points on the convex hull of the teapot. var vertices = ShapeHelper.SampleHull(allVertices, subdivisions: 3); // use these points to create a PointCloudShape. var pointCloudShape = new PointCloudShape(vertices); // shift the shape so its center of mass is at the origin. pointCloudShape.GetCenter(out JVector centerOfMass); pointCloudShape.Shift = -centerOfMass; // pointCloudShape.GetCenter(out centerOfMass); // now returns (0, 0, 0) // finally, create the rigid body for the teapot var rigidBody = world.CreateRigidBody(); rigidBody.AddShape(pointCloudShape); Warning The shift applied to the shape must also be taken into account when rendering the model, to ensure it aligns visually with the simulation. Creating Multiple Instances of the Same Shape In Jitter, it is not valid to add the same shape instance to multiple rigid bodies. To create additional instances of a shape, use the Clone() method of PointCloudShape. This method creates a new shape object that shares the underlying data structure, saving both memory and computation time: var shapeInstance1 = new PointCloudShape(vertices); var shapeInstance2 = shapeInstance1.Clone(); // Safe to use in a second body This approach is especially useful when many bodies share the same geometry, such as multiple identical props or characters in a simulation. Putting it all together using System.Numerics; using Raylib_cs; using Jitter2; using Jitter2.Collision.Shapes; using Jitter2.Dynamics; using Jitter2.LinearMath; using static Raylib_cs.Raylib; static Matrix4x4 GetRayLibTransformMatrix(RigidBody body) { JMatrix ori = JMatrix.CreateFromQuaternion(body.Orientation); JVector pos = body.Position; return new Matrix4x4(ori.M11, ori.M12, ori.M13, pos.X, ori.M21, ori.M22, ori.M23, pos.Y, ori.M31, ori.M32, ori.M33, pos.Z, 0, 0, 0, 1.0f); } static Texture2D GenCheckedTexture(int size, int checks, Color colorA, Color colorB) { Image imageMag = GenImageChecked(size, size, checks, checks, colorA, colorB); Texture2D textureMag = LoadTextureFromImage(imageMag); UnloadImage(imageMag); return textureMag; } const int numberOfTeapots = 12; // set a hint for anti-aliasing SetConfigFlags(ConfigFlags.Msaa4xHint); // initialize a 1200x800 px window with a title InitWindow(1200, 800, \"TeaDrop example\"); // dynamically create a plane model Texture2D texture = GenCheckedTexture(10, 1, Color.LightGray, Color.Gray); Model planeModel = LoadModelFromMesh(GenMeshPlane(20, 20, 10, 10)); SetMaterialTexture(ref planeModel, 0, MaterialMapIndex.Diffuse, ref texture); // load the teapot model from file Model teapotModel = LoadModel(\"teapot.obj\"); // load the mesh vertices if (teapotModel.MeshCount == 0) throw new Exception(\"Model could not be loaded!\"); Mesh teapotMesh; unsafe { teapotMesh = teapotModel.Meshes[0]; } var allVertices = teapotMesh.VerticesAs<JVector>(); // sample vertices on the convex hull var vertices = ShapeHelper.SampleHull(allVertices, 4); // create the PointCloudShape from the reduced vertices var pointCloudShape = new PointCloudShape(vertices); // shift the shape, such that the center of mass is at the origin pointCloudShape.GetCenter(out JVector center); pointCloudShape.Shift = -center; // we need to take the transpose here, since Raylib and System.Numerics // use a different convention Matrix4x4 shift = Matrix4x4.CreateTranslation(-center); shift = Matrix4x4.Transpose(shift); texture = GenCheckedTexture(16, 2, Color.White, Color.Magenta); Material teapotMat = LoadMaterialDefault(); SetMaterialTexture(ref teapotMat, MaterialMapIndex.Diffuse, texture); // initialize the Jitter physics world World world = new (); world.SubstepCount = 4; // add a body representing the plane RigidBody planeBody = world.CreateRigidBody(); planeBody.AddShape(new BoxShape(20)); planeBody.Position = new JVector(0, -10, 0); planeBody.MotionType = MotionType.Static; // add numberOfTeapots teapots for(int i = 0; i < numberOfTeapots; i++) { RigidBody body = world.CreateRigidBody(); body.AddShape(pointCloudShape.Clone()); body.Position = new JVector(0, i * 4 + 0.5f, 0); } // create a camera Camera3D camera = new () { Position = new Vector3(-40.0f, 16.0f, 20.0f), Target = new Vector3(0.0f, 4.0f, 0.0f), Up = new Vector3(0.0f, 1.0f, 0.0f), FovY = 45.0f, Projection = CameraProjection.Perspective }; // 100 fps target SetTargetFPS(100); // simple render loop while (!WindowShouldClose()) { BeginDrawing(); ClearBackground(Color.Blue); BeginMode3D(camera); DrawModel(planeModel, Vector3.Zero, 1.0f, Color.White); world.Step(1.0f / 100.0f, true); foreach(var body in world.RigidBodies) { if (body == planeBody || body == world.NullBody) continue; // do not draw this DrawMesh(teapotMesh, teapotMat, GetRayLibTransformMatrix(body) * shift); } EndMode3D(); DrawText($\"{GetFPS()} fps\", 10, 10, 20, Color.White); EndDrawing(); } CloseWindow();"
  },
  "docs/tutorials/teapots/hull-sampling.html": {
    "href": "docs/tutorials/teapots/hull-sampling.html",
    "title": "Hull Sampling | Jitter2",
    "summary": "Hull Sampling The teapot is a concave shape, which we will approximate using its convex hull (Wikipedia). As a first step, we will reduce the number of vertices used to construct the convex hull. Note Sampling We could work with the entire set of vertices, but this comes with two main disadvantages: The set may include vertices that lie inside the hull. While these do not affect the simulation outcome, they are still briefly considered during collision detection in each frame. We typically don't need an exact convex hull. Omitting a few vertices often has little effect on accuracy while significantly improving performance. Reducing the number of vertices can help speed up the simulation without sacrificing collision fidelity. Jitter provides a built-in method to simplify the vertex set: ShapeHelper.SampleHull. This function samples directions uniformly across the unit sphere and returns the vertices that are furthest away in those directions. These vertices, by definition, lie on the convex hull of the original shape. Replace the content of Program.cs with the following code: using System.Numerics; using Jitter2.Collision.Shapes; using Jitter2.LinearMath; using Raylib_cs; using static Raylib_cs.Raylib; // set a hint for anti-aliasing SetConfigFlags(ConfigFlags.Msaa4xHint); // initialize a 1200x800 px window with a title InitWindow(1200, 800, \"TeaDrop example\"); // load the teapot model from a file Model teapotModel = LoadModel(\"teapot.obj\"); // load the mesh vertices if (teapotModel.MeshCount == 0) throw new Exception(\"Model could not be loaded!\"); Mesh mesh; unsafe { mesh = teapotModel.Meshes[0]; } var allVertices = mesh.VerticesAs<JVector>(); var vertices = ShapeHelper.SampleHull(allVertices, 4); // just for visualization - // we will not need to construct the explicit hull for the simulation! var debugHull = ShapeHelper.Tessellate(vertices, 4); // create a camera Camera3D camera = new () { Position = new Vector3(-5.0f, 2.0f, 3.0f), Target = new Vector3(0.0f, 1.0f, 0.0f), Up = new Vector3(0.0f, 1.0f, 0.0f), FovY = 45.0f, Projection = CameraProjection.Perspective }; // 100 fps target SetTargetFPS(100); // simple render loop while (!WindowShouldClose()) { BeginDrawing(); ClearBackground(Color.Blue); // make the scene rotate UpdateCamera(ref camera, CameraMode.Orbital); BeginMode3D(camera); // draw the teapot model DrawModelWires(teapotModel, Vector3.Zero, 1.0f, Color.White); // draw the sample vertices of the convex hull foreach (var vertex in vertices) { DrawSphere(vertex, 0.02f, Color.Red); } // for debugging: draw the explicit hull foreach (var vertex in debugHull) { DrawLine3D(vertex.V0, vertex.V1, Color.Green); DrawLine3D(vertex.V1, vertex.V2, Color.Green); DrawLine3D(vertex.V2, vertex.V0, Color.Green); } EndMode3D(); DrawText($\"{GetFPS()} fps\", 10, 10, 20, Color.White); EndDrawing(); } CloseWindow(); The teapot's wireframe is drawn in white, the green wireframe shows the convex hull, and the sampled hull vertices are depicted as red dots."
  },
  "docs/tutorials/teapots/project-setup.html": {
    "href": "docs/tutorials/teapots/project-setup.html",
    "title": "Project Setup | Jitter2",
    "summary": "Project Setup In the previous section, we created a simulation of falling boxes. Jitter includes several default shapes, such as capsules, cylinders, and spheres. These shapes can be transformed and/or combined, and they are already sufficient to represent many types of collidable entities. In this section, we will add a custom convex shape to the simulation—specifically, the famous Utah teapot. We'll construct this shape from its visual representation by loading a teapot.obj file and using its vertices to create the convex shape. Requirements Install the .NET 10 SDK. Ensure that dotnet is correctly set up by executing the following command: dotnet --version Create a New Console Application and Add Jitter and Raylib First, create a new directory named \"TeaDrop\" and navigate into it: mkdir TeaDrop && cd TeaDrop Download and unzip the teapot.obj model. wget https://github.com/notgiven688/jitterphysics2/raw/refs/heads/main/src/JitterDemo/assets/teapot.obj.zip unzip teapot.obj.zip Next, create a new console application in this directory and add Raylib-cs and Jitter2: dotnet new console dotnet add package Raylib-cs --version 6.1.1 dotnet add package Jitter2 Add the following code to TeaDrop.csproj to allow unsafe code, and to copy teapot.obj automatically to the output directory: <PropertyGroup> <AllowUnsafeBlocks>true</AllowUnsafeBlocks> </PropertyGroup> <ItemGroup> <None Update=\"teapot.obj\"> <CopyToOutputDirectory>Always</CopyToOutputDirectory> </None> </ItemGroup> You have completed the setup. If you now execute the following command: dotnet run Your console should display: \"Hello, World!\"."
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "summary": ""
  }
}