{
  "api/Jitter2.CallbackThreadAttribute.html": {
    "href": "api/Jitter2.CallbackThreadAttribute.html",
    "title": "Class CallbackThreadAttribute | Jitter2",
    "summary": "Class CallbackThreadAttribute Namespace Jitter2 Assembly Jitter2.dll Indicates the thread context in which a callback or event is expected to be invoked. This attribute is primarily informational and used for documentation purposes. [AttributeUsage(AttributeTargets.Method|AttributeTargets.Event)] public sealed class CallbackThreadAttribute : Attribute Inheritance object Attribute CallbackThreadAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors CallbackThreadAttribute(ThreadContext) Indicates the thread context in which a callback or event is expected to be invoked. This attribute is primarily informational and used for documentation purposes. public CallbackThreadAttribute(ThreadContext context) Parameters context ThreadContext Properties Context Gets the thread context in which the attributed member is expected to be invoked. public ThreadContext Context { get; } Property Value ThreadContext"
  },
  "api/Jitter2.Collision.CollisionManifold.html": {
    "href": "api/Jitter2.Collision.CollisionManifold.html",
    "title": "Struct CollisionManifold | Jitter2",
    "summary": "Struct CollisionManifold Namespace Jitter2.Collision Assembly Jitter2.dll Represents a contact manifold between two convex shapes, storing up to six contact points. public struct CollisionManifold Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The manifold is constructed by projecting support points along perturbed normals in a hexagonal pattern around the collision normal, then clipping to find the contact region. Properties Count Gets the number of contact points in the manifold. public readonly int Count { get; } Property Value int ManifoldA Gets a span of contact points on shape A. Valid indices are [0, Count). public Span<JVector> ManifoldA { get; } Property Value Span<JVector> ManifoldB Gets a span of contact points on shape B. Valid indices are [0, Count). public Span<JVector> ManifoldB { get; } Property Value Span<JVector> Methods BuildManifold<TA, TB>(TA, TB, in JQuaternion, in JQuaternion, in JVector, in JVector, in JVector, in JVector, in JVector) Builds the contact manifold between two shapes given their transforms and initial contact. public void BuildManifold<TA, TB>(TA shapeA, TB shapeB, in JQuaternion quaternionA, in JQuaternion quaternionB, in JVector positionA, in JVector positionB, in JVector pA, in JVector pB, in JVector normal) where TA : ISupportMappable where TB : ISupportMappable Parameters shapeA TA The first shape. shapeB TB The second shape. quaternionA JQuaternion Orientation of shape A. quaternionB JQuaternion Orientation of shape B. positionA JVector Position of shape A. positionB JVector Position of shape B. pA JVector Initial contact point on shape A. pB JVector Initial contact point on shape B. normal JVector The collision normal (from B to A). Type Parameters TA The type of support shape A. TB The type of support shape B. BuildManifold<TA, TB>(TA, TB, in JVector, in JVector, in JVector) Builds the contact manifold between two rigid body shapes using their current transforms. public void BuildManifold<TA, TB>(TA shapeA, TB shapeB, in JVector pA, in JVector pB, in JVector normal) where TA : RigidBodyShape where TB : RigidBodyShape Parameters shapeA TA The first rigid body shape. shapeB TB The second rigid body shape. pA JVector Initial contact point on shape A. pB JVector Initial contact point on shape B. normal JVector The collision normal (from B to A). Type Parameters TA The type of shape A. TB The type of shape B."
  },
  "api/Jitter2.Collision.ConvexPolytope.Triangle.html": {
    "href": "api/Jitter2.Collision.ConvexPolytope.Triangle.html",
    "title": "Struct ConvexPolytope.Triangle | Jitter2",
    "summary": "Struct ConvexPolytope.Triangle Namespace Jitter2.Collision Assembly Jitter2.dll public struct ConvexPolytope.Triangle Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public short A Field Value short B public short B Field Value short C public short C Field Value short ClosestToOrigin public JVector ClosestToOrigin Field Value JVector ClosestToOriginSq public float ClosestToOriginSq Field Value float FacingOrigin public bool FacingOrigin Field Value bool Normal public JVector Normal Field Value JVector NormalSq public float NormalSq Field Value float Properties this[int] public short this[int i] { get; } Parameters i int Property Value short"
  },
  "api/Jitter2.Collision.ConvexPolytope.html": {
    "href": "api/Jitter2.Collision.ConvexPolytope.html",
    "title": "Struct ConvexPolytope | Jitter2",
    "summary": "Struct ConvexPolytope Namespace Jitter2.Collision Assembly Jitter2.dll Represents a convex polytope builder used in the Expanding Polytope Algorithm (EPA) for computing penetration depth and contact information. public struct ConvexPolytope Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The polytope is iteratively expanded by adding vertices from the Minkowski difference until convergence. Call InitHeap() at least once before use to allocate memory for vertices and triangles. Memory is allocated from the unmanaged heap and reused across EPA iterations. Properties HullTriangles public readonly Span<ConvexPolytope.Triangle> HullTriangles { get; } Property Value Span<ConvexPolytope.Triangle> OriginEnclosed Indicates whether the origin is enclosed within the polyhedron. Important: This property returns correct values after invoking GetClosestTriangle(). public readonly bool OriginEnclosed { get; } Property Value bool Methods AddVertex(in Vertex) Adds a vertex to the polytope and rebuilds the convex hull. public bool AddVertex(in MinkowskiDifference.Vertex vertex) Parameters vertex MinkowskiDifference.Vertex The Minkowski difference vertex to add. Returns bool true if the vertex was incorporated; false if the polytope could not expand. Remarks This operation invalidates references from previous GetClosestTriangle() calls. CalculatePoints(in Triangle, out JVector, out JVector) Computes the closest points on shapes A and B from a triangle on the polytope. public void CalculatePoints(in ConvexPolytope.Triangle ctri, out JVector pA, out JVector pB) Parameters ctri ConvexPolytope.Triangle The triangle from GetClosestTriangle(). pA JVector The closest point on shape A. pB JVector The closest point on shape B. GetClosestTriangle() Finds the triangle on the polytope closest to the origin. public ref ConvexPolytope.Triangle GetClosestTriangle() Returns ConvexPolytope.Triangle A reference to the closest triangle. Also updates OriginEnclosed. GetVertex(int) public ref MinkowskiDifference.Vertex GetVertex(int index) Parameters index int Returns MinkowskiDifference.Vertex InitHeap() Allocates unmanaged memory for vertices and triangles. public void InitHeap() Remarks Must be called before any other method. Safe to call multiple times; allocation occurs only once. InitTetrahedron() Initializes the polytope with a tetrahedron formed from the first four vertices. public void InitTetrahedron() Remarks The first four vertices must be set before calling this method. InitTetrahedron(in JVector) Initializes the polytope with a small tetrahedron centered at the specified point. public void InitTetrahedron(in JVector point) Parameters point JVector The center point of the initial tetrahedron."
  },
  "api/Jitter2.Collision.DynamicTree.Node.html": {
    "href": "api/Jitter2.Collision.DynamicTree.Node.html",
    "title": "Struct DynamicTree.Node | Jitter2",
    "summary": "Struct DynamicTree.Node Namespace Jitter2.Collision Assembly Jitter2.dll Represents a node in the AABB tree. public struct DynamicTree.Node Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ExpandedBox The expanded bounding box of this node, used for broadphase culling. For leaf nodes, this is the proxy's bounding box expanded by velocity and a margin. For internal nodes, this is the union of its children's boxes. public TreeBox ExpandedBox Field Value TreeBox ForceUpdate When set, forces the node to be updated in the next Update(bool, float) call, even if its bounding box hasn't changed. public bool ForceUpdate Field Value bool Left Index of the left child node, or NullNode if this is a leaf. public int Left Field Value int Parent Index of the parent node, or NullNode if this is the root. public int Parent Field Value int Proxy The proxy associated with this node, or null for internal nodes. public IDynamicTreeProxy? Proxy Field Value IDynamicTreeProxy Right Index of the right child node, or NullNode if this is a leaf. public int Right Field Value int Properties IsLeaf Returns true if this is a leaf node (has an associated proxy). public readonly bool IsLeaf { get; } Property Value bool"
  },
  "api/Jitter2.Collision.DynamicTree.RayCastFilterPost.html": {
    "href": "api/Jitter2.Collision.DynamicTree.RayCastFilterPost.html",
    "title": "Delegate DynamicTree.RayCastFilterPost | Jitter2",
    "summary": "Delegate DynamicTree.RayCastFilterPost Namespace Jitter2.Collision Assembly Jitter2.dll Delegate for filtering ray cast results after the shape intersection test. public delegate bool DynamicTree.RayCastFilterPost(DynamicTree.RayCastResult result) Parameters result DynamicTree.RayCastResult The ray cast result to evaluate. Returns bool false to filter out this hit; true to keep it."
  },
  "api/Jitter2.Collision.DynamicTree.RayCastFilterPre.html": {
    "href": "api/Jitter2.Collision.DynamicTree.RayCastFilterPre.html",
    "title": "Delegate DynamicTree.RayCastFilterPre | Jitter2",
    "summary": "Delegate DynamicTree.RayCastFilterPre Namespace Jitter2.Collision Assembly Jitter2.dll Delegate for filtering ray cast candidates before the shape intersection test. public delegate bool DynamicTree.RayCastFilterPre(IDynamicTreeProxy result) Parameters result IDynamicTreeProxy The proxy to evaluate. Returns bool false to skip this proxy; true to test it."
  },
  "api/Jitter2.Collision.DynamicTree.RayCastResult.html": {
    "href": "api/Jitter2.Collision.DynamicTree.RayCastResult.html",
    "title": "Struct DynamicTree.RayCastResult | Jitter2",
    "summary": "Struct DynamicTree.RayCastResult Namespace Jitter2.Collision Assembly Jitter2.dll Represents the result of a ray cast against the dynamic tree. public struct DynamicTree.RayCastResult Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Entity The proxy that was hit. public IDynamicTreeProxy Entity Field Value IDynamicTreeProxy Lambda The ray parameter at the hit: hitPoint = origin + Lambda * direction. public float Lambda Field Value float Normal The surface normal at the hit point. public JVector Normal Field Value JVector"
  },
  "api/Jitter2.Collision.DynamicTree.Timings.html": {
    "href": "api/Jitter2.Collision.DynamicTree.Timings.html",
    "title": "Enum DynamicTree.Timings | Jitter2",
    "summary": "Enum DynamicTree.Timings Namespace Jitter2.Collision Assembly Jitter2.dll Profiling buckets for DebugTimings, representing stages of Update(bool, float). public enum DynamicTree.Timings Fields Last = 5 Sentinel value for array sizing. Not a real timing bucket. PruneInvalidPairs = 0 Time spent removing stale pairs from the potential pairs set. ScanMoved = 2 Time spent scanning for proxies that moved outside their expanded boxes. ScanOverlaps = 4 Time spent scanning for new overlapping pairs. UpdateBoundingBoxes = 1 Time spent updating proxy bounding boxes. UpdateProxies = 3 Time spent reinserting moved proxies into the tree."
  },
  "api/Jitter2.Collision.DynamicTree.html": {
    "href": "api/Jitter2.Collision.DynamicTree.html",
    "title": "Class DynamicTree | Jitter2",
    "summary": "Class DynamicTree Namespace Jitter2.Collision Assembly Jitter2.dll Represents a dynamic AABB tree for broadphase collision detection. public class DynamicTree Inheritance object DynamicTree Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Uses a bounding volume hierarchy with Surface Area Heuristic (SAH) for efficient insertion and query operations. Supports incremental updates for moving objects. Complexity: O(log n) for insertion/removal, O(n) worst-case for overlap queries. Constructors DynamicTree(Func<IDynamicTreeProxy, IDynamicTreeProxy, bool>) Initializes a new instance of the DynamicTree class. public DynamicTree(Func<IDynamicTreeProxy, IDynamicTreeProxy, bool> filter) Parameters filter Func<IDynamicTreeProxy, IDynamicTreeProxy, bool> A collision filter function, used in Jitter to exclude collisions between Shapes belonging to the same body. The collision is filtered out if the function returns false. Fields DebugTimings Contains timings for the stages of the last call to Update(bool, float). Values are in milliseconds. Index using (int)Timings.XYZ. public readonly double[] DebugTimings Field Value double[] ExpandEps Specifies a small additional expansion of the bounding box which is constant. public const float ExpandEps = 0.1 Field Value float ExpandFactor Specifies the factor by which the bounding box in the dynamic tree structure is expanded. The expansion is calculated as Velocity * ExpandFactor * (1 + alpha), where alpha is a pseudo-random number in the range [0, 1]. public const float ExpandFactor = 0.1 Field Value float InitialSize Initial capacity of the internal node array. public const int InitialSize = 1024 Field Value int Nodes The internal array of tree nodes. Exposed for advanced scenarios such as debugging or visualization. public DynamicTree.Node[] Nodes Field Value Node[] Remarks This array may be resized during tree operations. Do not cache references to elements. NullNode Sentinel value indicating a null/invalid node index. public const int NullNode = -1 Field Value int PruningFraction Fraction of the potential pairs hash set to scan per update for pruning invalid entries. A value of 128 means 1/128th of the hash set is scanned each update. public const int PruningFraction = 128 Field Value int Properties Filter Gets or sets the filter function used to exclude proxy pairs from collision detection. public Func<IDynamicTreeProxy, IDynamicTreeProxy, bool> Filter { get; set; } Property Value Func<IDynamicTreeProxy, IDynamicTreeProxy, bool> Remarks The filter is called during overlap enumeration. Return false to exclude a pair. In Jitter, this is typically used to exclude shapes belonging to the same rigid body. HashSetInfo Retrieve information of the size and filling of the internal hash set used to store potential overlaps. public (int TotalSize, int Count) HashSetInfo { get; } Property Value (int solver, int relaxation) Proxies Gets a read-only view of all proxies registered with this tree. public ReadOnlyPartitionedSet<IDynamicTreeProxy> Proxies { get; } Property Value ReadOnlyPartitionedSet<IDynamicTreeProxy> Root Gets the index of the root node, or NullNode if the tree is empty. public int Root { get; } Property Value int UpdatedProxyCount Gets the number of updated proxies during the last call to Update(bool, float). public int UpdatedProxyCount { get; } Property Value int Methods ActivateProxy<T>(T) Marks a proxy as active, causing it to be tracked for movement during updates. public void ActivateProxy<T>(T proxy) where T : class, IDynamicTreeProxy Parameters proxy T The proxy to activate. Type Parameters T The proxy type. AddProxy<T>(T, bool) Adds a proxy to the tree. public void AddProxy<T>(T proxy, bool active = true) where T : class, IDynamicTreeProxy Parameters proxy T The proxy to add. active bool If true, the proxy is tracked for movement each update. Type Parameters T The proxy type. Exceptions InvalidOperationException Thrown if the proxy is already in this tree. CalculateCost() Calculates the SAH cost of the tree (sum of all node surface areas). public double CalculateCost() Returns double The total cost. Lower values indicate a more balanced tree. DeactivateProxy<T>(T) Marks a proxy as inactive, assuming it will not move outside its expanded bounding box. public void DeactivateProxy<T>(T proxy) where T : class, IDynamicTreeProxy Parameters proxy T The proxy to deactivate. Type Parameters T The proxy type. EnumerateOverlaps(Action<IDynamicTreeProxy, IDynamicTreeProxy>, bool) Enumerates all potential collision pairs and invokes the specified action for each. public void EnumerateOverlaps(Action<IDynamicTreeProxy, IDynamicTreeProxy> action, bool multiThread = false) Parameters action Action<IDynamicTreeProxy, IDynamicTreeProxy> The action to invoke for each overlapping pair. multiThread bool If true, uses multithreading for enumeration. EnumerateTreeBoxes(Action<TreeBox, int>) Enumerates all axis-aligned bounding boxes in the tree. public void EnumerateTreeBoxes(Action<TreeBox, int> action) Parameters action Action<TreeBox, int> The action to perform on each bounding box and node height in the tree. IsActive<T>(T) Checks whether the specified proxy is currently active. public bool IsActive<T>(T proxy) where T : class, IDynamicTreeProxy Parameters proxy T The proxy to check. Returns bool true if the proxy is active; otherwise, false. Type Parameters T The proxy type. Optimize(Func<double>, int, float, bool) Optimizes the tree structure by randomly reinserting proxies. public void Optimize(Func<double> getNextRandom, int sweeps, float chance, bool incremental) Parameters getNextRandom Func<double> A function returning random values in [0, 1). sweeps int Number of optimization passes. Must be greater than zero. chance float Probability of reinserting each proxy per sweep. Range: [0, 1]. incremental bool If false, all proxies are reinserted in random order on the first sweep. Optimize(int, float, bool) Optimizes the tree structure by randomly reinserting proxies. public void Optimize(int sweeps = 100, float chance = 0.01, bool incremental = false) Parameters sweeps int Number of optimization passes. Must be greater than zero. chance float Probability of reinserting each proxy per sweep. Range: [0, 1]. incremental bool If false, all proxies are reinserted in random order on the first sweep. Query<T>(T, in JBoundingBox) Queries the tree for proxies overlapping an axis-aligned bounding box. public void Query<T>(T hits, in JBoundingBox box) where T : ICollection<IDynamicTreeProxy> Parameters hits T Collection to store overlapping proxies. box JBoundingBox The bounding box to query. Type Parameters T The collection type. Query<T>(T, JVector, JVector) Queries the tree for proxies intersecting a ray. public void Query<T>(T hits, JVector rayOrigin, JVector rayDirection) where T : ICollection<IDynamicTreeProxy> Parameters hits T Collection to store intersected proxies. rayOrigin JVector The origin of the ray. rayDirection JVector The direction of the ray. Type Parameters T The collection type. RayCast(JVector, JVector, RayCastFilterPre?, RayCastFilterPost?, out IDynamicTreeProxy?, out JVector, out float) Ray cast against the world. public bool RayCast(JVector origin, JVector direction, DynamicTree.RayCastFilterPre? pre, DynamicTree.RayCastFilterPost? post, out IDynamicTreeProxy? proxy, out JVector normal, out float lambda) Parameters origin JVector Origin of the ray. direction JVector Direction of the ray. Does not have to be normalized. pre DynamicTree.RayCastFilterPre Optional pre-filter which allows to skip shapes in the detection. post DynamicTree.RayCastFilterPost Optional post-filter which allows to skip detections. proxy IDynamicTreeProxy The shape which was hit. normal JVector The normal of the surface where the ray hits. Zero if ray does not hit. lambda float Distance from the origin to the ray hit point in units of the ray's direction. Returns bool True if the ray hits, false otherwise. RayCast(JVector, JVector, float, RayCastFilterPre?, RayCastFilterPost?, out IDynamicTreeProxy?, out JVector, out float) Ray cast against the world. public bool RayCast(JVector origin, JVector direction, float maxLambda, DynamicTree.RayCastFilterPre? pre, DynamicTree.RayCastFilterPost? post, out IDynamicTreeProxy? proxy, out JVector normal, out float lambda) Parameters origin JVector Origin of the ray. direction JVector Direction of the ray. Does not have to be normalized. maxLambda float Maximum lambda of the ray's length to consider for intersections. pre DynamicTree.RayCastFilterPre Optional pre-filter which allows to skip shapes in the detection. post DynamicTree.RayCastFilterPost Optional post-filter which allows to skip detections. proxy IDynamicTreeProxy The shape which was hit. normal JVector The normal of the surface where the ray hits. Zero if ray does not hit. lambda float Distance from the origin to the ray hit point in units of the ray's direction. Returns bool True if the ray hits, false otherwise. RemoveProxy(IDynamicTreeProxy) Removes a proxy from the tree. public void RemoveProxy(IDynamicTreeProxy proxy) Parameters proxy IDynamicTreeProxy The proxy to remove. Exceptions InvalidOperationException Thrown if the proxy is not in this tree. Update(bool, float) Updates all active proxies in the tree. public void Update(bool multiThread, float dt) Parameters multiThread bool If true, uses multithreading for the update. dt float The timestep in seconds, used for velocity-based bounding box expansion. Update<T>(T) Forces an immediate update of a single proxy in the tree. public void Update<T>(T proxy) where T : class, IDynamicTreeProxy Parameters proxy T The proxy to update. Type Parameters T The proxy type."
  },
  "api/Jitter2.Collision.IBroadPhaseFilter.html": {
    "href": "api/Jitter2.Collision.IBroadPhaseFilter.html",
    "title": "Interface IBroadPhaseFilter | Jitter2",
    "summary": "Interface IBroadPhaseFilter Namespace Jitter2.Collision Assembly Jitter2.dll Provides a hook into the broadphase collision detection pipeline. public interface IBroadPhaseFilter Remarks Implement this interface to intercept shape pairs before narrowphase detection. This can be used to filter out specific pairs, implement custom collision layers, or handle collisions for custom proxy types. See BroadPhaseFilter. Methods Filter(IDynamicTreeProxy, IDynamicTreeProxy) Called for each pair of proxies whose bounding boxes overlap. [CallbackThread(ThreadContext.Any)] bool Filter(IDynamicTreeProxy proxyA, IDynamicTreeProxy proxyB) Parameters proxyA IDynamicTreeProxy The first proxy. proxyB IDynamicTreeProxy The second proxy. Returns bool true to continue with narrowphase detection; false to skip this pair."
  },
  "api/Jitter2.Collision.IDynamicTreeProxy.html": {
    "href": "api/Jitter2.Collision.IDynamicTreeProxy.html",
    "title": "Interface IDynamicTreeProxy | Jitter2",
    "summary": "Interface IDynamicTreeProxy Namespace Jitter2.Collision Assembly Jitter2.dll Represents an entity that can be tracked by the DynamicTree for broadphase collision detection. public interface IDynamicTreeProxy : IPartitionedSetIndex Inherited Members IPartitionedSetIndex.SetIndex Properties NodePtr Gets or sets the internal node pointer used by the tree. int NodePtr { get; set; } Property Value int Remarks This value is managed internally by DynamicTree. Do not modify directly. Velocity Gets the velocity of the entity, used for bounding box expansion. JVector Velocity { get; } Property Value JVector WorldBoundingBox Gets the axis-aligned bounding box of the entity in world space. JBoundingBox WorldBoundingBox { get; } Property Value JBoundingBox"
  },
  "api/Jitter2.Collision.INarrowPhaseFilter.html": {
    "href": "api/Jitter2.Collision.INarrowPhaseFilter.html",
    "title": "Interface INarrowPhaseFilter | Jitter2",
    "summary": "Interface INarrowPhaseFilter Namespace Jitter2.Collision Assembly Jitter2.dll Provides a hook into the narrowphase collision detection pipeline. public interface INarrowPhaseFilter Remarks Implement this interface to intercept collisions after contact generation. This can be used to modify contact data, implement custom collision responses, or filter out specific collisions. Methods Filter(RigidBodyShape, RigidBodyShape, ref JVector, ref JVector, ref JVector, ref float) Called for each detected collision with its contact data. [CallbackThread(ThreadContext.Any)] bool Filter(RigidBodyShape shapeA, RigidBodyShape shapeB, ref JVector pointA, ref JVector pointB, ref JVector normal, ref float penetration) Parameters shapeA RigidBodyShape The first shape in the collision. shapeB RigidBodyShape The second shape in the collision. pointA JVector Contact point on shape A (modifiable). pointB JVector Contact point on shape B (modifiable). normal JVector Collision normal from B to A (modifiable). penetration float Penetration depth (modifiable). Returns bool true to keep the collision; false to discard it."
  },
  "api/Jitter2.Collision.IRayCastable.html": {
    "href": "api/Jitter2.Collision.IRayCastable.html",
    "title": "Interface IRayCastable | Jitter2",
    "summary": "Interface IRayCastable Namespace Jitter2.Collision Assembly Jitter2.dll Represents an entity that can be intersected by a ray. public interface IRayCastable Methods RayCast(in JVector, in JVector, out JVector, out float) Performs a ray cast against this object. bool RayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda) Parameters origin JVector The starting point of the ray. direction JVector The direction of the ray. Does not need to be normalized. normal JVector The surface normal at the intersection point. lambda float The distance along the ray to the intersection: hitPoint = origin + lambda * direction. Returns bool true if the ray intersects with the object; otherwise, false."
  },
  "api/Jitter2.Collision.ISupportMappable.html": {
    "href": "api/Jitter2.Collision.ISupportMappable.html",
    "title": "Interface ISupportMappable | Jitter2",
    "summary": "Interface ISupportMappable Namespace Jitter2.Collision Assembly Jitter2.dll Defines an interface for a generic convex shape characterized by its support function. public interface ISupportMappable Remarks The support function is the fundamental operation for GJK-based collision detection algorithms. Any convex shape can be represented implicitly through its support mapping without requiring explicit vertex or face data. Methods GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction."
  },
  "api/Jitter2.Collision.IUpdatableBoundingBox.html": {
    "href": "api/Jitter2.Collision.IUpdatableBoundingBox.html",
    "title": "Interface IUpdatableBoundingBox | Jitter2",
    "summary": "Interface IUpdatableBoundingBox Namespace Jitter2.Collision Assembly Jitter2.dll Represents an entity whose bounding box can be recomputed. public interface IUpdatableBoundingBox Methods UpdateWorldBoundingBox(float) Recomputes the world-space bounding box. void UpdateWorldBoundingBox(float dt = 0) Parameters dt float The timestep for velocity-based expansion. Default is zero."
  },
  "api/Jitter2.Collision.Island.html": {
    "href": "api/Jitter2.Collision.Island.html",
    "title": "Class Island | Jitter2",
    "summary": "Class Island Namespace Jitter2.Collision Assembly Jitter2.dll Represents an island, which is a collection of bodies that are either directly or indirectly in contact with each other. public sealed class Island : IPartitionedSetIndex Inheritance object Island Implements IPartitionedSetIndex Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Island() Initializes a new instance of the Island class. public Island() Properties Bodies Gets a collection of all the bodies present in this island. public ReadOnlyHashSet<RigidBody> Bodies { get; } Property Value ReadOnlyHashSet<RigidBody>"
  },
  "api/Jitter2.Collision.MinkowskiDifference.Vertex.html": {
    "href": "api/Jitter2.Collision.MinkowskiDifference.Vertex.html",
    "title": "Struct MinkowskiDifference.Vertex | Jitter2",
    "summary": "Struct MinkowskiDifference.Vertex Namespace Jitter2.Collision Assembly Jitter2.dll Represents a vertex on the Minkowski difference of two shapes. public struct MinkowskiDifference.Vertex Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Vertex(JVector) Creates a vertex with only the difference point set. public Vertex(JVector v) Parameters v JVector The Minkowski difference point. Fields A The support point on shape A in world space. public JVector A Field Value JVector B The support point on shape B in world space. public JVector B Field Value JVector V The point on the Minkowski difference: V = A - B. public JVector V Field Value JVector"
  },
  "api/Jitter2.Collision.MinkowskiDifference.html": {
    "href": "api/Jitter2.Collision.MinkowskiDifference.html",
    "title": "Class MinkowskiDifference | Jitter2",
    "summary": "Class MinkowskiDifference Namespace Jitter2.Collision Assembly Jitter2.dll Provides methods for computing points on the Minkowski difference of two convex shapes. public static class MinkowskiDifference Inheritance object MinkowskiDifference Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The Minkowski difference A - B is defined as the set of all points (a - b) where a is in A and b is in B. This is the fundamental construct used by GJK and EPA algorithms to detect collisions. Methods GetCenter<TA, TB>(in TA, in TB, in JQuaternion, in JVector, out Vertex) Computes a point guaranteed to be inside the Minkowski difference. public static void GetCenter<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationB, in JVector positionB, out MinkowskiDifference.Vertex center) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA The support function of shape A (at origin, not rotated). supportB TB The support function of shape B. orientationB JQuaternion The orientation of shape B. positionB JVector The position of shape B. center MinkowskiDifference.Vertex The resulting vertex representing the center of the Minkowski difference. Type Parameters TA The type of support shape A. TB The type of support shape B. Support<TA, TB>(in TA, in TB, in JQuaternion, in JVector, in JVector, out Vertex) Computes the support function S_{A-B}(d) = S_A(d) - S_B(-d) for the Minkowski difference. public static void Support<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationB, in JVector positionB, in JVector direction, out MinkowskiDifference.Vertex v) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA The support function of shape A (at origin, not rotated). supportB TB The support function of shape B. orientationB JQuaternion The orientation of shape B. positionB JVector The position of shape B. direction JVector The search direction. v MinkowskiDifference.Vertex The resulting vertex containing support points from both shapes. Type Parameters TA The type of support shape A. TB The type of support shape B."
  },
  "api/Jitter2.Collision.NarrowPhase.html": {
    "href": "api/Jitter2.Collision.NarrowPhase.html",
    "title": "Class NarrowPhase | Jitter2",
    "summary": "Class NarrowPhase Namespace Jitter2.Collision Assembly Jitter2.dll Provides collision detection algorithms for convex shapes defined by support functions. public static class NarrowPhase Inheritance object NarrowPhase Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Implements GJK (Gilbert-Johnson-Keerthi) for distance queries, MPR (Minkowski Portal Refinement) for fast overlap detection, and EPA (Expanding Polytope Algorithm) for penetration depth. All methods are thread-safe when used with thread-local solver state. Methods Collision<TA, TB>(in TA, in TB, in JQuaternion, in JQuaternion, in JVector, in JVector, out JVector, out JVector, out JVector, out float) Determines whether two convex shapes overlap, providing detailed information for both overlapping and separated cases. Internally, the method employs the Expanding Polytope Algorithm (EPA) to gather collision information. public static bool Collision<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationA, in JQuaternion orientationB, in JVector positionA, in JVector positionB, out JVector pointA, out JVector pointB, out JVector normal, out float penetration) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA The support function of shape A. supportB TB The support function of shape B. orientationA JQuaternion The orientation of shape A in world space. orientationB JQuaternion The orientation of shape B in world space. positionA JVector The position of shape A in world space. positionB JVector The position of shape B in world space. pointA JVector For the overlapping case: the deepest point on shape A inside shape B; for the separated case: the closest point on shape A to shape B. pointB JVector For the overlapping case: the deepest point on shape B inside shape A; for the separated case: the closest point on shape B to shape A. normal JVector The normalized collision normal pointing from pointB to pointA. This normal remains defined even if pointA and pointB coincide. It denotes the direction in which the shapes should be moved by the minimum distance (defined by the penetration depth) to either separate them in the overlapping case or bring them into contact in the separated case. penetration float The penetration depth. Returns bool Returns true if the algorithm completes successfully, false otherwise. In case of algorithm convergence failure, collision information reverts to the type's default values. Type Parameters TA TB Collision<TA, TB>(in TA, in TB, in JQuaternion, in JVector, out JVector, out JVector, out JVector, out float) Determines whether two convex shapes overlap, providing detailed information for both overlapping and separated cases. It assumes that support shape A is at position zero and not rotated. Internally, the method employs the Expanding Polytope Algorithm (EPA) to gather collision information. public static bool Collision<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationB, in JVector positionB, out JVector pointA, out JVector pointB, out JVector normal, out float penetration) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA The support function of shape A. supportB TB The support function of shape B. orientationB JQuaternion The orientation of shape B. positionB JVector The position of shape B. pointA JVector For the overlapping case: the deepest point on shape A inside shape B; for the separated case: the closest point on shape A to shape B. pointB JVector For the overlapping case: the deepest point on shape B inside shape A; for the separated case: the closest point on shape B to shape A. normal JVector The normalized collision normal pointing from pointB to pointA. This normal remains defined even if pointA and pointB coincide. It denotes the direction in which the shapes should be moved by the minimum distance (defined by the penetration depth) to either separate them in the overlapping case or bring them into contact in the separated case. penetration float The penetration depth. Returns bool Returns true if the algorithm completes successfully, false otherwise. In case of algorithm convergence failure, collision information reverts to the type's default values. Type Parameters TA TB Distance<TA, TB>(in TA, in TB, in JQuaternion, in JQuaternion, in JVector, in JVector, out JVector, out JVector, out JVector, out float) Provides the distance and closest points for non-overlapping shapes. public static bool Distance<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationA, in JQuaternion orientationB, in JVector positionA, in JVector positionB, out JVector pointA, out JVector pointB, out JVector normal, out float distance) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA The support function of shape A. supportB TB The support function of shape B. orientationA JQuaternion The orientation of shape A in world space. orientationB JQuaternion The orientation of shape B in world space. positionA JVector The position of shape A in world space. positionB JVector The position of shape B in world space. pointA JVector Closest point on shape A. Not well-defined for the overlapping case. pointB JVector Closest point on shape B. Not well-defined for the overlapping case. normal JVector distance float The distance between the separating shapes. Zero if shapes overlap. Returns bool Returns true if the shapes do not overlap and distance information can be provided. Type Parameters TA TB Distance<TA, TB>(in TA, in TB, in JQuaternion, in JVector, out JVector, out JVector, out JVector, out float) Provides the distance and closest points for non-overlapping shapes. It assumes that support shape A is located at position zero and not rotated. public static bool Distance<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationB, in JVector positionB, out JVector pointA, out JVector pointB, out JVector normal, out float distance) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA The support function of shape A. supportB TB The support function of shape B. orientationB JQuaternion The orientation of shape B in world space. positionB JVector The position of shape B in world space. pointA JVector Closest point on shape A. Not well-defined for the overlapping case. pointB JVector Closest point on shape B. Not well-defined for the overlapping case. normal JVector distance float The distance between the separating shapes. Zero if shapes overlap. Returns bool Returns true if the shapes do not overlap and distance information can be provided. Type Parameters TA TB MprEpa<TA, TB>(in TA, in TB, in JQuaternion, in JQuaternion, in JVector, in JVector, out JVector, out JVector, out JVector, out float, float) Detects whether two convex shapes overlap and provides detailed collision information for overlapping shapes. Internally, this method utilizes the Minkowski Portal Refinement (MPR) to obtain the collision information. Although MPR is not exact, it delivers a strict upper bound for the penetration depth. If the upper bound exceeds a predefined threshold, the results are further refined using the Expanding Polytope Algorithm (EPA). public static bool MprEpa<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationA, in JQuaternion orientationB, in JVector positionA, in JVector positionB, out JVector pointA, out JVector pointB, out JVector normal, out float penetration, float epaThreshold = 0.02) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA The support function of shape A. supportB TB The support function of shape B. orientationA JQuaternion The orientation of shape A in world space. orientationB JQuaternion The orientation of shape B in world space. positionA JVector The position of shape A in world space. positionB JVector The position of shape B in world space. pointA JVector The deepest point on shape A that is inside shape B. pointB JVector The deepest point on shape B that is inside shape A. normal JVector The normalized collision normal pointing from pointB to pointA. This normal remains defined even if pointA and pointB coincide, representing the direction in which the shapes must be separated by the minimal distance (determined by the penetration depth) to avoid overlap. penetration float The penetration depth. epaThreshold float The threshold parameter. Returns bool Returns true if the shapes overlap (collide), and false otherwise. Type Parameters TA TB MprEpa<TA, TB>(in TA, in TB, in JQuaternion, in JVector, out JVector, out JVector, out JVector, out float, float) Detects whether two convex shapes overlap and provides detailed collision information for overlapping shapes. It assumes that support shape A is at position zero and not rotated. Internally, this method utilizes the Minkowski Portal Refinement (MPR) to obtain the collision information. Although MPR is not exact, it delivers a strict upper bound for the penetration depth. If the upper bound exceeds a predefined threshold, the results are further refined using the Expanding Polytope Algorithm (EPA). public static bool MprEpa<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationB, in JVector positionB, out JVector pointA, out JVector pointB, out JVector normal, out float penetration, float epaThreshold = 0.02) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA The support function of shape A. supportB TB The support function of shape B. orientationB JQuaternion The orientation of shape B. positionB JVector The position of shape B. pointA JVector The deepest point on shape A that is inside shape B. pointB JVector The deepest point on shape B that is inside shape A. normal JVector The normalized collision normal pointing from pointB to pointA. This normal remains defined even if pointA and pointB coincide, representing the direction in which the shapes must be separated by the minimal distance (determined by the penetration depth) to avoid overlap. penetration float The penetration depth. epaThreshold float The threshold parameter. Returns bool Returns true if the shapes overlap (collide), and false otherwise. Type Parameters TA TB Overlap<TA, TB>(in TA, in TB, in JQuaternion, in JQuaternion, in JVector, in JVector) Performs an overlap test. public static bool Overlap<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationA, in JQuaternion orientationB, in JVector positionA, in JVector positionB) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA The support function of shape A. supportB TB The support function of shape B. orientationA JQuaternion The orientation of shape A in world space. orientationB JQuaternion The orientation of shape B in world space. positionA JVector The position of shape A in world space. positionB JVector The position of shape B in world space. Returns bool Returns true of the shapes overlap, and false otherwise. Type Parameters TA TB Overlap<TA, TB>(in TA, in TB, in JQuaternion, in JVector) Performs an overlap test. It assumes that support shape A is located at position zero and not rotated. public static bool Overlap<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationB, in JVector positionB) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA The support function of shape A. supportB TB The support function of shape B. orientationB JQuaternion The orientation of shape B in world space. positionB JVector The position of shape B in world space. Returns bool Returns true of the shapes overlap, and false otherwise. Type Parameters TA TB PointTest<TA>(in TA, in JMatrix, in JVector, in JVector) Check if a point is inside a shape. public static bool PointTest<TA>(in TA support, in JMatrix orientation, in JVector position, in JVector point) where TA : ISupportMappable Parameters support TA Support map representing the shape. orientation JMatrix Orientation of the shape. position JVector Position of the shape. point JVector Point to check. Returns bool Returns true if the point is contained within the shape, false otherwise. Type Parameters TA PointTest<TA>(in TA, in JVector) Check if a point is inside a shape. public static bool PointTest<TA>(in TA support, in JVector point) where TA : ISupportMappable Parameters support TA Support map representing the shape. point JVector Point to check. Returns bool Returns true if the point is contained within the shape, false otherwise. Type Parameters TA RayCast<TA>(in TA, in JQuaternion, in JVector, in JVector, in JVector, out float, out JVector) Performs a ray cast against a shape. public static bool RayCast<TA>(in TA support, in JQuaternion orientation, in JVector position, in JVector origin, in JVector direction, out float lambda, out JVector normal) where TA : ISupportMappable Parameters support TA The support function of the shape. orientation JQuaternion The orientation of the shape in world space. position JVector The position of the shape in world space. origin JVector The origin of the ray. direction JVector The direction of the ray; normalization is not necessary. lambda float Specifies the hit point of the ray, calculated as 'origin + lambda * direction'. Zero if the origin is inside the shape, PositiveInfinity is the ray does not hit. normal JVector The normalized normal vector perpendicular to the surface, pointing outwards. Zero if the ray does not hit or the ray origin overlaps with the shape. Returns bool Returns true if the ray intersects with the shape; otherwise, false. Type Parameters TA RayCast<TA>(in TA, in JVector, in JVector, out float, out JVector) Performs a ray cast against a shape. public static bool RayCast<TA>(in TA support, in JVector origin, in JVector direction, out float lambda, out JVector normal) where TA : ISupportMappable Parameters support TA The support function of the shape. origin JVector The origin of the ray. direction JVector The direction of the ray; normalization is not necessary. lambda float Specifies the hit point of the ray, calculated as 'origin + lambda * direction'. Zero if the origin is inside the shape, PositiveInfinity is the ray does not hit. normal JVector The normalized normal vector perpendicular to the surface, pointing outwards. Zero if the ray does not hit or the origin overlaps with the shape. Returns bool Returns true if the ray intersects with the shape; otherwise, false. Type Parameters TA Sweep<TA, TB>(in TA, in TB, in JQuaternion, in JQuaternion, in JVector, in JVector, in JVector, in JVector, out JVector, out JVector, out JVector, out float) Calculates the time of impact and the collision points in world space for two shapes with velocities sweepA and sweepB. public static bool Sweep<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationA, in JQuaternion orientationB, in JVector positionA, in JVector positionB, in JVector sweepA, in JVector sweepB, out JVector pointA, out JVector pointB, out JVector normal, out float lambda) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA supportB TB orientationA JQuaternion orientationB JQuaternion positionA JVector positionB JVector sweepA JVector sweepB JVector pointA JVector Collision point on shapeA in world space at t = 0, where collision will occur. pointB JVector Collision point on shapeB in world space at t = 0, where collision will occur. normal JVector Zero if the shapes already overlap or do not hit. lambda float Time of impact. PositiveInfinity if no hit is detected, zero if shapes overlap. Returns bool True if the shapes will hit or already overlap, false otherwise. Type Parameters TA TB Sweep<TA, TB>(in TA, in TB, in JQuaternion, in JQuaternion, in JVector, in JVector, in JVector, in JVector, in JVector, in JVector, in float, in float, out JVector, out JVector, out JVector, out float) Calculates the time of impact (TOI) and the collision points in world space for two shapes with linear velocities sweepA and sweepB and angular velocities sweepAngularA and sweepAngularB. public static bool Sweep<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationA, in JQuaternion orientationB, in JVector positionA, in JVector positionB, in JVector sweepA, in JVector sweepB, in JVector sweepAngularA, in JVector sweepAngularB, in float extentA, in float extentB, out JVector pointA, out JVector pointB, out JVector normal, out float lambda) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA supportB TB orientationA JQuaternion orientationB JQuaternion positionA JVector positionB JVector sweepA JVector sweepB JVector sweepAngularA JVector sweepAngularB JVector extentA float extentB float pointA JVector Collision point on shape A in world space at t = 0, where collision will occur. pointB JVector Collision point on shape B in world space at t = 0, where collision will occur. normal JVector Normalized collision normal in world space at time of impact (points from A to B). Zero if the shapes already overlap or do not hit. lambda float Time of impact. PositiveInfinity if no hit is detected. Zero if shapes overlap. Returns bool True if the shapes hit or already overlap, false otherwise. Type Parameters TA TB Remarks Uses conservative advancement for continuous collision detection. May fail to converge to the correct TOI and collision points in certain edge cases due to limitations in linear motion approximation and distance gradient estimation. Sweep<TA, TB>(in TA, in TB, in JQuaternion, in JVector, in JVector, out JVector, out JVector, out JVector, out float) Perform a sweep test where support shape A is at position zero, not rotated and has no sweep direction. public static bool Sweep<TA, TB>(in TA supportA, in TB supportB, in JQuaternion orientationB, in JVector positionB, in JVector sweepB, out JVector pointA, out JVector pointB, out JVector normal, out float lambda) where TA : ISupportMappable where TB : ISupportMappable Parameters supportA TA supportB TB orientationB JQuaternion positionB JVector sweepB JVector pointA JVector Collision point on shapeA in world space at t = 0, where collision will occur. pointB JVector Collision point on shapeB in world space at t = 0, where collision will occur. normal JVector Zero if the shapes already overlap or do not hit. lambda float Time of impact. PositiveInfinity if no hit is detected, zero if shapes overlap. Returns bool True if the shapes hit or already overlap, false otherwise. Type Parameters TA TB"
  },
  "api/Jitter2.Collision.Shapes.BoxShape.html": {
    "href": "api/Jitter2.Collision.Shapes.BoxShape.html",
    "title": "Class BoxShape | Jitter2",
    "summary": "Class BoxShape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents a three-dimensional box shape. public class BoxShape : RigidBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape RigidBodyShape BoxShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Inherited Members RigidBodyShape.RigidBody RigidBodyShape.Velocity RigidBodyShape.UpdateWorldBoundingBox(float) RigidBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BoxShape(JVector) Creates a box shape with specified dimensions. public BoxShape(JVector size) Parameters size JVector The dimensions of the box. Exceptions ArgumentOutOfRangeException Thrown when any component of size is less than or equal to zero. BoxShape(float) Creates a cube shape with sides of equal length. public BoxShape(float size) Parameters size float The length of each side. Exceptions ArgumentOutOfRangeException Thrown when size is less than or equal to zero. BoxShape(float, float, float) Creates a box shape with the specified length, height, and width. public BoxShape(float width, float height, float length) Parameters width float The width of the box. height float The height of the box. length float The length of the box. Exceptions ArgumentOutOfRangeException Thrown when length, height, or width is less than or equal to zero. Properties Size Gets or sets the dimensions of the box. public JVector Size { get; set; } Property Value JVector Exceptions ArgumentOutOfRangeException Thrown when any component of value is less than or equal to zero. Methods CalculateBoundingBox(in JQuaternion, in JVector, out JBoundingBox) public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters orientation JQuaternion position JVector box JBoundingBox CalculateMassInertia(out JMatrix, out JVector, out float) Calculates the mass and inertia of the shape. Can be overridden by child classes to improve performance or accuracy. The default implementation relies on an approximation of the shape constructed using the support map function. public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) Parameters inertia JMatrix com JVector mass float Remarks The inertia tensor is computed relative to the coordinate system origin (0,0,0), not the center of mass. GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. LocalRayCast(in JVector, in JVector, out JVector, out float) Performs a local ray cast against the shape, checking if a ray originating from a specified point and traveling in a specified direction intersects with the object. It does not take into account the transformation of the associated rigid body. public override bool LocalRayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda) Parameters origin JVector The starting point of the ray. direction JVector The direction of the ray. This vector does not need to be normalized. normal JVector When this method returns, contains the surface normal at the point of intersection, if an intersection occurs. lambda float When this method returns, contains the scalar value representing the distance along the ray's direction vector from the origin to the intersection point. The hit point can be calculated as: origin + lambda * direction. Returns bool true if the ray intersects with the object; otherwise, false. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction."
  },
  "api/Jitter2.Collision.Shapes.CapsuleShape.html": {
    "href": "api/Jitter2.Collision.Shapes.CapsuleShape.html",
    "title": "Class CapsuleShape | Jitter2",
    "summary": "Class CapsuleShape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents a capsule shape defined by a radius and the length of its cylindrical section. public class CapsuleShape : RigidBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape RigidBodyShape CapsuleShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Inherited Members RigidBodyShape.RigidBody RigidBodyShape.Velocity RigidBodyShape.UpdateWorldBoundingBox(float) RigidBodyShape.LocalRayCast(in JVector, in JVector, out JVector, out float) RigidBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CapsuleShape(float, float) Initializes a new instance of the CapsuleShape class with the specified radius and length. The symmetry axis of the capsule is aligned along the Y-axis. public CapsuleShape(float radius = 0.5, float length = 1) Parameters radius float The radius of the capsule. length float The length of the cylindrical part of the capsule, excluding the half-spheres at both ends. Exceptions ArgumentOutOfRangeException Thrown when radius is less than or equal to zero or when length is negative. Properties Length Gets or sets the length of the cylindrical part of the capsule, excluding the half-spheres on both ends. public float Length { get; set; } Property Value float Exceptions ArgumentOutOfRangeException Thrown when value is negative. Radius Gets or sets the radius of the capsule. public float Radius { get; set; } Property Value float Exceptions ArgumentOutOfRangeException Thrown when value is less than or equal to zero. Methods CalculateBoundingBox(in JQuaternion, in JVector, out JBoundingBox) public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters orientation JQuaternion position JVector box JBoundingBox CalculateMassInertia(out JMatrix, out JVector, out float) Calculates the mass and inertia of the shape. Can be overridden by child classes to improve performance or accuracy. The default implementation relies on an approximation of the shape constructed using the support map function. public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) Parameters inertia JMatrix com JVector mass float Remarks The inertia tensor is computed relative to the coordinate system origin (0,0,0), not the center of mass. GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction."
  },
  "api/Jitter2.Collision.Shapes.ConeShape.html": {
    "href": "api/Jitter2.Collision.Shapes.ConeShape.html",
    "title": "Class ConeShape | Jitter2",
    "summary": "Class ConeShape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents a cone shape defined by a base radius and height. public class ConeShape : RigidBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape RigidBodyShape ConeShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Inherited Members RigidBodyShape.RigidBody RigidBodyShape.Velocity RigidBodyShape.UpdateWorldBoundingBox(float) RigidBodyShape.LocalRayCast(in JVector, in JVector, out JVector, out float) RigidBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ConeShape(float, float) Initializes a new instance of the ConeShape class with specified radius and height. The symmetry axis of the cone is aligned along the Y-axis. public ConeShape(float radius = 0.5, float height = 1) Parameters radius float The radius of the cone at its base. height float The height of the cone. Exceptions ArgumentOutOfRangeException Thrown when radius or height is less than or equal to zero. Properties Height Gets or sets the height of the cone. public float Height { get; set; } Property Value float Exceptions ArgumentOutOfRangeException Thrown when value is less than or equal to zero. Radius Gets or sets the radius of the cone at its base. public float Radius { get; set; } Property Value float Exceptions ArgumentOutOfRangeException Thrown when radius is less than or equal to zero. Methods CalculateBoundingBox(in JQuaternion, in JVector, out JBoundingBox) public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters orientation JQuaternion position JVector box JBoundingBox CalculateMassInertia(out JMatrix, out JVector, out float) Calculates the mass and inertia of the shape. Can be overridden by child classes to improve performance or accuracy. The default implementation relies on an approximation of the shape constructed using the support map function. public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) Parameters inertia JMatrix com JVector mass float Remarks The inertia tensor is computed relative to the coordinate system origin (0,0,0), not the center of mass. GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction."
  },
  "api/Jitter2.Collision.Shapes.ConvexHullShape.html": {
    "href": "api/Jitter2.Collision.Shapes.ConvexHullShape.html",
    "title": "Class ConvexHullShape | Jitter2",
    "summary": "Class ConvexHullShape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents a convex hull shape defined by a set of triangles. public class ConvexHullShape : RigidBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable, ICloneableShape<ConvexHullShape> Inheritance object Shape RigidBodyShape ConvexHullShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable ICloneableShape<ConvexHullShape> Inherited Members RigidBodyShape.RigidBody RigidBodyShape.Velocity RigidBodyShape.UpdateWorldBoundingBox(float) RigidBodyShape.LocalRayCast(in JVector, in JVector, out JVector, out float) RigidBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ConvexHullShape(IEnumerable<JTriangle>) Initializes a new instance of the ConvexHullShape class, creating a convex hull. public ConvexHullShape(IEnumerable<JTriangle> triangles) Parameters triangles IEnumerable<JTriangle> All vertices defining the convex hull. The vertices must strictly lie on the surface of the convex hull to avoid incorrect results or indefinite hangs in the collision algorithm. Exceptions ArgumentException Thrown when triangles is empty. InvalidOperationException Thrown when the convex hull consists of more than MaxValue vertices. ConvexHullShape(ReadOnlySpan<JTriangle>) Initializes a new instance of the ConvexHullShape class, creating a convex hull. public ConvexHullShape(ReadOnlySpan<JTriangle> triangles) Parameters triangles ReadOnlySpan<JTriangle> All vertices defining the convex hull. The vertices must strictly lie on the surface of the convex hull to avoid incorrect results or indefinite hangs in the collision algorithm. Exceptions ArgumentException Thrown when triangles is empty. InvalidOperationException Thrown when the convex hull consists of more than MaxValue vertices. Properties Shift Gets or sets the shift applied to the convex hull vertices. public JVector Shift { get; set; } Property Value JVector Methods CalculateBoundingBox(in JQuaternion, in JVector, out JBoundingBox) public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters orientation JQuaternion position JVector box JBoundingBox CalculateMassInertia() Recalculates the mass, center of mass, and inertia tensor from the convex hull triangles. public void CalculateMassInertia() CalculateMassInertia(out JMatrix, out JVector, out float) Calculates the mass and inertia of the shape. Can be overridden by child classes to improve performance or accuracy. The default implementation relies on an approximation of the shape constructed using the support map function. public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) Parameters inertia JMatrix com JVector mass float Remarks The inertia tensor is computed relative to the coordinate system origin (0,0,0), not the center of mass. Clone() Creates a clone of the convex hull shape. Note that the underlying data structure is shared among instances. public ConvexHullShape Clone() Returns ConvexHullShape A new instance of the ConvexHullShape class that shares the same underlying data structure as the original instance. GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction. UpdateShape() Updates the shape's cached mass, inertia, and bounding box. public void UpdateShape()"
  },
  "api/Jitter2.Collision.Shapes.CylinderShape.html": {
    "href": "api/Jitter2.Collision.Shapes.CylinderShape.html",
    "title": "Class CylinderShape | Jitter2",
    "summary": "Class CylinderShape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents a cylinder shape defined by a height and radius. public class CylinderShape : RigidBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape RigidBodyShape CylinderShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Inherited Members RigidBodyShape.RigidBody RigidBodyShape.Velocity RigidBodyShape.UpdateWorldBoundingBox(float) RigidBodyShape.LocalRayCast(in JVector, in JVector, out JVector, out float) RigidBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CylinderShape(float, float) Initializes a new instance of the CylinderShape class, creating a cylinder shape with the specified height and radius. The symmetry axis of the cylinder is aligned along the y-axis. public CylinderShape(float height, float radius) Parameters height float The height of the cylinder. radius float The radius of the cylinder at its base. Exceptions ArgumentOutOfRangeException Thrown when height or radius is less than or equal to zero. Properties Height Gets or sets the height of the cylinder. public float Height { get; set; } Property Value float Exceptions ArgumentOutOfRangeException Thrown when value is less than or equal to zero. Radius Gets or sets the radius of the cylinder. public float Radius { get; set; } Property Value float Exceptions ArgumentOutOfRangeException Thrown when value is less than or equal to zero. Methods CalculateBoundingBox(in JQuaternion, in JVector, out JBoundingBox) public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters orientation JQuaternion position JVector box JBoundingBox CalculateMassInertia(out JMatrix, out JVector, out float) Calculates the mass and inertia of the shape. Can be overridden by child classes to improve performance or accuracy. The default implementation relies on an approximation of the shape constructed using the support map function. public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) Parameters inertia JMatrix com JVector mass float Remarks The inertia tensor is computed relative to the coordinate system origin (0,0,0), not the center of mass. GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction."
  },
  "api/Jitter2.Collision.Shapes.ICloneableShape-1.html": {
    "href": "api/Jitter2.Collision.Shapes.ICloneableShape-1.html",
    "title": "Interface ICloneableShape<T> | Jitter2",
    "summary": "Interface ICloneableShape<T> Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Defines a method to create a new instance of a shape for use with another rigid body. public interface ICloneableShape<out T> where T : Shape Type Parameters T The concrete shape type implementing this interface. Methods Clone() Creates a copy of the current shape instance that shares underlying geometry data. T Clone() Returns T A new shape instance of type T that shares immutable data with the original but has its own instance state."
  },
  "api/Jitter2.Collision.Shapes.PointCloudShape.html": {
    "href": "api/Jitter2.Collision.Shapes.PointCloudShape.html",
    "title": "Class PointCloudShape | Jitter2",
    "summary": "Class PointCloudShape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents a convex hull shape defined by a point cloud. Unlike ConvexHullShape, it is not necessary for the points to lie on the convex hull. For performance optimization, this shape should ideally be used for a small number of points (~300). public class PointCloudShape : RigidBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable, ICloneableShape<PointCloudShape> Inheritance object Shape RigidBodyShape PointCloudShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable ICloneableShape<PointCloudShape> Inherited Members RigidBodyShape.RigidBody RigidBodyShape.Velocity RigidBodyShape.UpdateWorldBoundingBox(float) RigidBodyShape.LocalRayCast(in JVector, in JVector, out JVector, out float) RigidBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PointCloudShape(VertexSupportMap) Initializes a new instance of the PointCloudShape class. public PointCloudShape(VertexSupportMap supportMap) Parameters supportMap VertexSupportMap PointCloudShape(IEnumerable<JVector>) Initializes a new instance of the PointCloudShape class. public PointCloudShape(IEnumerable<JVector> vertices) Parameters vertices IEnumerable<JVector> All vertices that define the convex hull. Exceptions ArgumentException Thrown when vertices is empty. PointCloudShape(ReadOnlySpan<JVector>) Initializes a new instance of the PointCloudShape class. public PointCloudShape(ReadOnlySpan<JVector> vertices) Parameters vertices ReadOnlySpan<JVector> All vertices that define the convex hull. Exceptions ArgumentException Thrown when vertices is empty. Properties Shift Gets or sets the shift value for the shape. This property can be used when constructing a rigid body that contains one or more shapes. public JVector Shift { get; set; } Property Value JVector Methods CalculateBoundingBox(in JQuaternion, in JVector, out JBoundingBox) public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters orientation JQuaternion position JVector box JBoundingBox CalculateMassInertia() Recalculates the mass, center of mass, and inertia tensor. public void CalculateMassInertia() CalculateMassInertia(out JMatrix, out JVector, out float) Calculates the mass and inertia of the shape. Can be overridden by child classes to improve performance or accuracy. The default implementation relies on an approximation of the shape constructed using the support map function. public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) Parameters inertia JMatrix com JVector mass float Remarks The inertia tensor is computed relative to the coordinate system origin (0,0,0), not the center of mass. Clone() Creates a copy of this shape. The underlying data structure is shared among the instances. public PointCloudShape Clone() Returns PointCloudShape GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction. UpdateShape() Updates the shape's cached mass, inertia, and bounding box. public void UpdateShape()"
  },
  "api/Jitter2.Collision.Shapes.RigidBodyShape.html": {
    "href": "api/Jitter2.Collision.Shapes.RigidBodyShape.html",
    "title": "Class RigidBodyShape | Jitter2",
    "summary": "Class RigidBodyShape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents the abstract base class for shapes that can be attached to a rigid body. public abstract class RigidBodyShape : Shape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape RigidBodyShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Derived BoxShape CapsuleShape ConeShape ConvexHullShape CylinderShape PointCloudShape SphereShape TransformedShape TriangleShape Inherited Members Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) Shape.SupportMap(in JVector, out JVector) Shape.GetCenter(out JVector) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties RigidBody The instance of RigidBody to which this shape is attached. public RigidBody RigidBody { get; } Property Value RigidBody Velocity Gets the velocity of the entity, used for bounding box expansion. public override sealed JVector Velocity { get; } Property Value JVector Methods CalculateBoundingBox(in JQuaternion, in JVector, out JBoundingBox) public virtual void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters orientation JQuaternion position JVector box JBoundingBox CalculateMassInertia(out JMatrix, out JVector, out float) Calculates the mass and inertia of the shape. Can be overridden by child classes to improve performance or accuracy. The default implementation relies on an approximation of the shape constructed using the support map function. [ReferenceFrame(ReferenceFrame.Local)] public virtual void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) Parameters inertia JMatrix com JVector mass float Remarks The inertia tensor is computed relative to the coordinate system origin (0,0,0), not the center of mass. LocalRayCast(in JVector, in JVector, out JVector, out float) Performs a local ray cast against the shape, checking if a ray originating from a specified point and traveling in a specified direction intersects with the object. It does not take into account the transformation of the associated rigid body. [ReferenceFrame(ReferenceFrame.Local)] public virtual bool LocalRayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda) Parameters origin JVector The starting point of the ray. direction JVector The direction of the ray. This vector does not need to be normalized. normal JVector When this method returns, contains the surface normal at the point of intersection, if an intersection occurs. lambda float When this method returns, contains the scalar value representing the distance along the ray's direction vector from the origin to the intersection point. The hit point can be calculated as: origin + lambda * direction. Returns bool true if the ray intersects with the object; otherwise, false. RayCast(in JVector, in JVector, out JVector, out float) Performs a ray cast against this object. [ReferenceFrame(ReferenceFrame.World)] public override sealed bool RayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda) Parameters origin JVector The starting point of the ray. direction JVector The direction of the ray. Does not need to be normalized. normal JVector The surface normal at the intersection point. lambda float The distance along the ray to the intersection: hitPoint = origin + lambda * direction. Returns bool true if the ray intersects with the object; otherwise, false. UpdateWorldBoundingBox(float) Recomputes the world-space bounding box. public override sealed void UpdateWorldBoundingBox(float dt = 0) Parameters dt float The timestep for velocity-based expansion. Default is zero."
  },
  "api/Jitter2.Collision.Shapes.Shape.html": {
    "href": "api/Jitter2.Collision.Shapes.Shape.html",
    "title": "Class Shape | Jitter2",
    "summary": "Class Shape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll The main entity of the collision system. Implements ISupportMappable for narrow-phase and IDynamicTreeProxy for broad-phase collision detection. The shape itself does not have a position or orientation. Shapes can be associated with instances of RigidBody. public abstract class Shape : IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Derived RigidBodyShape SoftBodyShape Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields ShapeId A 64-bit integer representing the shape ID. This is used by algorithms that require arranging shapes in a well-defined order. public readonly ulong ShapeId Field Value ulong Properties Velocity Gets the velocity of the entity, used for bounding box expansion. [ReferenceFrame(ReferenceFrame.World)] public abstract JVector Velocity { get; } Property Value JVector WorldBoundingBox The bounding box of the shape in world space. It is automatically updated when the position or orientation of the corresponding instance of RigidBody changes. public JBoundingBox WorldBoundingBox { get; protected set; } Property Value JBoundingBox Methods GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. [ReferenceFrame(ReferenceFrame.Local)] public abstract void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. RayCast(in JVector, in JVector, out JVector, out float) Performs a ray cast against this object. [ReferenceFrame(ReferenceFrame.World)] public abstract bool RayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda) Parameters origin JVector The starting point of the ray. direction JVector The direction of the ray. Does not need to be normalized. normal JVector The surface normal at the intersection point. lambda float The distance along the ray to the intersection: hitPoint = origin + lambda * direction. Returns bool true if the ray intersects with the object; otherwise, false. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. [ReferenceFrame(ReferenceFrame.Local)] public abstract void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction. SweptExpandBoundingBox(float) protected void SweptExpandBoundingBox(float dt) Parameters dt float UpdateWorldBoundingBox(float) Recomputes the world-space bounding box. [ReferenceFrame(ReferenceFrame.World)] public abstract void UpdateWorldBoundingBox(float dt = 0) Parameters dt float The timestep for velocity-based expansion. Default is zero."
  },
  "api/Jitter2.Collision.Shapes.ShapeHelper.html": {
    "href": "api/Jitter2.Collision.Shapes.ShapeHelper.html",
    "title": "Class ShapeHelper | Jitter2",
    "summary": "Class ShapeHelper Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Provides helper methods for calculating the properties of implicitly defined shapes. public static class ShapeHelper Inheritance object ShapeHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CalculateBoundingBox(ISupportMappable, in JQuaternion, in JVector, out JBoundingBox) Calculates the axis-aligned bounding box of a shape given its orientation and position. public static void CalculateBoundingBox(ISupportMappable support, in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters support ISupportMappable The support map interface implemented by the shape. orientation JQuaternion The orientation of the shape. position JVector The position of the shape. box JBoundingBox The resulting bounding box. CalculateMassInertia(ISupportMappable, out JMatrix, out JVector, out float, int) Calculates the mass properties of an implicitly defined shape, assuming unit mass density. public static void CalculateMassInertia(ISupportMappable support, out JMatrix inertia, out JVector centerOfMass, out float mass, int subdivisions = 4) Parameters support ISupportMappable The support map interface implemented by the shape. inertia JMatrix Output parameter for the inertia tensor calculated relative to the Origin (0,0,0). centerOfMass JVector Output parameter for the calculated center of mass vector (relative to the Origin). mass float Output parameter for the calculated mass (Volume * density 1.0). subdivisions int The recursion depth for the surface tessellation (default 4). Remarks The shape is approximated via surface tessellation using the specified number of subdivisions. Note on Reference Frame: The calculated inertia tensor is expressed relative to the coordinate system origin (0,0,0), not the calculated centerOfMass. MakeHull(ISupportMappable, int) [Obsolete(\"Use Tessellate instead.\")] public static List<JTriangle> MakeHull(ISupportMappable support, int subdivisions = 3) Parameters support ISupportMappable subdivisions int Returns List<JTriangle> MakeHull(IEnumerable<JVector>, int) [Obsolete(\"Use Tessellate instead.\")] public static List<JTriangle> MakeHull(IEnumerable<JVector> vertices, int subdivisions = 3) Parameters vertices IEnumerable<JVector> subdivisions int Returns List<JTriangle> MakeHull(ReadOnlySpan<JVector>, int) [Obsolete(\"Use Tessellate instead.\")] public static List<JTriangle> MakeHull(ReadOnlySpan<JVector> vertices, int subdivisions = 3) Parameters vertices ReadOnlySpan<JVector> subdivisions int Returns List<JTriangle> MakeHull<T>(ISupportMappable, T, int) [Obsolete(\"Use Tessellate instead.\")] public static void MakeHull<T>(ISupportMappable support, T hullCollection, int subdivisions = 3) where T : ICollection<JTriangle> Parameters support ISupportMappable hullCollection T subdivisions int Type Parameters T SampleHull(ISupportMappable, int) Samples a convex shape's hull by evaluating support directions generated through recursive subdivision of an icosahedron. public static List<JVector> SampleHull(ISupportMappable support, int subdivisions = 3) Parameters support ISupportMappable An object implementing ISupportMappable, representing a convex shape that can be queried with directional support mapping. subdivisions int The number of recursive subdivisions applied to each icosahedron triangle. Higher values produce more sampling directions and better coverage, but increase computation. Default is 3. Returns List<JVector> A list of JVector points on the convex hull, sampled using directional support mapping from a refined spherical distribution. Remarks This method begins with a regular icosahedron and recursively subdivides each triangular face into smaller triangles, projecting new vertices onto the unit sphere. Each final vertex direction is passed to the support mapper to generate a hull point. SampleHull(IEnumerable<JVector>, int) Approximates the convex hull of a given set of 3D vertices by sampling support points generated through recursive subdivision of an icosahedron. public static List<JVector> SampleHull(IEnumerable<JVector> vertices, int subdivisions = 3) Parameters vertices IEnumerable<JVector> The list of vertices that define the object. subdivisions int The number of recursive subdivisions applied to each icosahedron triangle. Higher values produce more sampling directions and better coverage, but increase computation. Default is 3. Returns List<JVector> A list of JVector points on the convex hull, sampled using directional support mapping from a refined spherical distribution. Remarks This method begins with a regular icosahedron and recursively subdivides each triangular face into smaller triangles, projecting new vertices onto the unit sphere. Each final vertex direction is passed to the support mapper to generate a hull point. SampleHull(ReadOnlySpan<JVector>, int) Approximates the convex hull of a given set of 3D vertices by sampling support points generated through recursive subdivision of an icosahedron. public static List<JVector> SampleHull(ReadOnlySpan<JVector> vertices, int subdivisions = 3) Parameters vertices ReadOnlySpan<JVector> The list of vertices that define the object. subdivisions int The number of recursive subdivisions applied to each icosahedron triangle. Higher values produce more sampling directions and better coverage, but increase computation. Default is 3. Returns List<JVector> A list of JVector points on the convex hull, sampled using directional support mapping from a refined spherical distribution. Remarks This method begins with a regular icosahedron and recursively subdivides each triangular face into smaller triangles, projecting new vertices onto the unit sphere. Each final vertex direction is passed to the support mapper to generate a hull point. Tessellate(ISupportMappable, int) Creates a tessellation of a shape defined by its support map. public static List<JTriangle> Tessellate(ISupportMappable support, int subdivisions = 3) Parameters support ISupportMappable The support map interface implemented by the shape. subdivisions int The number of subdivisions used for hull generation. Returns List<JTriangle> Remarks The tessellated hull may not be perfectly convex. It is therefore not suited to be used with ConvexHullShape. Tessellate(IEnumerable<JVector>, int) Creates a tessellation of the convex hull of a given set of 3D vertices. public static List<JTriangle> Tessellate(IEnumerable<JVector> vertices, int subdivisions = 3) Parameters vertices IEnumerable<JVector> The vertices used to approximate the hull. subdivisions int The number of subdivisions used for hull generation. Returns List<JTriangle> A list of triangles representing the convex hull. Remarks The tessellated hull may not be perfectly convex. It is therefore not suited to be used with ConvexHullShape. Tessellate(ReadOnlySpan<JVector>, int) Creates a tessellation of the convex hull of a given set of 3D vertices. public static List<JTriangle> Tessellate(ReadOnlySpan<JVector> vertices, int subdivisions = 3) Parameters vertices ReadOnlySpan<JVector> The vertices used to approximate the hull. subdivisions int The number of subdivisions used for hull generation. Returns List<JTriangle> A list of triangles representing the convex hull. Remarks The tessellated hull may not be perfectly convex. It is therefore not suited to be used with ConvexHullShape. Tessellate<T>(ISupportMappable, T, int) Creates a tessellation of a shape defined by its support map. public static void Tessellate<T>(ISupportMappable support, T hullCollection, int subdivisions = 3) where T : ICollection<JTriangle> Parameters support ISupportMappable The support map interface implemented by the shape. hullCollection T A collection to which the triangles are added to. subdivisions int The number of subdivisions used for hull generation. Type Parameters T Remarks The tessellated hull may not be perfectly convex. It is therefore not suited to be used with ConvexHullShape."
  },
  "api/Jitter2.Collision.Shapes.SphereShape.html": {
    "href": "api/Jitter2.Collision.Shapes.SphereShape.html",
    "title": "Class SphereShape | Jitter2",
    "summary": "Class SphereShape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents a sphere. public class SphereShape : RigidBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape RigidBodyShape SphereShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Inherited Members RigidBodyShape.RigidBody RigidBodyShape.Velocity RigidBodyShape.UpdateWorldBoundingBox(float) RigidBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SphereShape(float) Initializes a new instance of the SphereShape class with an optional radius parameter. The default radius is 1.0 units. public SphereShape(float radius = 1) Parameters radius float The radius of the sphere. Defaults to (Real)1.0. Exceptions ArgumentOutOfRangeException Thrown when radius is less than or equal to zero. Properties Radius Gets or sets the radius of the sphere. public float Radius { get; set; } Property Value float Exceptions ArgumentOutOfRangeException Thrown when value is less than or equal to zero. Methods CalculateBoundingBox(in JQuaternion, in JVector, out JBoundingBox) public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters orientation JQuaternion position JVector box JBoundingBox CalculateMassInertia(out JMatrix, out JVector, out float) Calculates the mass and inertia of the shape. Can be overridden by child classes to improve performance or accuracy. The default implementation relies on an approximation of the shape constructed using the support map function. public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) Parameters inertia JMatrix com JVector mass float Remarks The inertia tensor is computed relative to the coordinate system origin (0,0,0), not the center of mass. GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. LocalRayCast(in JVector, in JVector, out JVector, out float) Performs a local ray cast against the shape, checking if a ray originating from a specified point and traveling in a specified direction intersects with the object. It does not take into account the transformation of the associated rigid body. public override bool LocalRayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda) Parameters origin JVector The starting point of the ray. direction JVector The direction of the ray. This vector does not need to be normalized. normal JVector When this method returns, contains the surface normal at the point of intersection, if an intersection occurs. lambda float When this method returns, contains the scalar value representing the distance along the ray's direction vector from the origin to the intersection point. The hit point can be calculated as: origin + lambda * direction. Returns bool true if the ray intersects with the object; otherwise, false. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction."
  },
  "api/Jitter2.Collision.Shapes.TransformedShape.html": {
    "href": "api/Jitter2.Collision.Shapes.TransformedShape.html",
    "title": "Class TransformedShape | Jitter2",
    "summary": "Class TransformedShape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents a shape wrapper defined by an original shape and an affine transformation (translation and linear map). public class TransformedShape : RigidBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape RigidBodyShape TransformedShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Inherited Members RigidBodyShape.RigidBody RigidBodyShape.Velocity RigidBodyShape.UpdateWorldBoundingBox(float) RigidBodyShape.LocalRayCast(in JVector, in JVector, out JVector, out float) RigidBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TransformedShape(RigidBodyShape, JMatrix) Constructs a transformed shape with a linear transformation (rotation, scale, or shear), assuming zero translation. public TransformedShape(RigidBodyShape shape, JMatrix transform) Parameters shape RigidBodyShape transform JMatrix TransformedShape(RigidBodyShape, JVector) Constructs a transformed shape with a translation (offset), assuming identity rotation/scale. public TransformedShape(RigidBodyShape shape, JVector translation) Parameters shape RigidBodyShape translation JVector TransformedShape(RigidBodyShape, in JVector, in JMatrix) Constructs a transformed shape through an affine transformation defined by a linear map and a translation. public TransformedShape(RigidBodyShape shape, in JVector translation, in JMatrix transform) Parameters shape RigidBodyShape translation JVector transform JMatrix Properties OriginalShape Gets the original shape that is being transformed. public RigidBodyShape OriginalShape { get; } Property Value RigidBodyShape Transformation Gets or sets the linear transformation (rotation, scale, or shear) applied to the shape. public JMatrix Transformation { get; set; } Property Value JMatrix Translation Gets or sets the translation applied to the shape. public JVector Translation { get; set; } Property Value JVector Methods CalculateBoundingBox(in JQuaternion, in JVector, out JBoundingBox) public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters orientation JQuaternion position JVector box JBoundingBox CalculateMassInertia(out JMatrix, out JVector, out float) Calculates the mass and inertia of the shape. Can be overridden by child classes to improve performance or accuracy. The default implementation relies on an approximation of the shape constructed using the support map function. public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) Parameters inertia JMatrix com JVector mass float Remarks The inertia tensor is computed relative to the coordinate system origin (0,0,0), not the center of mass. GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction."
  },
  "api/Jitter2.Collision.Shapes.TriangleMesh.DegenerateTriangleException.html": {
    "href": "api/Jitter2.Collision.Shapes.TriangleMesh.DegenerateTriangleException.html",
    "title": "Class TriangleMesh.DegenerateTriangleException | Jitter2",
    "summary": "Class TriangleMesh.DegenerateTriangleException Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll public sealed class TriangleMesh.DegenerateTriangleException : Exception, ISerializable Inheritance object Exception TriangleMesh.DegenerateTriangleException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite object.Equals(object) object.Equals(object, object) object.GetHashCode() object.ReferenceEquals(object, object) Constructors DegenerateTriangleException(JTriangle) public DegenerateTriangleException(JTriangle triangle) Parameters triangle JTriangle"
  },
  "api/Jitter2.Collision.Shapes.TriangleMesh.Triangle.html": {
    "href": "api/Jitter2.Collision.Shapes.TriangleMesh.Triangle.html",
    "title": "Struct TriangleMesh.Triangle | Jitter2",
    "summary": "Struct TriangleMesh.Triangle Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll public struct TriangleMesh.Triangle Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Triangle(int, int, int) public Triangle(int a, int b, int c) Parameters a int b int c int Fields IndexA public readonly int IndexA Field Value int IndexB public readonly int IndexB Field Value int IndexC public readonly int IndexC Field Value int NeighborA public int NeighborA Field Value int NeighborB public int NeighborB Field Value int NeighborC public int NeighborC Field Value int Normal public JVector Normal Field Value JVector"
  },
  "api/Jitter2.Collision.Shapes.TriangleMesh.html": {
    "href": "api/Jitter2.Collision.Shapes.TriangleMesh.html",
    "title": "Class TriangleMesh | Jitter2",
    "summary": "Class TriangleMesh Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents a triangle mesh defined by a collection of vertices and triangle indices. public class TriangleMesh Inheritance object TriangleMesh Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TriangleMesh(IEnumerable<JTriangle>, bool) Creates a mesh from a \"soup\" of triangles. Vertices are automatically identified and deduplicated. public TriangleMesh(IEnumerable<JTriangle> soup, bool ignoreDegenerated = false) Parameters soup IEnumerable<JTriangle> ignoreDegenerated bool TriangleMesh(ReadOnlySpan<JTriangle>, bool) Creates a mesh from a \"soup\" of triangles. Vertices are automatically identified and deduplicated. public TriangleMesh(ReadOnlySpan<JTriangle> soup, bool ignoreDegenerated = false) Parameters soup ReadOnlySpan<JTriangle> ignoreDegenerated bool TriangleMesh(ReadOnlySpan<JVector>, ReadOnlySpan<int>, bool) Creates a mesh from existing vertices and indices. public TriangleMesh(ReadOnlySpan<JVector> vertices, ReadOnlySpan<int> indices, bool ignoreDegenerated = false) Parameters vertices ReadOnlySpan<JVector> The vertex buffer. indices ReadOnlySpan<int> The index buffer (must be a multiple of 3). ignoreDegenerated bool TriangleMesh(ReadOnlySpan<JVector>, ReadOnlySpan<ushort>, bool) Creates a mesh from existing vertices and indices. public TriangleMesh(ReadOnlySpan<JVector> vertices, ReadOnlySpan<ushort> indices, bool ignoreDegenerated = false) Parameters vertices ReadOnlySpan<JVector> The vertex buffer. indices ReadOnlySpan<ushort> The index buffer (must be a multiple of 3). ignoreDegenerated bool TriangleMesh(ReadOnlySpan<JVector>, ReadOnlySpan<uint>, bool) Creates a mesh from existing vertices and indices. public TriangleMesh(ReadOnlySpan<JVector> vertices, ReadOnlySpan<uint> indices, bool ignoreDegenerated = false) Parameters vertices ReadOnlySpan<JVector> The vertex buffer. indices ReadOnlySpan<uint> The index buffer (must be a multiple of 3). ignoreDegenerated bool Properties Indices Gets the triangle indices of the mesh. public ReadOnlySpan<TriangleMesh.Triangle> Indices { get; } Property Value ReadOnlySpan<TriangleMesh.Triangle> Vertices Gets the vertices of the mesh. public ReadOnlySpan<JVector> Vertices { get; } Property Value ReadOnlySpan<JVector> Methods Create<TVertex>(ReadOnlySpan<TVertex>, ReadOnlySpan<int>, bool) Creates a mesh from custom vertices (e.g. System.Numerics.Vector3) and indices. public static TriangleMesh Create<TVertex>(ReadOnlySpan<TVertex> vertices, ReadOnlySpan<int> indices, bool ignoreDegenerated = false) where TVertex : unmanaged Parameters vertices ReadOnlySpan<TVertex> indices ReadOnlySpan<int> ignoreDegenerated bool Returns TriangleMesh Type Parameters TVertex Create<TVertex>(ReadOnlySpan<TVertex>, ReadOnlySpan<ushort>, bool) Creates a mesh from custom vertices (e.g. System.Numerics.Vector3) and indices. public static TriangleMesh Create<TVertex>(ReadOnlySpan<TVertex> vertices, ReadOnlySpan<ushort> indices, bool ignoreDegenerated = false) where TVertex : unmanaged Parameters vertices ReadOnlySpan<TVertex> indices ReadOnlySpan<ushort> ignoreDegenerated bool Returns TriangleMesh Type Parameters TVertex Create<TVertex>(ReadOnlySpan<TVertex>, ReadOnlySpan<uint>, bool) Creates a mesh from custom vertices (e.g. System.Numerics.Vector3) and indices. public static TriangleMesh Create<TVertex>(ReadOnlySpan<TVertex> vertices, ReadOnlySpan<uint> indices, bool ignoreDegenerated = false) where TVertex : unmanaged Parameters vertices ReadOnlySpan<TVertex> indices ReadOnlySpan<uint> ignoreDegenerated bool Returns TriangleMesh Type Parameters TVertex"
  },
  "api/Jitter2.Collision.Shapes.TriangleShape.html": {
    "href": "api/Jitter2.Collision.Shapes.TriangleShape.html",
    "title": "Class TriangleShape | Jitter2",
    "summary": "Class TriangleShape Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Represents a triangle shape defined by a reference to a TriangleMesh and an index. public class TriangleShape : RigidBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape RigidBodyShape TriangleShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Inherited Members RigidBodyShape.RigidBody RigidBodyShape.Velocity RigidBodyShape.UpdateWorldBoundingBox(float) RigidBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TriangleShape(TriangleMesh, int) Initializes a new instance of the TriangleShape class. public TriangleShape(TriangleMesh mesh, int index) Parameters mesh TriangleMesh The triangle mesh to which this triangle belongs. index int The index representing the position of the triangle within the mesh. Exceptions ArgumentNullException Thrown when mesh is null. ArgumentOutOfRangeException Thrown when index is negative or greater than or equal to the number of triangles in the mesh. Fields Index The index representing the position of the triangle within the mesh. public readonly int Index Field Value int Mesh The triangle mesh to which this triangle belongs. public readonly TriangleMesh Mesh Field Value TriangleMesh Methods CalculateBoundingBox(in JQuaternion, in JVector, out JBoundingBox) public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBoundingBox box) Parameters orientation JQuaternion position JVector box JBoundingBox CalculateMassInertia(out JMatrix, out JVector, out float) public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) Parameters inertia JMatrix com JVector mass float Exceptions NotSupportedException Always thrown because a triangle has no volume and therefore no mass properties. CreateAllShapes(TriangleMesh) Creates and returns all instances of type TriangleShape for as given TriangleMesh. public static IEnumerable<TriangleShape> CreateAllShapes(TriangleMesh mesh) Parameters mesh TriangleMesh Returns IEnumerable<TriangleShape> GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. GetWorldVertices(out JVector, out JVector, out JVector) Retrieves the vertices transformed to world space coordinates, as affected by the rigid body's transformation. public void GetWorldVertices(out JVector a, out JVector b, out JVector c) Parameters a JVector The transformed coordinate of the first vertex. b JVector The transformed coordinate of the second vertex. c JVector The transformed coordinate of the third vertex. LocalRayCast(in JVector, in JVector, out JVector, out float) Performs a local ray cast against the shape, checking if a ray originating from a specified point and traveling in a specified direction intersects with the object. It does not take into account the transformation of the associated rigid body. public override bool LocalRayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda) Parameters origin JVector The starting point of the ray. direction JVector The direction of the ray. This vector does not need to be normalized. normal JVector When this method returns, contains the surface normal at the point of intersection, if an intersection occurs. lambda float When this method returns, contains the scalar value representing the distance along the ray's direction vector from the origin to the intersection point. The hit point can be calculated as: origin + lambda * direction. Returns bool true if the ray intersects with the object; otherwise, false. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction."
  },
  "api/Jitter2.Collision.Shapes.VertexSupportMap.html": {
    "href": "api/Jitter2.Collision.Shapes.VertexSupportMap.html",
    "title": "Struct VertexSupportMap | Jitter2",
    "summary": "Struct VertexSupportMap Namespace Jitter2.Collision.Shapes Assembly Jitter2.dll Implements a SIMD accelerated support map for a set of vertices. public struct VertexSupportMap : ISupportMappable, IEquatable<VertexSupportMap> Implements ISupportMappable IEquatable<VertexSupportMap> Inherited Members ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors VertexSupportMap(IEnumerable<JVector>) public VertexSupportMap(IEnumerable<JVector> vertices) Parameters vertices IEnumerable<JVector> VertexSupportMap(ReadOnlySpan<JVector>) public VertexSupportMap(ReadOnlySpan<JVector> vertices) Parameters vertices ReadOnlySpan<JVector> Methods Equals(VertexSupportMap) Indicates whether the current object is equal to another object of the same type. public readonly bool Equals(VertexSupportMap other) Parameters other VertexSupportMap An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override readonly bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public readonly void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. GetHashCode() Returns the hash code for this instance. public override readonly int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public readonly void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction. Operators operator ==(VertexSupportMap, VertexSupportMap) public static bool operator ==(VertexSupportMap left, VertexSupportMap right) Parameters left VertexSupportMap right VertexSupportMap Returns bool operator !=(VertexSupportMap, VertexSupportMap) public static bool operator !=(VertexSupportMap left, VertexSupportMap right) Parameters left VertexSupportMap right VertexSupportMap Returns bool"
  },
  "api/Jitter2.Collision.Shapes.html": {
    "href": "api/Jitter2.Collision.Shapes.html",
    "title": "Namespace Jitter2.Collision.Shapes | Jitter2",
    "summary": "Namespace Jitter2.Collision.Shapes Classes BoxShape Represents a three-dimensional box shape. CapsuleShape Represents a capsule shape defined by a radius and the length of its cylindrical section. ConeShape Represents a cone shape defined by a base radius and height. ConvexHullShape Represents a convex hull shape defined by a set of triangles. CylinderShape Represents a cylinder shape defined by a height and radius. PointCloudShape Represents a convex hull shape defined by a point cloud. Unlike ConvexHullShape, it is not necessary for the points to lie on the convex hull. For performance optimization, this shape should ideally be used for a small number of points (~300). RigidBodyShape Represents the abstract base class for shapes that can be attached to a rigid body. Shape The main entity of the collision system. Implements ISupportMappable for narrow-phase and IDynamicTreeProxy for broad-phase collision detection. The shape itself does not have a position or orientation. Shapes can be associated with instances of RigidBody. ShapeHelper Provides helper methods for calculating the properties of implicitly defined shapes. SphereShape Represents a sphere. TransformedShape Represents a shape wrapper defined by an original shape and an affine transformation (translation and linear map). TriangleMesh Represents a triangle mesh defined by a collection of vertices and triangle indices. TriangleMesh.DegenerateTriangleException TriangleShape Represents a triangle shape defined by a reference to a TriangleMesh and an index. Structs TriangleMesh.Triangle VertexSupportMap Implements a SIMD accelerated support map for a set of vertices. Interfaces ICloneableShape<T> Defines a method to create a new instance of a shape for use with another rigid body."
  },
  "api/Jitter2.Collision.SimplexSolver.html": {
    "href": "api/Jitter2.Collision.SimplexSolver.html",
    "title": "Struct SimplexSolver | Jitter2",
    "summary": "Struct SimplexSolver Namespace Jitter2.Collision Assembly Jitter2.dll Implements the Gilbert-Johnson-Keerthi (GJK) simplex solver for finding the closest point to the origin on a simplex (point, line segment, triangle, or tetrahedron). public struct SimplexSolver Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This solver iteratively reduces the simplex to the feature closest to the origin. It handles degeneracy by falling back to lower-dimensional features when the current simplex is near-degenerate. Complexity: O(1) per vertex addition for point/segment, O(1) for triangle, O(1) for tetrahedron with early-out optimizations. Methods AddVertex(in JVector, out JVector) Adds a vertex to the simplex and computes the new closest point to the origin. public bool AddVertex(in JVector vertex, out JVector closest) Parameters vertex JVector The vertex to add (a point on the Minkowski difference). closest JVector When this method returns, contains the point on the reduced simplex closest to the origin. Returns bool true if the origin is not contained within the simplex (continue iterating); false if the origin is enclosed by the tetrahedron (collision detected). Reset() Resets the solver to an empty simplex. public void Reset()"
  },
  "api/Jitter2.Collision.SimplexSolverAB.html": {
    "href": "api/Jitter2.Collision.SimplexSolverAB.html",
    "title": "Struct SimplexSolverAB | Jitter2",
    "summary": "Struct SimplexSolverAB Namespace Jitter2.Collision Assembly Jitter2.dll Implements the Gilbert-Johnson-Keerthi (GJK) simplex solver with support for retrieving the closest points on the original shapes (A and B spaces). public struct SimplexSolverAB Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Unlike SimplexSolver, this solver tracks barycentric coordinates and the original support points, enabling extraction of the closest points on each shape via GetClosest(out JVector, out JVector). Complexity: O(1) per vertex addition with early-out optimizations. Methods AddVertex(in Vertex, out JVector) Adds a vertex (with full A/B support point data) to the simplex and computes the new closest point to the origin. public bool AddVertex(in MinkowskiDifference.Vertex vertex, out JVector closest) Parameters vertex MinkowskiDifference.Vertex The Minkowski difference vertex including support points from both shapes. closest JVector The point on the reduced simplex closest to the origin. Returns bool true if the origin is not contained within the simplex; false if the origin is enclosed by the tetrahedron. AddVertex(in JVector, out JVector) Adds a vertex to the simplex and computes the new closest point to the origin. public bool AddVertex(in JVector vertex, out JVector closest) Parameters vertex JVector The vertex position on the Minkowski difference. closest JVector The point on the reduced simplex closest to the origin. Returns bool true if the origin is not contained within the simplex; false if the origin is enclosed by the tetrahedron. GetClosest(out JVector, out JVector) Computes the closest points on the original shapes A and B using the current simplex and barycentric coordinates. public void GetClosest(out JVector pointA, out JVector pointB) Parameters pointA JVector The closest point on shape A. pointB JVector The closest point on shape B. Reset() Resets the solver to an empty simplex. public void Reset()"
  },
  "api/Jitter2.Collision.TreeBox.html": {
    "href": "api/Jitter2.Collision.TreeBox.html",
    "title": "Struct TreeBox | Jitter2",
    "summary": "Struct TreeBox Namespace Jitter2.Collision Assembly Jitter2.dll Represents an axis-aligned bounding box with SIMD-friendly memory layout, used for spatial partitioning in acceleration structures such as DynamicTree. public struct TreeBox : IEquatable<TreeBox> Implements IEquatable<TreeBox> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The struct is explicitly laid out to occupy exactly 8 float fields, enabling efficient SIMD operations and binary comparisons. It contains both minimum and maximum corners of the box as JVector, along with unused W components (MinW, MaxW) to match memory alignment. Constructors TreeBox(in JBoundingBox) Creates a new TreeBox from an existing JBoundingBox. public TreeBox(in JBoundingBox box) Parameters box JBoundingBox TreeBox(in JVector, in JVector) Creates a new TreeBox from minimum and maximum corner vectors. public TreeBox(in JVector min, in JVector max) Parameters min JVector max JVector Fields Epsilon Small epsilon value used for ray-box intersection tests. public const float Epsilon = 1E-12 Field Value float Max The maximum corner of the bounding box. public JVector Max Field Value JVector MaxW Padding for SIMD alignment. Not used directly. public float MaxW Field Value float Min The minimum corner of the bounding box. public JVector Min Field Value JVector MinW Padding for SIMD alignment. Not used directly. public float MinW Field Value float Properties Center Gets the center point of the bounding box. public readonly JVector Center { get; } Property Value JVector VectorMax Returns a Vector128<T> view of the Max vector, reinterpreted as a SIMD vector for efficient processing. This enables vectorized operations on the bounding box's maximum corner. public readonly ref Vector128<float> VectorMax { get; } Property Value Vector128<float> VectorMin Returns a Vector128<T> view of the Min vector, reinterpreted as a SIMD vector for efficient processing. This enables vectorized operations on the bounding box's minimum corner. public readonly ref Vector128<float> VectorMin { get; } Property Value Vector128<float> Methods AsJBoundingBox() Converts this TreeBox to a JBoundingBox. public readonly JBoundingBox AsJBoundingBox() Returns JBoundingBox Contains(in TreeBox) Determines whether this box completely encloses the specified TreeBox. public readonly bool Contains(in TreeBox box) Parameters box TreeBox The box to check for containment. Returns bool true if the box is entirely inside this box. Contains(in TreeBox, in TreeBox) Determines whether the outer box completely contains the inner box using SIMD instructions. public static bool Contains(in TreeBox outer, in TreeBox inner) Parameters outer TreeBox The potential container box. inner TreeBox The box to check for inclusion. Returns bool true if inner is fully inside outer. Contains(in JBoundingBox) Determines whether this box completely encloses the specified box. public readonly bool Contains(in JBoundingBox box) Parameters box JBoundingBox The box to check for containment. Returns bool true if the box is entirely inside this box; otherwise, false. Contains(in JVector) Determines whether this box contains the specified point. public readonly bool Contains(in JVector point) Parameters point JVector The point to check. Returns bool true if the point is within the boundaries of this box; otherwise, false. CreateMerged(in TreeBox, in TreeBox, out TreeBox) Creates a new box that encompasses both input boxes. public static void CreateMerged(in TreeBox first, in TreeBox second, out TreeBox result) Parameters first TreeBox The first box. second TreeBox The second box. result TreeBox The resulting union box. Disjoint(in TreeBox) Determines whether this box is completely separated from the specified TreeBox. public readonly bool Disjoint(in TreeBox box) Parameters box TreeBox The box to check against. Returns bool true if the boxes do not overlap; false if they touch or overlap. Disjoint(in TreeBox, in TreeBox) Determines whether two boxes are completely separated (disjoint) using SIMD instructions. public static bool Disjoint(in TreeBox first, in TreeBox second) Parameters first TreeBox The first box. second TreeBox The second box. Returns bool true if the boxes do not overlap on any axis; false if they touch or intersect. Disjoint(in JBoundingBox) Determines whether this box is completely separated from (does not overlap) the specified box. public readonly bool Disjoint(in JBoundingBox box) Parameters box JBoundingBox The box to check against. Returns bool true if the boxes are separated by a gap on at least one axis; otherwise, false. Encompasses(in JBoundingBox) Determines whether this box completely encloses the specified box. [Obsolete(\"Use Contains instead.\")] public readonly bool Encompasses(in JBoundingBox box) Parameters box JBoundingBox Returns bool Remarks This is an alias for Contains(in JBoundingBox). Equals(TreeBox) Indicates whether the current object is equal to another object of the same type. public readonly bool Equals(TreeBox other) Parameters other TreeBox An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(in TreeBox, in TreeBox) Determines whether two boxes are equal using binary comparison. public static bool Equals(in TreeBox first, in TreeBox second) Parameters first TreeBox second TreeBox Returns bool Equals(object?) Indicates whether this instance and a specified object are equal. public override readonly bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override readonly int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. GetSurfaceArea() Calculates the surface area of the bounding box. public readonly double GetSurfaceArea() Returns double The total surface area (\\(2(xy + yz + zx)\\)). MergedSurface(in TreeBox, in TreeBox) Calculates the surface area of a hypothetical box that would result from merging the two specified boxes. public static double MergedSurface(in TreeBox first, in TreeBox second) Parameters first TreeBox The first box. second TreeBox The second box. Returns double The surface area of the union box. Used for SAH (Surface Area Heuristic) costs. NotDisjoint(in TreeBox, in TreeBox) Determines whether two boxes overlap using SIMD instructions. [Obsolete(\"Use !Disjoint instead.\")] public static bool NotDisjoint(in TreeBox first, in TreeBox second) Parameters first TreeBox The first box. second TreeBox The second box. Returns bool true if the boxes intersect; false if they are disjoint. NotDisjoint(in JBoundingBox) Determines whether this box intersects with or overlaps the specified box. [Obsolete(\"Use !Disjoint instead.\")] public readonly bool NotDisjoint(in JBoundingBox box) Parameters box JBoundingBox The box to check against. Returns bool true if the boxes overlap; false if they are completely separated. RayIntersect(in JVector, in JVector) Checks if an infinite ray intersects this bounding box. public readonly bool RayIntersect(in JVector origin, in JVector direction) Parameters origin JVector The origin of the ray. direction JVector The direction of the ray (not necessarily normalized). Returns bool true if the ray intersects the box; otherwise, false. RayIntersect(in JVector, in JVector, out float) Checks if an infinite ray intersects this bounding box and calculates the entry distance. public readonly bool RayIntersect(in JVector origin, in JVector direction, out float enter) Parameters origin JVector The origin of the ray. direction JVector The direction of the ray (not necessarily normalized). enter float Outputs the scalar distance along the direction vector where the ray enters the box. If inside, this is 0. Returns bool true if the ray intersects the box; otherwise, false. SegmentIntersect(in JVector, in JVector) Checks if a finite line segment intersects this bounding box. public readonly bool SegmentIntersect(in JVector origin, in JVector direction) Parameters origin JVector The start point of the segment. direction JVector The vector defining the direction and length of the segment (End Point = Origin + Direction). Returns bool true if the segment passes through the box; otherwise, false. ToString() Returns the fully qualified type name of this instance. public override readonly string ToString() Returns string The fully qualified type name. Operators operator ==(TreeBox, TreeBox) public static bool operator ==(TreeBox left, TreeBox right) Parameters left TreeBox right TreeBox Returns bool operator !=(TreeBox, TreeBox) public static bool operator !=(TreeBox left, TreeBox right) Parameters left TreeBox right TreeBox Returns bool See Also JBoundingBox JVector"
  },
  "api/Jitter2.Collision.TriangleEdgeCollisionFilter.html": {
    "href": "api/Jitter2.Collision.TriangleEdgeCollisionFilter.html",
    "title": "Class TriangleEdgeCollisionFilter | Jitter2",
    "summary": "Class TriangleEdgeCollisionFilter Namespace Jitter2.Collision Assembly Jitter2.dll Filters internal edge collisions for triangle mesh geometry. public class TriangleEdgeCollisionFilter : INarrowPhaseFilter Inheritance object TriangleEdgeCollisionFilter Implements INarrowPhaseFilter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks When rigid bodies slide over triangle meshes, they may collide with internal edges where triangles meet, causing jitter. This filter adjusts collision normals at edges to match neighboring triangles or discards the collision entirely. Works best with manifold meshes that have adjacency information. Boundary edges (no neighbor) are processed normally. Back-face collisions are discarded. Properties AngleThreshold Gets or sets the angle threshold for determining when two triangle normals are considered identical. public JAngle AngleThreshold { get; set; } Property Value JAngle The default value is approximately 2.5 degrees. Remarks When a collision occurs near an edge, this threshold determines whether the current triangle and its neighbor are treated as coplanar (same normal) or as forming a crease. Coplanar neighbors use simpler normal snapping logic. This threshold is also used to detect and discard back-face collisions: if the collision normal points opposite to the triangle normal (beyond this angle from perpendicular), the collision is filtered out. EdgeThreshold Gets or sets the distance threshold for edge collision detection, in world units. public float EdgeThreshold { get; set; } Property Value float The default value is 0.01 world units. Remarks Collision points closer than this distance to a triangle edge are considered edge collisions and may have their normals adjusted or be discarded. Larger values are more aggressive at filtering edges but may incorrectly affect legitimate collisions near triangle boundaries. ProjectionThreshold Gets or sets the minimum length of the projected collision normal required to keep the contact. public float ProjectionThreshold { get; set; } Property Value float The default value is 0.5. Remarks When the collision normal is projected onto the plane formed by the triangle normal and its neighbor's normal, a very short projection indicates the collision is occurring along the edge crease itself. Such collisions are discarded as they typically represent internal edge artifacts. Lower values allow more edge collisions through; higher values are more aggressive at filtering. Methods Filter(RigidBodyShape, RigidBodyShape, ref JVector, ref JVector, ref JVector, ref float) Called for each detected collision with its contact data. public bool Filter(RigidBodyShape shapeA, RigidBodyShape shapeB, ref JVector pointA, ref JVector pointB, ref JVector normal, ref float penetration) Parameters shapeA RigidBodyShape The first shape in the collision. shapeB RigidBodyShape The second shape in the collision. pointA JVector Contact point on shape A (modifiable). pointB JVector Contact point on shape B (modifiable). normal JVector Collision normal from B to A (modifiable). penetration float Penetration depth (modifiable). Returns bool true to keep the collision; false to discard it."
  },
  "api/Jitter2.Collision.html": {
    "href": "api/Jitter2.Collision.html",
    "title": "Namespace Jitter2.Collision | Jitter2",
    "summary": "Namespace Jitter2.Collision Classes DynamicTree Represents a dynamic AABB tree for broadphase collision detection. Island Represents an island, which is a collection of bodies that are either directly or indirectly in contact with each other. MinkowskiDifference Provides methods for computing points on the Minkowski difference of two convex shapes. NarrowPhase Provides collision detection algorithms for convex shapes defined by support functions. TriangleEdgeCollisionFilter Filters internal edge collisions for triangle mesh geometry. Structs CollisionManifold Represents a contact manifold between two convex shapes, storing up to six contact points. ConvexPolytope Represents a convex polytope builder used in the Expanding Polytope Algorithm (EPA) for computing penetration depth and contact information. ConvexPolytope.Triangle DynamicTree.Node Represents a node in the AABB tree. DynamicTree.RayCastResult Represents the result of a ray cast against the dynamic tree. MinkowskiDifference.Vertex Represents a vertex on the Minkowski difference of two shapes. SimplexSolver Implements the Gilbert-Johnson-Keerthi (GJK) simplex solver for finding the closest point to the origin on a simplex (point, line segment, triangle, or tetrahedron). SimplexSolverAB Implements the Gilbert-Johnson-Keerthi (GJK) simplex solver with support for retrieving the closest points on the original shapes (A and B spaces). TreeBox Represents an axis-aligned bounding box with SIMD-friendly memory layout, used for spatial partitioning in acceleration structures such as DynamicTree. Interfaces IBroadPhaseFilter Provides a hook into the broadphase collision detection pipeline. IDynamicTreeProxy Represents an entity that can be tracked by the DynamicTree for broadphase collision detection. INarrowPhaseFilter Provides a hook into the narrowphase collision detection pipeline. IRayCastable Represents an entity that can be intersected by a ray. ISupportMappable Defines an interface for a generic convex shape characterized by its support function. IUpdatableBoundingBox Represents an entity whose bounding box can be recomputed. Enums DynamicTree.Timings Profiling buckets for DebugTimings, representing stages of Update(bool, float). Delegates DynamicTree.RayCastFilterPost Delegate for filtering ray cast results after the shape intersection test. DynamicTree.RayCastFilterPre Delegate for filtering ray cast candidates before the shape intersection test."
  },
  "api/Jitter2.DataStructures.IPartitionedSetIndex.html": {
    "href": "api/Jitter2.DataStructures.IPartitionedSetIndex.html",
    "title": "Interface IPartitionedSetIndex | Jitter2",
    "summary": "Interface IPartitionedSetIndex Namespace Jitter2.DataStructures Assembly Jitter2.dll Defines an index property used by PartitionedSet<T> to track element positions. public interface IPartitionedSetIndex Properties SetIndex Gets or sets the index of the element within the PartitionedSet<T>. A value of -1 indicates the element is not part of any set. int SetIndex { get; set; } Property Value int"
  },
  "api/Jitter2.DataStructures.PartitionedSet-1.Enumerator.html": {
    "href": "api/Jitter2.DataStructures.PartitionedSet-1.Enumerator.html",
    "title": "Struct PartitionedSet<T>.Enumerator | Jitter2",
    "summary": "Struct PartitionedSet<T>.Enumerator Namespace Jitter2.DataStructures Assembly Jitter2.dll public struct PartitionedSet<T>.Enumerator : IEnumerator<T>, IEnumerator, IDisposable Implements IEnumerator<T> IEnumerator IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Enumerator(PartitionedSet<T>) public Enumerator(PartitionedSet<T> partitionedSet) Parameters partitionedSet PartitionedSet<T> Properties Current Gets the element in the collection at the current position of the enumerator. public readonly T Current { get; } Property Value T The element in the collection at the current position of the enumerator. Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public readonly void Dispose() MoveNext() Advances the enumerator to the next element of the collection. public bool MoveNext() Returns bool true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection. Exceptions InvalidOperationException The collection was modified after the enumerator was created. Reset() Sets the enumerator to its initial position, which is before the first element in the collection. public void Reset() Exceptions InvalidOperationException The collection was modified after the enumerator was created. NotSupportedException The enumerator does not support being reset."
  },
  "api/Jitter2.DataStructures.PartitionedSet-1.html": {
    "href": "api/Jitter2.DataStructures.PartitionedSet-1.html",
    "title": "Class PartitionedSet<T> | Jitter2",
    "summary": "Class PartitionedSet<T> Namespace Jitter2.DataStructures Assembly Jitter2.dll Represents a collection of objects that can be partitioned into active and inactive subsets. public class PartitionedSet<T> : IEnumerable<T>, IEnumerable where T : class, IPartitionedSetIndex Type Parameters T The type of elements in the set, which must implement IPartitionedSetIndex. Inheritance object PartitionedSet<T> Implements IEnumerable<T> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The methods Add(T, bool), Remove(T), Contains(T), IsActive(T), MoveToActive(T), and MoveToInactive(T) all operate in O(1) time complexity. Constructors PartitionedSet(int) Initializes a new instance of the PartitionedSet<T> class. public PartitionedSet(int initialSize = 1024) Parameters initialSize int The initial capacity of the internal array. Properties Active Returns a span of active elements in the set. public ReadOnlySpan<T> Active { get; } Property Value ReadOnlySpan<T> ActiveCount Gets the number of active elements in the set. public int ActiveCount { get; } Property Value int Count Gets the total number of elements in the set. public int Count { get; } Property Value int Elements Returns a span of all elements in the set. public ReadOnlySpan<T> Elements { get; } Property Value ReadOnlySpan<T> Inactive Returns a span of inactive elements in the set. public ReadOnlySpan<T> Inactive { get; } Property Value ReadOnlySpan<T> this[int] Gets the element at the specified index. public T this[int i] { get; } Parameters i int Property Value T Methods Add(T, bool) Adds an element to the set. public void Add(T element, bool active = false) Parameters element T The element to add. active bool If true, the element is added to the active partition. AsSpan() Returns a span of all elements in the set. public Span<T> AsSpan() Returns Span<T> Clear() Removes all elements from the set. public void Clear() Contains(T) Determines whether the set contains the specified element. public bool Contains(T element) Parameters element T The element to locate. Returns bool true if the element is found; otherwise, false. GetEnumerator() public PartitionedSet<T>.Enumerator GetEnumerator() Returns PartitionedSet<T>.Enumerator IsActive(T) Determines whether the specified element is in the active partition. public bool IsActive(T element) Parameters element T The element to check. Returns bool true if the element is active; otherwise, false. MoveToActive(T) Moves an element to the active partition. public bool MoveToActive(T element) Parameters element T The element to move. Returns bool true if the element was moved; false if it was already active. MoveToInactive(T) Moves an element to the inactive partition. public bool MoveToInactive(T element) Parameters element T The element to move. Returns bool true if the element was moved; false if it was already inactive. Remove(T) Removes the specified element from the set. public void Remove(T element) Parameters element T The element to remove."
  },
  "api/Jitter2.DataStructures.ReadOnlyHashSet-1.html": {
    "href": "api/Jitter2.DataStructures.ReadOnlyHashSet-1.html",
    "title": "Struct ReadOnlyHashSet<T> | Jitter2",
    "summary": "Struct ReadOnlyHashSet<T> Namespace Jitter2.DataStructures Assembly Jitter2.dll A read-only wrapper around HashSet<T> that prevents modification while allowing enumeration and lookup. public readonly struct ReadOnlyHashSet<T> : IReadOnlyCollection<T>, IEnumerable<T>, IEnumerable Type Parameters T The type of elements in the set. Implements IReadOnlyCollection<T> IEnumerable<T> IEnumerable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ReadOnlyHashSet(HashSet<T>) A read-only wrapper around HashSet<T> that prevents modification while allowing enumeration and lookup. public ReadOnlyHashSet(HashSet<T> hashset) Parameters hashset HashSet<T> Properties Count Gets the number of elements in the set. public int Count { get; } Property Value int Methods Contains(T) Determines whether the set contains the specified element. public bool Contains(T item) Parameters item T Returns bool CopyTo(T[]) Copies the elements of the set to an array. public void CopyTo(T[] array) Parameters array T[] CopyTo(T[], int) Copies the elements of the set to an array, starting at a particular index. public void CopyTo(T[] array, int arrayIndex) Parameters array T[] arrayIndex int GetEnumerator() public HashSet<T>.Enumerator GetEnumerator() Returns HashSet<T>.Enumerator"
  },
  "api/Jitter2.DataStructures.ReadOnlyList-1.html": {
    "href": "api/Jitter2.DataStructures.ReadOnlyList-1.html",
    "title": "Struct ReadOnlyList<T> | Jitter2",
    "summary": "Struct ReadOnlyList<T> Namespace Jitter2.DataStructures Assembly Jitter2.dll A read-only wrapper around List<T> that prevents modification while allowing indexed access and enumeration. public readonly struct ReadOnlyList<T> : IReadOnlyList<T>, IReadOnlyCollection<T>, IEnumerable<T>, IEnumerable Type Parameters T The type of elements in the list. Implements IReadOnlyList<T> IReadOnlyCollection<T> IEnumerable<T> IEnumerable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ReadOnlyList(List<T>) A read-only wrapper around List<T> that prevents modification while allowing indexed access and enumeration. public ReadOnlyList(List<T> list) Parameters list List<T> Properties Count Gets the number of elements in the list. public int Count { get; } Property Value int this[int] Gets the element at the specified index. public T this[int i] { get; } Parameters i int Property Value T Methods GetEnumerator() public List<T>.Enumerator GetEnumerator() Returns List<T>.Enumerator"
  },
  "api/Jitter2.DataStructures.ReadOnlyPartitionedSet-1.html": {
    "href": "api/Jitter2.DataStructures.ReadOnlyPartitionedSet-1.html",
    "title": "Struct ReadOnlyPartitionedSet<T> | Jitter2",
    "summary": "Struct ReadOnlyPartitionedSet<T> Namespace Jitter2.DataStructures Assembly Jitter2.dll A read-only wrapper around PartitionedSet<T>. public readonly struct ReadOnlyPartitionedSet<T> : IEnumerable<T>, IEnumerable where T : class, IPartitionedSetIndex Type Parameters T The type of elements in the set. Implements IEnumerable<T> IEnumerable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods ParallelExtensions.ParallelForBatch<T>(ReadOnlyPartitionedSet<T>, int, Action<Parallel.Batch>, bool) Constructors ReadOnlyPartitionedSet(PartitionedSet<T>) A read-only wrapper around PartitionedSet<T>. public ReadOnlyPartitionedSet(PartitionedSet<T> partitionedSet) Parameters partitionedSet PartitionedSet<T> Properties Active Returns a read-only span of the active elements in the set. public ReadOnlySpan<T> Active { get; } Property Value ReadOnlySpan<T> ActiveCount Gets the number of active elements. public int ActiveCount { get; } Property Value int Count Gets the total number of elements. public int Count { get; } Property Value int Elements Returns a read-only span of all elements in the set. public ReadOnlySpan<T> Elements { get; } Property Value ReadOnlySpan<T> Inactive Returns a read-only span of the inactive elements in the set. public ReadOnlySpan<T> Inactive { get; } Property Value ReadOnlySpan<T> this[int] Gets the element at the specified index. public T this[int i] { get; } Parameters i int Property Value T Methods Contains(T) Determines whether the set contains the specified element. public bool Contains(T element) Parameters element T Returns bool GetEnumerator() public PartitionedSet<T>.Enumerator GetEnumerator() Returns PartitionedSet<T>.Enumerator IsActive(T) Determines whether the specified element is in the active partition. public bool IsActive(T element) Parameters element T Returns bool"
  },
  "api/Jitter2.DataStructures.html": {
    "href": "api/Jitter2.DataStructures.html",
    "title": "Namespace Jitter2.DataStructures | Jitter2",
    "summary": "Namespace Jitter2.DataStructures Classes PartitionedSet<T> Represents a collection of objects that can be partitioned into active and inactive subsets. Structs PartitionedSet<T>.Enumerator ReadOnlyHashSet<T> A read-only wrapper around HashSet<T> that prevents modification while allowing enumeration and lookup. ReadOnlyList<T> A read-only wrapper around List<T> that prevents modification while allowing indexed access and enumeration. ReadOnlyPartitionedSet<T> A read-only wrapper around PartitionedSet<T>. Interfaces IPartitionedSetIndex Defines an index property used by PartitionedSet<T> to track element positions."
  },
  "api/Jitter2.Dynamics.Arbiter.html": {
    "href": "api/Jitter2.Dynamics.Arbiter.html",
    "title": "Class Arbiter | Jitter2",
    "summary": "Class Arbiter Namespace Jitter2.Dynamics Assembly Jitter2.dll Manages contact information between two different rigid bodies. public sealed class Arbiter Inheritance object Arbiter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks An arbiter is created when two shapes begin overlapping and is removed when they separate or when one of the involved bodies is removed from the world. Each arbiter can hold up to four cached contact points (see ContactData). In most cases arbiters are keyed by shape identifiers. For arbiters created by the engine, the ordering is canonical: the shape with the smaller ID is always first. The Handle property provides access to the underlying ContactData stored in unmanaged memory. This data is only valid while the arbiter exists and must not be accessed concurrently with Step(float, bool). Properties Body1 Gets the first rigid body involved in this contact. public RigidBody Body1 { get; } Property Value RigidBody Body2 Gets the second rigid body involved in this contact. public RigidBody Body2 { get; } Property Value RigidBody Handle Gets the handle to the ContactData stored in unmanaged memory. public JHandle<ContactData> Handle { get; } Property Value JHandle<ContactData> Remarks The underlying data is valid only while this arbiter is registered with the world. After removal, accessing Data results in undefined behavior."
  },
  "api/Jitter2.Dynamics.ArbiterKey.html": {
    "href": "api/Jitter2.Dynamics.ArbiterKey.html",
    "title": "Struct ArbiterKey | Jitter2",
    "summary": "Struct ArbiterKey Namespace Jitter2.Dynamics Assembly Jitter2.dll Represents an ordered pair of identifiers used to look up an Arbiter. public readonly struct ArbiterKey : IEquatable<ArbiterKey> Implements IEquatable<ArbiterKey> Inherited Members ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The order of key1 and key2 matters for equality comparison. For arbiters created by the physics engine, key1 is always less than key2. Constructors ArbiterKey(ulong, ulong) Represents an ordered pair of identifiers used to look up an Arbiter. public ArbiterKey(ulong key1, ulong key2) Parameters key1 ulong The first identifier (typically the smaller shape ID). key2 ulong The second identifier (typically the larger shape ID). Remarks The order of key1 and key2 matters for equality comparison. For arbiters created by the physics engine, key1 is always less than key2. Fields Key1 The first identifier in the pair. public readonly ulong Key1 Field Value ulong Key2 The second identifier in the pair. public readonly ulong Key2 Field Value ulong Methods Equals(ArbiterKey) Indicates whether the current object is equal to another object of the same type. public bool Equals(ArbiterKey other) Parameters other ArbiterKey An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. Operators operator ==(ArbiterKey, ArbiterKey) public static bool operator ==(ArbiterKey left, ArbiterKey right) Parameters left ArbiterKey right ArbiterKey Returns bool operator !=(ArbiterKey, ArbiterKey) public static bool operator !=(ArbiterKey left, ArbiterKey right) Parameters left ArbiterKey right ArbiterKey Returns bool"
  },
  "api/Jitter2.Dynamics.Constraints.AngularLimit.html": {
    "href": "api/Jitter2.Dynamics.Constraints.AngularLimit.html",
    "title": "Struct AngularLimit | Jitter2",
    "summary": "Struct AngularLimit Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Represents an angular limit defined by a minimum and maximum angle. Used by constraints to restrict rotational motion within a specified range. public struct AngularLimit Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors AngularLimit(JAngle, JAngle) Represents an angular limit defined by a minimum and maximum angle. Used by constraints to restrict rotational motion within a specified range. public AngularLimit(JAngle from, JAngle to) Parameters from JAngle The minimum angle of the limit. to JAngle The maximum angle of the limit. Fields Fixed A limit that locks the angle in place (no rotation allowed). public static readonly AngularLimit Fixed Field Value AngularLimit Full A limit that allows full rotation (- to + radians). public static readonly AngularLimit Full Field Value AngularLimit Properties From Gets or sets the minimum angle of the limit. public JAngle From { readonly get; set; } Property Value JAngle To Gets or sets the maximum angle of the limit. public JAngle To { readonly get; set; } Property Value JAngle Methods Deconstruct(out JAngle, out JAngle) Deconstructs the limit into its minimum and maximum angles. public readonly void Deconstruct(out JAngle limitMin, out JAngle limitMax) Parameters limitMin JAngle The minimum angle. limitMax JAngle The maximum angle. FromDegree(float, float) Creates an angular limit from degree values. public static AngularLimit FromDegree(float min, float max) Parameters min float The minimum angle in degrees. max float The maximum angle in degrees. Returns AngularLimit A new AngularLimit instance."
  },
  "api/Jitter2.Dynamics.Constraints.AngularMotor.AngularMotorData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.AngularMotor.AngularMotorData.html",
    "title": "Struct AngularMotor.AngularMotorData | Jitter2",
    "summary": "Struct AngularMotor.AngularMotorData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll public struct AngularMotor.AngularMotorData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public float AccumulatedImpulse Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> EffectiveMass public float EffectiveMass Field Value float Iterate public delegate*<ref ConstraintData, void> Iterate Field Value delegate*<ref ConstraintData, void> LocalAxis1 public JVector LocalAxis1 Field Value JVector LocalAxis2 public JVector LocalAxis2 Field Value JVector MaxForce public float MaxForce Field Value float MaxLambda public float MaxLambda Field Value float PrepareForIteration public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> Velocity public float Velocity Field Value float"
  },
  "api/Jitter2.Dynamics.Constraints.AngularMotor.html": {
    "href": "api/Jitter2.Dynamics.Constraints.AngularMotor.html",
    "title": "Class AngularMotor | Jitter2",
    "summary": "Class AngularMotor Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Represents a motor that drives relative angular velocity between two axes fixed in the reference frames of their respective bodies. public class AngularMotor : Constraint<AngularMotor.AngularMotorData>, IDebugDrawable Inheritance object Constraint Constraint<AngularMotor.AngularMotorData> AngularMotor Implements IDebugDrawable Inherited Members Constraint<AngularMotor.AngularMotorData>.Data Constraint<AngularMotor.AngularMotorData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled Constraint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties LocalAxis1 Gets the motor axis on the first body in local space. public JVector LocalAxis1 { get; } Property Value JVector LocalAxis2 Gets the motor axis on the second body in local space. public JVector LocalAxis2 { get; } Property Value JVector MaximumForce Gets or sets the maximum force the motor can apply. public float MaximumForce { get; set; } Property Value float Default is 0. Must be non-negative. Exceptions ArgumentOutOfRangeException Thrown when value is negative. TargetVelocity Gets or sets the target angular velocity in radians per second. public float TargetVelocity { get; set; } Property Value float Default is 0. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() Initialize(JVector) Initializes the motor with the same axis for both bodies. public void Initialize(JVector axis) Parameters axis JVector The motor axis in world space, used for both bodies. Initialize(JVector, JVector) Initializes the motor with separate axes for each body. public void Initialize(JVector axis1, JVector axis2) Parameters axis1 JVector The motor axis on the first body in world space. axis2 JVector The motor axis on the second body in world space. Remarks Stores the axes in local frames. Both axes are normalized internally. Default values: TargetVelocity = 0, MaximumForce = 0. IterateAngularMotor(ref ConstraintData, float) public static void IterateAngularMotor(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float PrepareForIterationAngularMotor(ref ConstraintData, float) public static void PrepareForIterationAngularMotor(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float"
  },
  "api/Jitter2.Dynamics.Constraints.BallSocket.BallSocketData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.BallSocket.BallSocketData.html",
    "title": "Struct BallSocket.BallSocketData | Jitter2",
    "summary": "Struct BallSocket.BallSocketData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll public struct BallSocket.BallSocketData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public JVector AccumulatedImpulse Field Value JVector Bias public JVector Bias Field Value JVector BiasFactor public float BiasFactor Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> EffectiveMass public JMatrix EffectiveMass Field Value JMatrix Iterate public delegate*<ref ConstraintData, void> Iterate Field Value delegate*<ref ConstraintData, void> LocalAnchor1 public JVector LocalAnchor1 Field Value JVector LocalAnchor2 public JVector LocalAnchor2 Field Value JVector PrepareForIteration public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> R1 public JVector R1 Field Value JVector R2 public JVector R2 Field Value JVector Softness public float Softness Field Value float U public JVector U Field Value JVector"
  },
  "api/Jitter2.Dynamics.Constraints.BallSocket.html": {
    "href": "api/Jitter2.Dynamics.Constraints.BallSocket.html",
    "title": "Class BallSocket | Jitter2",
    "summary": "Class BallSocket Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Implements a ball-and-socket joint that anchors a point on each body together, removing three translational degrees of freedom. public class BallSocket : Constraint<BallSocket.BallSocketData>, IDebugDrawable Inheritance object Constraint Constraint<BallSocket.BallSocketData> BallSocket Implements IDebugDrawable Inherited Members Constraint<BallSocket.BallSocketData>.Data Constraint<BallSocket.BallSocketData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled Constraint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Anchor1 Gets or sets the anchor point on the first rigid body in world space. The anchor point is fixed in the local reference frame of the first body. [ReferenceFrame(ReferenceFrame.World)] public JVector Anchor1 { get; set; } Property Value JVector Anchor2 Gets or sets the anchor point on the second rigid body in world space. The anchor point is fixed in the local reference frame of the second body. [ReferenceFrame(ReferenceFrame.World)] public JVector Anchor2 { get; set; } Property Value JVector Bias Gets or sets the bias factor controlling how aggressively positional error is corrected. public float Bias { get; set; } Property Value float Default is 0.2. Range [0, 1]. Higher values correct errors faster but may cause instability. Impulse Gets the accumulated impulse applied by this constraint during the last step. public JVector Impulse { get; } Property Value JVector Softness Gets or sets the softness (compliance) of the constraint. public float Softness { get; set; } Property Value float Default is 0. Higher values allow more positional error but improve stability. Scaled by inverse timestep during solving. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() Initialize(JVector) Initializes the constraint from a world-space anchor point. public void Initialize(JVector anchor) Parameters anchor JVector The anchor point in world space, shared by both bodies. Remarks Computes local anchor points for each body from their current poses. Default values: Bias = 0.2, Softness = 0. IterateBallSocket(ref ConstraintData, float) public static void IterateBallSocket(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float PrepareForIterationBallSocket(ref ConstraintData, float) public static void PrepareForIterationBallSocket(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float"
  },
  "api/Jitter2.Dynamics.Constraints.ConeLimit.ConeLimitData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.ConeLimit.ConeLimitData.html",
    "title": "Struct ConeLimit.ConeLimitData | Jitter2",
    "summary": "Struct ConeLimit.ConeLimitData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll public struct ConeLimit.ConeLimitData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public float AccumulatedImpulse Field Value float Bias public float Bias Field Value float BiasFactor public float BiasFactor Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Clamp public short Clamp Field Value short EffectiveMass public float EffectiveMass Field Value float Iterate public delegate*<ref ConstraintData, void> Iterate Field Value delegate*<ref ConstraintData, void> J0 public MemoryHelper.MemBlock6Real J0 Field Value MemoryHelper.MemBlock6Real LimitHigh public float LimitHigh Field Value float LimitLow public float LimitLow Field Value float LocalAxis1 public JVector LocalAxis1 Field Value JVector LocalAxis2 public JVector LocalAxis2 Field Value JVector PrepareForIteration public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> Softness public float Softness Field Value float"
  },
  "api/Jitter2.Dynamics.Constraints.ConeLimit.html": {
    "href": "api/Jitter2.Dynamics.Constraints.ConeLimit.html",
    "title": "Class ConeLimit | Jitter2",
    "summary": "Class ConeLimit Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Limits the relative tilt between two bodies, removing one angular degree of freedom when active. public class ConeLimit : Constraint<ConeLimit.ConeLimitData>, IDebugDrawable Inheritance object Constraint Constraint<ConeLimit.ConeLimitData> ConeLimit Implements IDebugDrawable Inherited Members Constraint<ConeLimit.ConeLimitData>.Data Constraint<ConeLimit.ConeLimitData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled Constraint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Angle Gets the current angle between the two body axes. public JAngle Angle { get; } Property Value JAngle AxisBody1 Gets or sets the reference axis of body 1 in world space. public JVector AxisBody1 { get; set; } Property Value JVector AxisBody2 Gets or sets the reference axis of body 2 in world space. public JVector AxisBody2 { get; set; } Property Value JVector Bias Gets or sets the bias factor controlling how aggressively angular error is corrected. public float Bias { get; set; } Property Value float Default is 0.2. Range [0, 1]. Higher values correct errors faster but may cause instability. Impulse Gets the accumulated impulse applied by this constraint during the last step. public float Impulse { get; } Property Value float Limit Gets or sets the angular limit of the cone. public AngularLimit Limit { get; set; } Property Value AngularLimit Softness Gets or sets the softness (compliance) of the constraint. public float Softness { get; set; } Property Value float Default is 0.001. Higher values allow more angular error but improve stability. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() Initialize(JVector, AngularLimit) Initializes the cone limit using a world-space axis and an angular range. public void Initialize(JVector axis, AngularLimit limit) Parameters axis JVector The reference axis in world space for the initial pose. limit AngularLimit The minimum and maximum allowed tilt angles. Remarks Stores the axis as a local axis on each body. The constraint measures the angle between these axes and restricts it to the given range. Default values: Softness = 0.001, Bias = 0.2. Initialize(JVector, JVector, AngularLimit) Initializes the cone limit using two world-space axes and an angular range. public void Initialize(JVector axisBody1, JVector axisBody2, AngularLimit limit) Parameters axisBody1 JVector The reference axis for body 1 in world space. axisBody2 JVector The reference axis for body 2 in world space. limit AngularLimit The minimum and maximum allowed tilt angles. Remarks Each axis is stored as a local axis on the corresponding body. The constraint measures the angle between these axes and restricts it to the given range. Default values: Softness = 0.001, Bias = 0.2. IterateConeLimit(ref ConstraintData, float) public static void IterateConeLimit(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float PrepareForIterationConeLimit(ref ConstraintData, float) public static void PrepareForIterationConeLimit(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float"
  },
  "api/Jitter2.Dynamics.Constraints.Constraint-1.html": {
    "href": "api/Jitter2.Dynamics.Constraints.Constraint-1.html",
    "title": "Class Constraint<T> | Jitter2",
    "summary": "Class Constraint<T> Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Generic base class for constraints that store custom data of type T. public abstract class Constraint<T> : Constraint, IDebugDrawable where T : unmanaged Type Parameters T The unmanaged data structure containing constraint-specific state. Must fit within ConstraintData (i.e., ConstraintSizeFull bytes). Inheritance object Constraint Constraint<T> Implements IDebugDrawable Derived AngularMotor BallSocket ConeLimit DistanceLimit FixedAngle HingeAngle LinearMotor PointOnLine PointOnPlane TwistAngle SpringConstraint Inherited Members Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled Constraint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Derive from this class to create constraints with custom data layouts. The Data property provides typed access to the constraint's unmanaged memory. Properties Data Gets a reference to the constraint's typed data stored in unmanaged memory. public ref T Data { get; } Property Value T IsSmallConstraint Gets whether this constraint uses the smaller data layout. public override bool IsSmallConstraint { get; } Property Value bool Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create()"
  },
  "api/Jitter2.Dynamics.Constraints.Constraint.html": {
    "href": "api/Jitter2.Dynamics.Constraints.Constraint.html",
    "title": "Class Constraint | Jitter2",
    "summary": "Class Constraint Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Base class for constraints that connect two rigid bodies and restrict their relative motion. public abstract class Constraint : IDebugDrawable Inheritance object Constraint Implements IDebugDrawable Derived Constraint<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Iterate protected delegate*<ref ConstraintData, float, void> Iterate Field Value delegate*<ref ConstraintData, float, void> PrepareForIteration protected delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> Properties Body1 Gets the first rigid body connected by this constraint. public RigidBody Body1 { get; } Property Value RigidBody Body2 Gets the second rigid body connected by this constraint. public RigidBody Body2 { get; } Property Value RigidBody Handle A handle for accessing the raw constraint data. public JHandle<ConstraintData> Handle { get; } Property Value JHandle<ConstraintData> IsEnabled Gets or sets whether this constraint is enabled. public bool IsEnabled { get; set; } Property Value bool Remarks Use Remove(Constraint) for permanent removal. IsSmallConstraint Gets whether this constraint uses the smaller data layout. public virtual bool IsSmallConstraint { get; } Property Value bool SmallHandle Gets a handle to the constraint data reinterpreted as SmallConstraintData. public JHandle<SmallConstraintData> SmallHandle { get; } Property Value JHandle<SmallConstraintData> Methods CheckDataSize<T>() Checks that the constraint data type fits within ConstraintData. protected static void CheckDataSize<T>() where T : unmanaged Type Parameters T The constraint-specific data type. Exceptions InvalidOperationException Thrown if the data type is too large. Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected virtual void Create() DebugDraw(IDebugDrawer) Draws a debug visualization of this constraint. public virtual void DebugDraw(IDebugDrawer drawer) Parameters drawer IDebugDrawer The debug drawer to receive visualization primitives. Exceptions NotImplementedException Thrown if the derived class does not override this method. VerifyNotZero() Verifies that this constraint has been properly created via the World class. protected void VerifyNotZero() Exceptions InvalidOperationException Thrown if the constraint was instantiated directly instead of through CreateConstraint<T>(RigidBody, RigidBody)."
  },
  "api/Jitter2.Dynamics.Constraints.ConstraintData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.ConstraintData.html",
    "title": "Struct ConstraintData | Jitter2",
    "summary": "Struct ConstraintData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Low-level data for constraints, stored in unmanaged memory. public struct ConstraintData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This structure is stored in unmanaged memory and accessed via Handle. It contains function pointers for the solver and handles to the connected bodies. The data is valid only while the constraint is registered with the world. Do not cache references across simulation steps. Not safe to access concurrently with Step(float, bool). Fields Body1 Handle to the first body's simulation data. public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 Handle to the second body's simulation data. public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Iterate Function pointer to the constraint's iteration solver. public delegate*<ref ConstraintData, float, void> Iterate Field Value delegate*<ref ConstraintData, float, void> PrepareForIteration Function pointer to the constraint's pre-iteration setup. public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void>"
  },
  "api/Jitter2.Dynamics.Constraints.DistanceLimit.DistanceLimitData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.DistanceLimit.DistanceLimitData.html",
    "title": "Struct DistanceLimit.DistanceLimitData | Jitter2",
    "summary": "Struct DistanceLimit.DistanceLimitData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll public struct DistanceLimit.DistanceLimitData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public float AccumulatedImpulse Field Value float Bias public float Bias Field Value float BiasFactor public float BiasFactor Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Clamp public short Clamp Field Value short Distance public float Distance Field Value float EffectiveMass public float EffectiveMass Field Value float Iterate public delegate*<ref ConstraintData, void> Iterate Field Value delegate*<ref ConstraintData, void> J0 public MemoryHelper.MemBlock12Real J0 Field Value MemoryHelper.MemBlock12Real LimitMax public float LimitMax Field Value float LimitMin public float LimitMin Field Value float LocalAnchor1 public JVector LocalAnchor1 Field Value JVector LocalAnchor2 public JVector LocalAnchor2 Field Value JVector PrepareForIteration public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> Softness public float Softness Field Value float"
  },
  "api/Jitter2.Dynamics.Constraints.DistanceLimit.html": {
    "href": "api/Jitter2.Dynamics.Constraints.DistanceLimit.html",
    "title": "Class DistanceLimit | Jitter2",
    "summary": "Class DistanceLimit Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Constrains the distance between a fixed point in the reference frame of one body and a fixed point in the reference frame of another body. This constraint removes one translational degree of freedom. For a distance of zero, use the BallSocket constraint. public class DistanceLimit : Constraint<DistanceLimit.DistanceLimitData>, IDebugDrawable Inheritance object Constraint Constraint<DistanceLimit.DistanceLimitData> DistanceLimit Implements IDebugDrawable Inherited Members Constraint<DistanceLimit.DistanceLimitData>.Data Constraint<DistanceLimit.DistanceLimitData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled Constraint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Anchor1 Gets or sets the anchor point on the first rigid body in world space. The anchor point is fixed in the local reference frame of the first body. [ReferenceFrame(ReferenceFrame.World)] public JVector Anchor1 { get; set; } Property Value JVector Anchor2 Gets or sets the anchor point on the second rigid body in world space. The anchor point is fixed in the local reference frame of the second body. [ReferenceFrame(ReferenceFrame.World)] public JVector Anchor2 { get; set; } Property Value JVector Bias Gets or sets the bias factor controlling how aggressively distance error is corrected. public float Bias { get; set; } Property Value float Default is 0.2. Range [0, 1]. Higher values correct errors faster but may cause instability. Distance Gets the current distance between anchor points in world space. public float Distance { get; } Property Value float Impulse Gets the accumulated impulse applied by this constraint during the last step. public float Impulse { get; } Property Value float Softness Gets or sets the softness (compliance) of the constraint. public float Softness { get; set; } Property Value float Default is 0.001. Higher values allow more distance error but improve stability. TargetDistance Gets or sets the target distance between anchor points. public float TargetDistance { get; set; } Property Value float Set during initialization from the initial anchor separation. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() Initialize(JVector, JVector) Initializes the constraint with a fixed distance between anchor points. public void Initialize(JVector anchor1, JVector anchor2) Parameters anchor1 JVector Anchor point on the first body in world space. anchor2 JVector Anchor point on the second body in world space. Initialize(JVector, JVector, LinearLimit) Initializes the constraint with distance limits between anchor points. public void Initialize(JVector anchor1, JVector anchor2, LinearLimit limit) Parameters anchor1 JVector Anchor point on the first body in world space. anchor2 JVector Anchor point on the second body in world space. limit LinearLimit The allowed distance range between anchor points. Remarks Computes local anchor points and the initial distance from current poses. Default values: Softness = 0.001, Bias = 0.2. IterateFixedAngle(ref ConstraintData, float) public static void IterateFixedAngle(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float PrepareForIterationFixedAngle(ref ConstraintData, float) public static void PrepareForIterationFixedAngle(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float"
  },
  "api/Jitter2.Dynamics.Constraints.FixedAngle.FixedAngleData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.FixedAngle.FixedAngleData.html",
    "title": "Struct FixedAngle.FixedAngleData | Jitter2",
    "summary": "Struct FixedAngle.FixedAngleData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll public struct FixedAngle.FixedAngleData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public JVector AccumulatedImpulse Field Value JVector Bias public JVector Bias Field Value JVector BiasFactor public float BiasFactor Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Clamp public ushort Clamp Field Value ushort EffectiveMass public JMatrix EffectiveMass Field Value JMatrix Iterate public delegate*<ref ConstraintData, void> Iterate Field Value delegate*<ref ConstraintData, void> Jacobian public JMatrix Jacobian Field Value JMatrix MaxAngle public float MaxAngle Field Value float MinAngle public float MinAngle Field Value float PrepareForIteration public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> Q0 public JQuaternion Q0 Field Value JQuaternion Softness public float Softness Field Value float"
  },
  "api/Jitter2.Dynamics.Constraints.FixedAngle.html": {
    "href": "api/Jitter2.Dynamics.Constraints.FixedAngle.html",
    "title": "Class FixedAngle | Jitter2",
    "summary": "Class FixedAngle Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Constrains the relative orientation between two bodies, eliminating three degrees of rotational freedom. public class FixedAngle : Constraint<FixedAngle.FixedAngleData>, IDebugDrawable Inheritance object Constraint Constraint<FixedAngle.FixedAngleData> FixedAngle Implements IDebugDrawable Inherited Members Constraint<FixedAngle.FixedAngleData>.Data Constraint<FixedAngle.FixedAngleData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled Constraint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Bias Gets or sets the bias factor controlling how aggressively angular error is corrected. public float Bias { get; set; } Property Value float Default is 0.2. Range [0, 1]. Higher values correct errors faster but may cause instability. Impulse Gets the accumulated impulse applied by this constraint during the last step. public JVector Impulse { get; } Property Value JVector Softness Gets or sets the softness (compliance) of the constraint. public float Softness { get; set; } Property Value float Default is 0.001. Higher values allow more angular error but improve stability. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() Initialize() Initializes the constraint using the current relative orientation of the bodies. public void Initialize() Remarks Records the current relative orientation as the target. Default values: Softness = 0.001, Bias = 0.2. IterateFixedAngle(ref ConstraintData, float) public static void IterateFixedAngle(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float PrepareForIterationFixedAngle(ref ConstraintData, float) public static void PrepareForIterationFixedAngle(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float"
  },
  "api/Jitter2.Dynamics.Constraints.HingeAngle.HingeAngleData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.HingeAngle.HingeAngleData.html",
    "title": "Struct HingeAngle.HingeAngleData | Jitter2",
    "summary": "Struct HingeAngle.HingeAngleData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll public struct HingeAngle.HingeAngleData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public JVector AccumulatedImpulse Field Value JVector Axis public JVector Axis Field Value JVector Bias public JVector Bias Field Value JVector BiasFactor public float BiasFactor Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Clamp public ushort Clamp Field Value ushort EffectiveMass public JMatrix EffectiveMass Field Value JMatrix Iterate public delegate*<ref ConstraintData, void> Iterate Field Value delegate*<ref ConstraintData, void> Jacobian public JMatrix Jacobian Field Value JMatrix LimitBias public float LimitBias Field Value float LimitSoftness public float LimitSoftness Field Value float MaxAngle public float MaxAngle Field Value float MinAngle public float MinAngle Field Value float PrepareForIteration public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> Q0 public JQuaternion Q0 Field Value JQuaternion Softness public float Softness Field Value float"
  },
  "api/Jitter2.Dynamics.Constraints.HingeAngle.html": {
    "href": "api/Jitter2.Dynamics.Constraints.HingeAngle.html",
    "title": "Class HingeAngle | Jitter2",
    "summary": "Class HingeAngle Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Constrains two bodies to rotate relative to each other around a single axis, removing two angular degrees of freedom. Optionally enforces angular limits. public class HingeAngle : Constraint<HingeAngle.HingeAngleData>, IDebugDrawable Inheritance object Constraint Constraint<HingeAngle.HingeAngleData> HingeAngle Implements IDebugDrawable Inherited Members Constraint<HingeAngle.HingeAngleData>.Data Constraint<HingeAngle.HingeAngleData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled Constraint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Angle Gets the current angle of rotation around the hinge axis relative to the initial pose. public JAngle Angle { get; } Property Value JAngle Bias Gets or sets the bias factor controlling how aggressively angular error is corrected. public float Bias { get; set; } Property Value float Default is 0.2. Range [0, 1]. Higher values correct errors faster but may cause instability. Impulse Gets the accumulated impulse applied by this constraint during the last step. public JVector Impulse { get; } Property Value JVector Limit Sets the angular limits for the hinge rotation. public AngularLimit Limit { set; } Property Value AngularLimit LimitBias Gets or sets the bias factor for angular limit correction. public float LimitBias { get; set; } Property Value float Default is 0.1. Range [0, 1]. Higher values correct limit violations faster. LimitSoftness Gets or sets the softness (compliance) applied when angular limits are active. public float LimitSoftness { get; set; } Property Value float Default is 0.001. Higher values allow more limit violation but improve stability. Softness Gets or sets the softness (compliance) of the angular constraint. public float Softness { get; set; } Property Value float Default is 0.001. Higher values allow more angular error but improve stability. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() Initialize(JVector, AngularLimit) Initializes the constraint with a rotation axis and angular limits. public void Initialize(JVector axis, AngularLimit limit) Parameters axis JVector The hinge axis in world space around which rotation is allowed. limit AngularLimit The angular limits defining the allowed rotation range. Remarks Stores the axis in the local frame of body 2 and records the initial relative orientation. Default values: Softness = 0.001, LimitSoftness = 0.001, Bias = 0.2, LimitBias = 0.1. IterateHingeAngle(ref ConstraintData, float) public static void IterateHingeAngle(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float PrepareForIterationHingeAngle(ref ConstraintData, float) public static void PrepareForIterationHingeAngle(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float"
  },
  "api/Jitter2.Dynamics.Constraints.HingeJoint.html": {
    "href": "api/Jitter2.Dynamics.Constraints.HingeJoint.html",
    "title": "Class HingeJoint | Jitter2",
    "summary": "Class HingeJoint Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Constructs a hinge joint utilizing a HingeAngle, a BallSocket, and an optional AngularMotor. public class HingeJoint : Joint, IDebugDrawable Inheritance object Joint HingeJoint Implements IDebugDrawable Inherited Members Joint.Constraints Joint.Register(Constraint) Joint.Deregister(Constraint) Joint.Enable() Joint.Disable() Joint.Remove() Joint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HingeJoint(World, RigidBody, RigidBody, JVector, JVector, AngularLimit, bool) public HingeJoint(World world, RigidBody body1, RigidBody body2, JVector hingeCenter, JVector hingeAxis, AngularLimit angle, bool hasMotor = false) Parameters world World body1 RigidBody body2 RigidBody hingeCenter JVector hingeAxis JVector angle AngularLimit hasMotor bool HingeJoint(World, RigidBody, RigidBody, JVector, JVector, bool) public HingeJoint(World world, RigidBody body1, RigidBody body2, JVector hingeCenter, JVector hingeAxis, bool hasMotor = false) Parameters world World body1 RigidBody body2 RigidBody hingeCenter JVector hingeAxis JVector hasMotor bool Properties BallSocket public BallSocket BallSocket { get; } Property Value BallSocket Body1 public RigidBody Body1 { get; } Property Value RigidBody Body2 public RigidBody Body2 { get; } Property Value RigidBody HingeAngle public HingeAngle HingeAngle { get; } Property Value HingeAngle Motor public AngularMotor? Motor { get; } Property Value AngularMotor"
  },
  "api/Jitter2.Dynamics.Constraints.Joint.html": {
    "href": "api/Jitter2.Dynamics.Constraints.Joint.html",
    "title": "Class Joint | Jitter2",
    "summary": "Class Joint Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Base class for joints, which are composite constraints built from multiple Constraint instances. public class Joint : IDebugDrawable Inheritance object Joint Implements IDebugDrawable Derived HingeJoint PrismaticJoint UniversalJoint WeldJoint Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Constraints public ReadOnlyList<Constraint> Constraints { get; } Property Value ReadOnlyList<Constraint> Methods DebugDraw(IDebugDrawer) Passes an IDebugDrawer to draw basic debug information for the object. public virtual void DebugDraw(IDebugDrawer drawer) Parameters drawer IDebugDrawer The debug drawer used for rendering debug information. Deregister(Constraint) Remove a constraint from the internal bookkeeping protected void Deregister(Constraint constraint) Parameters constraint Constraint Disable() Disables all constraints that this joint is composed of temporarily. For a complete removal use Remove(). public void Disable() Enable() Enables all constraints that this joint is composed of. public void Enable() Register(Constraint) Add a constraint to the internal bookkeeping protected void Register(Constraint constraint) Parameters constraint Constraint Remove() Removes all constraints that this joint is composed of from the physics world. public void Remove()"
  },
  "api/Jitter2.Dynamics.Constraints.LinearLimit.html": {
    "href": "api/Jitter2.Dynamics.Constraints.LinearLimit.html",
    "title": "Struct LinearLimit | Jitter2",
    "summary": "Struct LinearLimit Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Represents a linear limit defined by a minimum and maximum distance. Used by constraints to restrict translational motion within a specified range. public struct LinearLimit Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors LinearLimit(float, float) Represents a linear limit defined by a minimum and maximum distance. Used by constraints to restrict translational motion within a specified range. public LinearLimit(float from, float to) Parameters from float The minimum distance of the limit. to float The maximum distance of the limit. Fields Fixed A limit that locks the position in place (no translation allowed). public static readonly LinearLimit Fixed Field Value LinearLimit Full A limit that allows unrestricted movement (negative to positive infinity). public static readonly LinearLimit Full Field Value LinearLimit Properties From Gets or sets the minimum distance of the limit. public float From { readonly get; set; } Property Value float To Gets or sets the maximum distance of the limit. public float To { readonly get; set; } Property Value float Methods Deconstruct(out float, out float) Deconstructs the limit into its minimum and maximum distances. public readonly void Deconstruct(out float limitMin, out float limitMax) Parameters limitMin float The minimum distance. limitMax float The maximum distance. FromMinMax(float, float) Creates a linear limit from minimum and maximum values. public static LinearLimit FromMinMax(float min, float max) Parameters min float The minimum distance. max float The maximum distance. Returns LinearLimit A new LinearLimit instance."
  },
  "api/Jitter2.Dynamics.Constraints.LinearMotor.LinearMotorData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.LinearMotor.LinearMotorData.html",
    "title": "Struct LinearMotor.LinearMotorData | Jitter2",
    "summary": "Struct LinearMotor.LinearMotorData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll public struct LinearMotor.LinearMotorData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public float AccumulatedImpulse Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> EffectiveMass public float EffectiveMass Field Value float Iterate public delegate*<ref ConstraintData, void> Iterate Field Value delegate*<ref ConstraintData, void> LocalAxis1 public JVector LocalAxis1 Field Value JVector LocalAxis2 public JVector LocalAxis2 Field Value JVector MaxForce public float MaxForce Field Value float MaxLambda public float MaxLambda Field Value float PrepareForIteration public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> Velocity public float Velocity Field Value float"
  },
  "api/Jitter2.Dynamics.Constraints.LinearMotor.html": {
    "href": "api/Jitter2.Dynamics.Constraints.LinearMotor.html",
    "title": "Class LinearMotor | Jitter2",
    "summary": "Class LinearMotor Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll A motor constraint that drives relative translational movement along two axes fixed in the reference frames of the bodies. public class LinearMotor : Constraint<LinearMotor.LinearMotorData>, IDebugDrawable Inheritance object Constraint Constraint<LinearMotor.LinearMotorData> LinearMotor Implements IDebugDrawable Inherited Members Constraint<LinearMotor.LinearMotorData>.Data Constraint<LinearMotor.LinearMotorData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Impulse Gets the accumulated impulse applied by this motor during the last step. public float Impulse { get; } Property Value float LocalAxis1 Gets or sets the motor axis on the first body in local space. public JVector LocalAxis1 { get; set; } Property Value JVector LocalAxis2 Gets or sets the motor axis on the second body in local space. public JVector LocalAxis2 { get; set; } Property Value JVector MaximumForce Gets or sets the maximum force the motor can apply. public float MaximumForce { get; set; } Property Value float Default is 0. Must be non-negative. Exceptions ArgumentOutOfRangeException Thrown when value is negative. TargetVelocity Gets or sets the target linear velocity in units per second. public float TargetVelocity { get; set; } Property Value float Default is 0. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() DebugDraw(IDebugDrawer) Draws a debug visualization of this constraint. public override void DebugDraw(IDebugDrawer drawer) Parameters drawer IDebugDrawer The debug drawer to receive visualization primitives. Exceptions NotImplementedException Thrown if the derived class does not override this method. Initialize(JVector, JVector) Initializes the motor with axes for each body. public void Initialize(JVector axis1, JVector axis2) Parameters axis1 JVector Motor axis on the first body in world space. axis2 JVector Motor axis on the second body in world space. Remarks Stores the axes in local frames. Both axes are normalized internally. Default values: TargetVelocity = 0, MaximumForce = 0. IterateLinearMotor(ref ConstraintData, float) public static void IterateLinearMotor(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float PrepareForIterationLinearMotor(ref ConstraintData, float) public static void PrepareForIterationLinearMotor(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float"
  },
  "api/Jitter2.Dynamics.Constraints.PointOnLine.PointOnLineData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.PointOnLine.PointOnLineData.html",
    "title": "Struct PointOnLine.PointOnLineData | Jitter2",
    "summary": "Struct PointOnLine.PointOnLineData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll public struct PointOnLine.PointOnLineData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public JVector AccumulatedImpulse Field Value JVector Bias public JVector Bias Field Value JVector BiasFactor public float BiasFactor Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Clamp public ushort Clamp Field Value ushort EffectiveMass public JMatrix EffectiveMass Field Value JMatrix Iterate public delegate*<ref ConstraintData, void> Iterate Field Value delegate*<ref ConstraintData, void> LimitBias public float LimitBias Field Value float LimitSoftness public float LimitSoftness Field Value float LocalAnchor1 public JVector LocalAnchor1 Field Value JVector LocalAnchor2 public JVector LocalAnchor2 Field Value JVector LocalAxis public JVector LocalAxis Field Value JVector Max public float Max Field Value float Min public float Min Field Value float PrepareForIteration public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> Softness public float Softness Field Value float"
  },
  "api/Jitter2.Dynamics.Constraints.PointOnLine.html": {
    "href": "api/Jitter2.Dynamics.Constraints.PointOnLine.html",
    "title": "Class PointOnLine | Jitter2",
    "summary": "Class PointOnLine Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Constrains a fixed point in the reference frame of one body to a line that is fixed in the reference frame of another body. This constraint removes one degree of translational freedom; two if the limit is enforced. public class PointOnLine : Constraint<PointOnLine.PointOnLineData>, IDebugDrawable Inheritance object Constraint Constraint<PointOnLine.PointOnLineData> PointOnLine Implements IDebugDrawable Inherited Members Constraint<PointOnLine.PointOnLineData>.Data Constraint<PointOnLine.PointOnLineData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled Constraint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Bias Gets or sets the bias factor controlling how aggressively positional error is corrected. public float Bias { get; set; } Property Value float Default is 0.01. Range [0, 1]. Higher values correct errors faster but may cause instability. Distance Gets the current distance of the anchor point from the line origin along the axis. public float Distance { get; } Property Value float Impulse Gets the accumulated impulse applied by this constraint during the last step. public JVector Impulse { get; } Property Value JVector LimitBias Gets or sets the bias factor for distance limit correction. public float LimitBias { get; set; } Property Value float Default is 0.2. Range [0, 1]. Higher values correct limit violations faster. LimitSoftness Gets or sets the softness (compliance) applied when distance limits are active. public float LimitSoftness { get; set; } Property Value float Default is 0.0001. Higher values allow more limit violation but improve stability. Softness Gets or sets the softness (compliance) of the constraint. public float Softness { get; set; } Property Value float Default is 0.00001. Higher values allow more positional error but improve stability. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() Initialize(JVector, JVector, JVector) Initializes the constraint from world-space parameters. public void Initialize(JVector axis, JVector anchor1, JVector anchor2) Parameters axis JVector The line axis in world space, fixed in the reference frame of body 1. anchor1 JVector Anchor point on body 1 defining the line origin in world space. anchor2 JVector Anchor point on body 2 constrained to the line in world space. Remarks Computes local anchor points and axis from the current body poses. Default values: Bias = 0.01, Softness = 0.00001, LimitSoftness = 0.0001, LimitBias = 0.2. Initialize(JVector, JVector, JVector, LinearLimit) Initializes the constraint from world-space parameters. public void Initialize(JVector axis, JVector anchor1, JVector anchor2, LinearLimit limit) Parameters axis JVector The line axis in world space, fixed in the reference frame of body 1. anchor1 JVector Anchor point on body 1 defining the line origin in world space. anchor2 JVector Anchor point on body 2 constrained to the line in world space. limit LinearLimit Distance limit along the axis. Remarks Computes local anchor points and axis from the current body poses. Default values: Bias = 0.01, Softness = 0.00001, LimitSoftness = 0.0001, LimitBias = 0.2. IteratePointOnLine(ref ConstraintData, float) public static void IteratePointOnLine(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float PrepareForIterationPointOnLine(ref ConstraintData, float) public static void PrepareForIterationPointOnLine(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float"
  },
  "api/Jitter2.Dynamics.Constraints.PointOnPlane.SliderData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.PointOnPlane.SliderData.html",
    "title": "Struct PointOnPlane.SliderData | Jitter2",
    "summary": "Struct PointOnPlane.SliderData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll public struct PointOnPlane.SliderData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public float AccumulatedImpulse Field Value float Bias public float Bias Field Value float BiasFactor public float BiasFactor Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Clamp public ushort Clamp Field Value ushort EffectiveMass public float EffectiveMass Field Value float Iterate public delegate*<ref ConstraintData, void> Iterate Field Value delegate*<ref ConstraintData, void> J0 public MemoryHelper.MemBlock12Real J0 Field Value MemoryHelper.MemBlock12Real LocalAnchor1 public JVector LocalAnchor1 Field Value JVector LocalAnchor2 public JVector LocalAnchor2 Field Value JVector LocalAxis public JVector LocalAxis Field Value JVector Max public float Max Field Value float Min public float Min Field Value float PrepareForIteration public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> Softness public float Softness Field Value float"
  },
  "api/Jitter2.Dynamics.Constraints.PointOnPlane.html": {
    "href": "api/Jitter2.Dynamics.Constraints.PointOnPlane.html",
    "title": "Class PointOnPlane | Jitter2",
    "summary": "Class PointOnPlane Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Constrains a fixed point in the reference frame of one body to a plane that is fixed in the reference frame of another body. This constraint removes one degree of translational freedom if the limit is enforced. public class PointOnPlane : Constraint<PointOnPlane.SliderData>, IDebugDrawable Inheritance object Constraint Constraint<PointOnPlane.SliderData> PointOnPlane Implements IDebugDrawable Inherited Members Constraint<PointOnPlane.SliderData>.Data Constraint<PointOnPlane.SliderData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled Constraint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Bias Gets or sets the bias factor controlling how aggressively positional error is corrected. public float Bias { get; set; } Property Value float Default is 0.01. Range [0, 1]. Higher values correct errors faster but may cause instability. Impulse Gets the accumulated impulse applied by this constraint during the last step. public float Impulse { get; } Property Value float Softness Gets or sets the softness (compliance) of the constraint. public float Softness { get; set; } Property Value float Default is 0.00001. Higher values allow more positional error but improve stability. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() Initialize(JVector, JVector, JVector) Initializes the constraint from world-space parameters. public void Initialize(JVector axis, JVector anchor1, JVector anchor2) Parameters axis JVector The plane normal in world space, fixed in the reference frame of body 1. anchor1 JVector Anchor point on body 1 defining the plane origin in world space. anchor2 JVector Anchor point on body 2 constrained to the plane in world space. Remarks Computes local anchor points and axis from the current body poses. Default values: Bias = 0.01, Softness = 0.00001. Initialize(JVector, JVector, JVector, LinearLimit) Initializes the constraint from world-space parameters. public void Initialize(JVector axis, JVector anchor1, JVector anchor2, LinearLimit limit) Parameters axis JVector The plane normal in world space, fixed in the reference frame of body 1. anchor1 JVector Anchor point on body 1 defining the plane origin in world space. anchor2 JVector Anchor point on body 2 constrained to the plane in world space. limit LinearLimit Distance limit from the plane. Remarks Computes local anchor points and axis from the current body poses. Default values: Bias = 0.01, Softness = 0.00001. IteratePointOnPlane(ref ConstraintData, float) public static void IteratePointOnPlane(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float PrepareForIterationPointOnPlane(ref ConstraintData, float) public static void PrepareForIterationPointOnPlane(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float"
  },
  "api/Jitter2.Dynamics.Constraints.PrismaticJoint.html": {
    "href": "api/Jitter2.Dynamics.Constraints.PrismaticJoint.html",
    "title": "Class PrismaticJoint | Jitter2",
    "summary": "Class PrismaticJoint Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Constructs a prismatic joint utilizing a PointOnLine constraint in conjunction with FixedAngle, HingeAngle, and LinearMotor constraints. public class PrismaticJoint : Joint, IDebugDrawable Inheritance object Joint PrismaticJoint Implements IDebugDrawable Inherited Members Joint.Constraints Joint.Register(Constraint) Joint.Deregister(Constraint) Joint.Enable() Joint.Disable() Joint.Remove() Joint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PrismaticJoint(World, RigidBody, RigidBody, JVector, JVector, LinearLimit, bool, bool) public PrismaticJoint(World world, RigidBody body1, RigidBody body2, JVector center, JVector axis, LinearLimit limit, bool pinned = true, bool hasMotor = false) Parameters world World body1 RigidBody body2 RigidBody center JVector axis JVector limit LinearLimit pinned bool hasMotor bool PrismaticJoint(World, RigidBody, RigidBody, JVector, JVector, bool, bool) public PrismaticJoint(World world, RigidBody body1, RigidBody body2, JVector center, JVector axis, bool pinned = true, bool hasMotor = false) Parameters world World body1 RigidBody body2 RigidBody center JVector axis JVector pinned bool hasMotor bool Properties Body1 public RigidBody Body1 { get; } Property Value RigidBody Body2 public RigidBody Body2 { get; } Property Value RigidBody FixedAngle public FixedAngle? FixedAngle { get; } Property Value FixedAngle HingeAngle public HingeAngle? HingeAngle { get; } Property Value HingeAngle Motor public LinearMotor? Motor { get; } Property Value LinearMotor Slider public PointOnLine Slider { get; } Property Value PointOnLine"
  },
  "api/Jitter2.Dynamics.Constraints.SmallConstraintData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.SmallConstraintData.html",
    "title": "Struct SmallConstraintData | Jitter2",
    "summary": "Struct SmallConstraintData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Low-level data for constraints that fit within ConstraintSizeSmall bytes. public struct SmallConstraintData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This structure is stored in unmanaged memory and accessed via SmallHandle. It contains function pointers for the solver and handles to the connected bodies. The data is valid only while the constraint is registered with the world. Do not cache references across simulation steps. Not safe to access concurrently with Step(float, bool). Fields Body1 Handle to the first body's simulation data. public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 Handle to the second body's simulation data. public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Iterate Function pointer to the constraint's iteration solver. public delegate*<ref SmallConstraintData, float, void> Iterate Field Value delegate*<ref SmallConstraintData, float, void> PrepareForIteration Function pointer to the constraint's pre-iteration setup. public delegate*<ref SmallConstraintData, float, void> PrepareForIteration Field Value delegate*<ref SmallConstraintData, float, void>"
  },
  "api/Jitter2.Dynamics.Constraints.TwistAngle.TwistLimitData.html": {
    "href": "api/Jitter2.Dynamics.Constraints.TwistAngle.TwistLimitData.html",
    "title": "Struct TwistAngle.TwistLimitData | Jitter2",
    "summary": "Struct TwistAngle.TwistLimitData Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll public struct TwistAngle.TwistLimitData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public float AccumulatedImpulse Field Value float Angle1 public float Angle1 Field Value float Angle2 public float Angle2 Field Value float B public JVector B Field Value JVector Bias public float Bias Field Value float BiasFactor public float BiasFactor Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Clamp public ushort Clamp Field Value ushort EffectiveMass public float EffectiveMass Field Value float Iterate public delegate*<ref ConstraintData, void> Iterate Field Value delegate*<ref ConstraintData, void> Jacobian public JVector Jacobian Field Value JVector PrepareForIteration public delegate*<ref ConstraintData, float, void> PrepareForIteration Field Value delegate*<ref ConstraintData, float, void> Q0 public JQuaternion Q0 Field Value JQuaternion Softness public float Softness Field Value float"
  },
  "api/Jitter2.Dynamics.Constraints.TwistAngle.html": {
    "href": "api/Jitter2.Dynamics.Constraints.TwistAngle.html",
    "title": "Class TwistAngle | Jitter2",
    "summary": "Class TwistAngle Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Constrains the relative twist of two bodies. This constraint removes one angular degree of freedom when the limit is enforced. public class TwistAngle : Constraint<TwistAngle.TwistLimitData>, IDebugDrawable Inheritance object Constraint Constraint<TwistAngle.TwistLimitData> TwistAngle Implements IDebugDrawable Inherited Members Constraint<TwistAngle.TwistLimitData>.Data Constraint<TwistAngle.TwistLimitData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Angle Gets the current twist angle relative to the initial pose. public JAngle Angle { get; } Property Value JAngle Bias Gets or sets the bias factor controlling how aggressively angular error is corrected. public float Bias { get; set; } Property Value float Default is 0.2. Range [0, 1]. Higher values correct errors faster but may cause instability. Impulse Gets the accumulated impulse applied by this constraint during the last step. public float Impulse { get; } Property Value float Limit Sets the angular limits for the twist rotation. public AngularLimit Limit { set; } Property Value AngularLimit Softness Gets or sets the softness (compliance) of the constraint. public float Softness { get; set; } Property Value float Default is 0.0001. Higher values allow more angular error but improve stability. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() DebugDraw(IDebugDrawer) Draws a debug visualization of this constraint. public override void DebugDraw(IDebugDrawer drawer) Parameters drawer IDebugDrawer The debug drawer to receive visualization primitives. Exceptions NotImplementedException Thrown if the derived class does not override this method. Initialize(JVector, JVector) Initializes the constraint with a fixed twist angle (no rotation allowed). public void Initialize(JVector axis1, JVector axis2) Parameters axis1 JVector The twist axis for body 1 in world space. axis2 JVector The twist axis for body 2 in world space. Initialize(JVector, JVector, AngularLimit) Initializes the constraint from world-space axes and angular limits. public void Initialize(JVector axis1, JVector axis2, AngularLimit limit) Parameters axis1 JVector The twist axis for body 1 in world space. axis2 JVector The twist axis for body 2 in world space. limit AngularLimit The allowed relative twist angle range. Remarks Stores each axis in the local frame of its body and records the initial relative orientation. Default values: Softness = 0.0001, Bias = 0.2. IterateTwistAngle(ref ConstraintData, float) public static void IterateTwistAngle(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float PrepareForIterationTwistAngle(ref ConstraintData, float) public static void PrepareForIterationTwistAngle(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData idt float"
  },
  "api/Jitter2.Dynamics.Constraints.UniversalJoint.html": {
    "href": "api/Jitter2.Dynamics.Constraints.UniversalJoint.html",
    "title": "Class UniversalJoint | Jitter2",
    "summary": "Class UniversalJoint Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Creates a universal joint utilizing a TwistAngle, BallSocket, and an optional AngularMotor constraint. public class UniversalJoint : Joint, IDebugDrawable Inheritance object Joint UniversalJoint Implements IDebugDrawable Inherited Members Joint.Constraints Joint.Register(Constraint) Joint.Deregister(Constraint) Joint.Enable() Joint.Disable() Joint.Remove() Joint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors UniversalJoint(World, RigidBody, RigidBody, JVector, JVector, JVector, bool) public UniversalJoint(World world, RigidBody body1, RigidBody body2, JVector center, JVector rotateAxis1, JVector rotateAxis2, bool hasMotor = false) Parameters world World body1 RigidBody body2 RigidBody center JVector rotateAxis1 JVector rotateAxis2 JVector hasMotor bool Properties BallSocket public BallSocket BallSocket { get; } Property Value BallSocket Body1 public RigidBody Body1 { get; } Property Value RigidBody Body2 public RigidBody Body2 { get; } Property Value RigidBody Motor public AngularMotor? Motor { get; } Property Value AngularMotor TwistAngle public TwistAngle TwistAngle { get; } Property Value TwistAngle"
  },
  "api/Jitter2.Dynamics.Constraints.WeldJoint.html": {
    "href": "api/Jitter2.Dynamics.Constraints.WeldJoint.html",
    "title": "Class WeldJoint | Jitter2",
    "summary": "Class WeldJoint Namespace Jitter2.Dynamics.Constraints Assembly Jitter2.dll Creates a rigid weld joint between two bodies using a FixedAngle constraint for orientation locking and a BallSocket constraint for positional locking. This effectively removes all relative motion between the connected bodies. public class WeldJoint : Joint, IDebugDrawable Inheritance object Joint WeldJoint Implements IDebugDrawable Inherited Members Joint.Constraints Joint.Register(Constraint) Joint.Deregister(Constraint) Joint.Enable() Joint.Disable() Joint.Remove() Joint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors WeldJoint(World, RigidBody, RigidBody, JVector) public WeldJoint(World world, RigidBody body1, RigidBody body2, JVector center) Parameters world World body1 RigidBody body2 RigidBody center JVector Properties BallSocket public BallSocket BallSocket { get; } Property Value BallSocket Body1 public RigidBody Body1 { get; } Property Value RigidBody Body2 public RigidBody Body2 { get; } Property Value RigidBody FixedAngle public FixedAngle FixedAngle { get; } Property Value FixedAngle"
  },
  "api/Jitter2.Dynamics.Constraints.html": {
    "href": "api/Jitter2.Dynamics.Constraints.html",
    "title": "Namespace Jitter2.Dynamics.Constraints | Jitter2",
    "summary": "Namespace Jitter2.Dynamics.Constraints Classes AngularMotor Represents a motor that drives relative angular velocity between two axes fixed in the reference frames of their respective bodies. BallSocket Implements a ball-and-socket joint that anchors a point on each body together, removing three translational degrees of freedom. ConeLimit Limits the relative tilt between two bodies, removing one angular degree of freedom when active. Constraint Base class for constraints that connect two rigid bodies and restrict their relative motion. Constraint<T> Generic base class for constraints that store custom data of type T. DistanceLimit Constrains the distance between a fixed point in the reference frame of one body and a fixed point in the reference frame of another body. This constraint removes one translational degree of freedom. For a distance of zero, use the BallSocket constraint. FixedAngle Constrains the relative orientation between two bodies, eliminating three degrees of rotational freedom. HingeAngle Constrains two bodies to rotate relative to each other around a single axis, removing two angular degrees of freedom. Optionally enforces angular limits. HingeJoint Constructs a hinge joint utilizing a HingeAngle, a BallSocket, and an optional AngularMotor. Joint Base class for joints, which are composite constraints built from multiple Constraint instances. LinearMotor A motor constraint that drives relative translational movement along two axes fixed in the reference frames of the bodies. PointOnLine Constrains a fixed point in the reference frame of one body to a line that is fixed in the reference frame of another body. This constraint removes one degree of translational freedom; two if the limit is enforced. PointOnPlane Constrains a fixed point in the reference frame of one body to a plane that is fixed in the reference frame of another body. This constraint removes one degree of translational freedom if the limit is enforced. PrismaticJoint Constructs a prismatic joint utilizing a PointOnLine constraint in conjunction with FixedAngle, HingeAngle, and LinearMotor constraints. TwistAngle Constrains the relative twist of two bodies. This constraint removes one angular degree of freedom when the limit is enforced. UniversalJoint Creates a universal joint utilizing a TwistAngle, BallSocket, and an optional AngularMotor constraint. WeldJoint Creates a rigid weld joint between two bodies using a FixedAngle constraint for orientation locking and a BallSocket constraint for positional locking. This effectively removes all relative motion between the connected bodies. Structs AngularLimit Represents an angular limit defined by a minimum and maximum angle. Used by constraints to restrict rotational motion within a specified range. AngularMotor.AngularMotorData BallSocket.BallSocketData ConeLimit.ConeLimitData ConstraintData Low-level data for constraints, stored in unmanaged memory. DistanceLimit.DistanceLimitData FixedAngle.FixedAngleData HingeAngle.HingeAngleData LinearLimit Represents a linear limit defined by a minimum and maximum distance. Used by constraints to restrict translational motion within a specified range. LinearMotor.LinearMotorData PointOnLine.PointOnLineData PointOnPlane.SliderData SmallConstraintData Low-level data for constraints that fit within ConstraintSizeSmall bytes. TwistAngle.TwistLimitData"
  },
  "api/Jitter2.Dynamics.ContactData.Contact.Flags.html": {
    "href": "api/Jitter2.Dynamics.ContactData.Contact.Flags.html",
    "title": "Enum ContactData.Contact.Flags | Jitter2",
    "summary": "Enum ContactData.Contact.Flags Namespace Jitter2.Dynamics Assembly Jitter2.dll Flags indicating contact state. [Flags] public enum ContactData.Contact.Flags Fields NewContact = 2 Indicates this contact was created in the current step."
  },
  "api/Jitter2.Dynamics.ContactData.Contact.html": {
    "href": "api/Jitter2.Dynamics.ContactData.Contact.html",
    "title": "Struct ContactData.Contact | Jitter2",
    "summary": "Struct ContactData.Contact Namespace Jitter2.Dynamics Assembly Jitter2.dll Represents a single contact point between two rigid bodies. public struct ContactData.Contact Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This structure is layout-sensitive and stored in unmanaged memory as part of a ContactData. It contains geometric information (normal, tangents, positions) and solver state (accumulated impulses, bias). Do not cache or store references to this structure across simulation steps. Fields AllowedPenetration Penetration depth below which no position correction is applied. public const float AllowedPenetration = 0.01 Field Value float Bias Velocity bias for restitution (bounce). public float Bias Field Value float BiasFactor Fraction of penetration corrected per step (Baumgarte stabilization). public const float BiasFactor = 0.2 Field Value float BreakThreshold Separation distance beyond which a contact is considered broken. public const float BreakThreshold = 0.02 Field Value float Flag Current contact state flags. public ContactData.Contact.Flags Flag Field Value ContactData.Contact.Flags MaximumBias Maximum position-correction bias applied per iteration. public const float MaximumBias = 100 Field Value float PenaltyBias Position-correction bias computed from penetration depth. public float PenaltyBias Field Value float RelativePosition1 Position of the contact relative to the center of mass on the first body. [ReferenceFrame(ReferenceFrame.World)] public JVector RelativePosition1 Field Value JVector RelativePosition2 Position of the contact relative to the center of mass on the second body. [ReferenceFrame(ReferenceFrame.World)] public JVector RelativePosition2 Field Value JVector Properties Impulse The impulse applied in the normal direction which has been used to solve the contact. public readonly float Impulse { get; } Property Value float Normal Normal direction (normalized) of the contact. Pointing from the collision point on the surface of Body2 to the collision point on the surface of Body1. [ReferenceFrame(ReferenceFrame.World)] public readonly JVector Normal { get; } Property Value JVector Tangent1 Tangent (normalized) to the contact Normal in the direction of the relative movement of both bodies, at the time when the contact is created. [ReferenceFrame(ReferenceFrame.World)] public readonly JVector Tangent1 { get; } Property Value JVector Tangent2 A second tangent forming an orthonormal basis with Normal and Tangent1. [ReferenceFrame(ReferenceFrame.World)] public readonly JVector Tangent2 { get; } Property Value JVector TangentImpulse1 The impulse applied in the first tangent direction which has been used to solve the contact. public readonly float TangentImpulse1 { get; } Property Value float TangentImpulse2 The impulse applied in the second tangent direction which has been used to solve the contact. public readonly float TangentImpulse2 { get; } Property Value float Methods Initialize(ref RigidBodyData, ref RigidBodyData, in JVector, in JVector, in JVector, bool, float) public void Initialize(ref RigidBodyData b1, ref RigidBodyData b2, in JVector point1, in JVector point2, in JVector n, bool newContact, float restitution) Parameters b1 RigidBodyData b2 RigidBodyData point1 JVector point2 JVector n JVector newContact bool restitution float Iterate(ContactData*, bool) public void Iterate(ContactData* cd, bool applyBias) Parameters cd ContactData* applyBias bool IterateAccelerated(ContactData*, bool) public void IterateAccelerated(ContactData* cd, bool applyBias) Parameters cd ContactData* applyBias bool PrepareForIteration(ContactData*, float) public void PrepareForIteration(ContactData* cd, float idt) Parameters cd ContactData* idt float PrepareForIterationAccelerated(ContactData*, float) public void PrepareForIterationAccelerated(ContactData* cd, float idt) Parameters cd ContactData* idt float UpdatePosition(ContactData*) public readonly bool UpdatePosition(ContactData* cd) Parameters cd ContactData* Returns bool"
  },
  "api/Jitter2.Dynamics.ContactData.SolveMode.html": {
    "href": "api/Jitter2.Dynamics.ContactData.SolveMode.html",
    "title": "Enum ContactData.SolveMode | Jitter2",
    "summary": "Enum ContactData.SolveMode Namespace Jitter2.Dynamics Assembly Jitter2.dll Specifies which velocity components the solver should update for each body. [Flags] public enum ContactData.SolveMode Fields Angular = AngularBody1 | AngularBody2 Update angular velocities of both bodies. AngularBody1 = 2 Update angular velocity of body 1. AngularBody2 = 8 Update angular velocity of body 2. Full = FullBody1 | FullBody2 Update all velocity components of both bodies. FullBody1 = LinearBody1 | AngularBody1 Update both linear and angular velocity of body 1. FullBody2 = LinearBody2 | AngularBody2 Update both linear and angular velocity of body 2. Linear = LinearBody1 | LinearBody2 Update linear velocities of both bodies. LinearBody1 = 1 Update linear velocity of body 1. LinearBody2 = 4 Update linear velocity of body 2. None = 0 No velocity updates."
  },
  "api/Jitter2.Dynamics.ContactData.html": {
    "href": "api/Jitter2.Dynamics.ContactData.html",
    "title": "Struct ContactData | Jitter2",
    "summary": "Struct ContactData Namespace Jitter2.Dynamics Assembly Jitter2.dll Holds up to four ContactData.Contact structs for a single shape-to-shape collision. public struct ContactData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This structure is stored in unmanaged memory and accessed via Handle. The UsageMask bitfield indicates which of the four contact slots are active. The returned data is valid only while the associated arbiter exists and must not be accessed concurrently with Step(float, bool). Do not cache references to this structure. Fields Body1 Handle to the first body's simulation data. public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 Handle to the second body's simulation data. public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Contact0 First contact point. public ContactData.Contact Contact0 Field Value ContactData.Contact Contact1 Second contact point. public ContactData.Contact Contact1 Field Value ContactData.Contact Contact2 Third contact point. public ContactData.Contact Contact2 Field Value ContactData.Contact Contact3 Fourth contact point. public ContactData.Contact Contact3 Field Value ContactData.Contact Friction Combined friction coefficient for this contact pair. public float Friction Field Value float Key Unique key identifying this arbiter's shape pair. public ArbiterKey Key Field Value ArbiterKey MaskContact0 Bit mask for contact slot 0. public const uint MaskContact0 = 1 Field Value uint MaskContact1 Bit mask for contact slot 1. public const uint MaskContact1 = 2 Field Value uint MaskContact2 Bit mask for contact slot 2. public const uint MaskContact2 = 4 Field Value uint MaskContact3 Bit mask for contact slot 3. public const uint MaskContact3 = 8 Field Value uint MaskContactAll Bit mask indicating all four contact slots are in use. public const uint MaskContactAll = 15 Field Value uint Mode Determines which velocity components are updated by the solver. public ContactData.SolveMode Mode Field Value ContactData.SolveMode Restitution Combined restitution coefficient for this contact pair. public float Restitution Field Value float SpeculativeRelaxationFactor Relaxation factor for speculative contacts. public float SpeculativeRelaxationFactor Field Value float UsageMask The least four significant bits indicate which contacts are considered intact (bit set), broken (bit unset). Bits 5-8 indicate which contacts were intact/broken during the solving-phase. public uint UsageMask Field Value uint Examples A sphere may slide down a ramp. Within one timestep Jitter may detect the collision, create the contact, solve the contact, integrate velocities and positions and then consider the contact as broken, since the movement orthogonal to the contact normal exceeds a threshold. This results in no intact contact before calling Step(float, bool) and no intact contact after the call. However, the corresponding bit for the solver-phase will be set in this scenario. Properties IsHardwareAccelerated Gets a value indicating whether the current system supports hardware acceleration for SIMD (Single Instruction, Multiple Data) operations. public static bool IsHardwareAccelerated { get; } Property Value bool Methods AddContact(in JVector, in JVector, in JVector) Adds a new collision result to the contact manifold. Keeps at most four points. public void AddContact(in JVector point1, in JVector point2, in JVector normal) Parameters point1 JVector Contact point on the first body in world space. point2 JVector Contact point on the second body in world space. normal JVector Contact normal pointing from body 2 to body 1. Init(RigidBody, RigidBody) Initializes this contact data for a pair of rigid bodies. public void Init(RigidBody body1, RigidBody body2) Parameters body1 RigidBody The first rigid body. body2 RigidBody The second rigid body. Iterate(bool) Performs one solver iteration over all active contacts, applying corrective impulses. public void Iterate(bool applyBias) Parameters applyBias bool If true, applies position-correction bias. PrepareForIteration(float) Prepares all active contacts for solver iterations by computing effective masses and warm-starting impulses. public void PrepareForIteration(float idt) Parameters idt float Inverse of the timestep (1/dt). ResetMode(SolveMode) Resets the solve mode based on the current motion types of the bodies, then removes the specified flags. public void ResetMode(ContactData.SolveMode removeFlags = SolveMode.None) Parameters removeFlags ContactData.SolveMode Flags to remove from the full solve mode. UpdatePosition() Updates contact positions after integration and removes contacts that have separated beyond the break threshold. public void UpdatePosition()"
  },
  "api/Jitter2.Dynamics.MotionType.html": {
    "href": "api/Jitter2.Dynamics.MotionType.html",
    "title": "Enum MotionType | Jitter2",
    "summary": "Enum MotionType Namespace Jitter2.Dynamics Assembly Jitter2.dll Specifies how a rigid body participates in the simulation. public enum MotionType Fields Dynamic = 0 Fully simulated; responds to forces, impulses, contacts and constraints. Kinematic = 1 User-controlled body that is not affected by forces or collisions, but can affect dynamic bodies. Treated as having infinite mass in the solver. May have a non-zero velocity set by user code. Takes part in collision island building. Static = 2 Immovable body (zero velocity) treated as having infinite mass by the solver. The position and orientation may be changed directly by user code, which will update the broadphase and may affect contacts on the next step."
  },
  "api/Jitter2.Dynamics.RigidBody.html": {
    "href": "api/Jitter2.Dynamics.RigidBody.html",
    "title": "Class RigidBody | Jitter2",
    "summary": "Class RigidBody Namespace Jitter2.Dynamics Assembly Jitter2.dll Represents the primary entity in the Jitter physics world. public sealed class RigidBody : IPartitionedSetIndex, IDebugDrawable Inheritance object RigidBody Implements IPartitionedSetIndex IDebugDrawable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Fields RigidBodyId Unique identifier for this rigid body, assigned by the World upon creation. This ID remains stable for the lifetime of the body. public readonly ulong RigidBodyId Field Value ulong Properties AffectedByGravity Gets or sets whether the body is affected by the world's gravity during integration. public bool AffectedByGravity { get; set; } Property Value bool Remarks Only applies when MotionType is Dynamic. Default is true. AngularVelocity Gets or sets the angular velocity of the rigid body in world space. public JVector AngularVelocity { get; set; } Property Value JVector Remarks Measured in radians per second. The vector direction is the rotation axis, and its magnitude is the rotation speed. Setting a non-zero velocity schedules the body for activation on the next step. Exceptions InvalidOperationException Thrown if the body's MotionType is Static. Connections Contains all bodies this body is in contact with or shares a constraint with. public ReadOnlyList<RigidBody> Connections { get; } Property Value ReadOnlyList<RigidBody> Constraints Contains all constraints connected to this body. public ReadOnlyHashSet<Constraint> Constraints { get; } Property Value ReadOnlyHashSet<Constraint> Contacts Contains all contacts in which this body is involved. public ReadOnlyHashSet<Arbiter> Contacts { get; } Property Value ReadOnlyHashSet<Arbiter> Damping Gets or sets the damping factors for linear and angular motion. A damping factor of 0 means the body is not damped, while 1 brings the body to a halt immediately. Damping is applied when calling Step(float, bool). Jitter multiplies the respective velocity each step by 1 minus the damping factor. Note that the values are not scaled by time; a smaller time-step in Step(float, bool) results in increased damping. public (float linear, float angular) Damping { get; set; } Property Value (float angular, float linear) Remarks The damping factors must be within the range [0, 1]. Exceptions ArgumentOutOfRangeException Thrown if either the linear or angular damping value is less than 0 or greater than 1. Data Returns a by-ref view of the unmanaged simulation state for this body. public ref RigidBodyData Data { get; } Property Value RigidBodyData Remarks Due to performance considerations, simulation data (position, velocity, etc.) is stored in a contiguous block of unmanaged memory. This property provides direct access to that data. Usage notes: Prefer using RigidBody properties instead of accessing fields directly. Do not cache the returned reference across simulation steps. Modifying fields directly can break invariants (e.g., world-space inertia) unless you know what you're doing. DeactivationThreshold Gets or sets the deactivation threshold. If the magnitudes of both the angular and linear velocity remain below the specified values for the duration of DeactivationTime, the body is deactivated. The threshold values are given in rad/s and length units/s, respectively. public (float angular, float linear) DeactivationThreshold { get; set; } Property Value (float angular, float linear) Remarks Values must be non-negative. This property stores the squared thresholds internally, so the input values are automatically squared when set. Exceptions ArgumentOutOfRangeException Thrown if either the linear or angular threshold is negative. DeactivationTime Gets or sets the deactivation time. If the magnitudes of both the angular and linear velocity of the rigid body remain below the DeactivationThreshold for the specified time, the body is deactivated. public TimeSpan DeactivationTime { get; set; } Property Value TimeSpan EnableGyroscopicForces Enables the implicit gyroscopictorque solver for this RigidBody. public bool EnableGyroscopicForces { get; set; } Property Value bool true to integrate gyroscopic torque each step; otherwise false (default). Remarks When true, every sub-step performs an extra Newton iteration to solve   (I ) implicitly. The benefit becomes noticeable for bodies with a high inertia anisotropy or very fast spin-rates. Typical examples are long, thin rods, spinning tops, propellers, and other objects whose principal inertias differ by an order of magnitude. In those cases the flag eliminates artificial precession. EnableSpeculativeContacts Gets or sets whether speculative contacts are enabled for this body. public bool EnableSpeculativeContacts { get; set; } Property Value bool Remarks Speculative contacts help prevent tunneling for fast-moving bodies by generating contacts before actual penetration occurs. This may increase contact count and solver cost. Default is false. Force Represents the force to be applied to the body during the next call to Step(float, bool). This value is automatically reset to zero after the call. public JVector Force { get; set; } Property Value JVector Friction Gets or sets the coefficient of friction used for contact resolution. public float Friction { get; set; } Property Value float Remarks The friction coefficient determines the resistance to sliding motion. Values typically range from 0 (no friction) upwards. Higher values represent strong friction or adhesion effects. Default is 0.2. Exceptions ArgumentOutOfRangeException Thrown if the value is negative. Handle Gets the handle to the rigid body data, see Data. public JHandle<RigidBodyData> Handle { get; } Property Value JHandle<RigidBodyData> InverseInertia Gets the inverse inertia tensor in body (local) space. public JMatrix InverseInertia { get; } Property Value JMatrix Remarks For world-space inverse inertia, see InverseInertiaWorld. For non-dynamic bodies, the solver treats inertia as infinite regardless of this value. IsActive Indicates whether the rigid body is active or considered to be in a sleeping state. Use SetActivationState(bool) to alter the activation state. public bool IsActive { get; } Property Value bool IsStatic [Obsolete(\"Use the MotionType property instead.\")] public bool IsStatic { get; set; } Property Value bool Island Gets the collision island associated with this rigid body. public Island Island { get; } Property Value Island Mass Gets the mass of the rigid body. To modify the mass, use SetMassInertia(float) or SetMassInertia(in JMatrix, float, bool). public float Mass { get; } Property Value float Remarks This value is only meaningful for Dynamic bodies. Static and kinematic bodies are treated as having infinite mass by the solver regardless of this value. MotionType Gets or sets how the rigid body participates in the simulation. public MotionType MotionType { get; set; } Property Value MotionType Remarks Changing this property has immediate side effects: Switching to Static zeroes velocities, removes connections, and deactivates the body. Switching from Static rebuilds connections from existing contacts. Dynamic bodies use their mass and inertia; static and kinematic bodies are treated as having infinite mass by the solver. Exceptions ArgumentOutOfRangeException Thrown if the value is not a valid MotionType. Orientation Gets or sets the world-space orientation of the rigid body. public JQuaternion Orientation { get; set; } Property Value JQuaternion Remarks Setting this property updates the broadphase proxies for all attached shapes and schedules the body for activation on the next step. Position Gets or sets the world-space position of the rigid body. public JVector Position { get; set; } Property Value JVector Remarks Setting this property updates the broadphase proxies for all attached shapes and schedules the body for activation on the next step. Restitution Gets or sets the restitution (bounciness) of this object. public float Restitution { get; set; } Property Value float Remarks The restitution value determines how much energy is retained after a collision, with 0 representing an inelastic collision (no bounce) and 1 representing a perfectly elastic collision (full bounce). Values between 0 and 1 create a partially elastic collision effect. Default is 0.0. Exceptions ArgumentOutOfRangeException Thrown if the value is not between 0 and 1. Shapes Gets the list of shapes added to this rigid body. public ReadOnlyList<RigidBodyShape> Shapes { get; } Property Value ReadOnlyList<RigidBodyShape> Tag A managed pointer to custom user data. This is not utilized by the engine. public object? Tag { get; set; } Property Value object Torque Represents the torque to be applied to the body during the next call to Step(float, bool). This value is automatically reset to zero after the call. public JVector Torque { get; set; } Property Value JVector Velocity Gets or sets the linear velocity of the rigid body in world space. public JVector Velocity { get; set; } Property Value JVector Remarks Measured in units per second. Setting a non-zero velocity schedules the body for activation on the next step. Exceptions InvalidOperationException Thrown if the body's MotionType is Static. World Gets or sets the world assigned to this body. public World World { get; } Property Value World Methods AddForce(in JVector, in JVector, bool) Applies a force to the rigid body, altering its velocity. This force is applied for a single frame only and is reset to zero with the following call to Step(float, bool). [ReferenceFrame(ReferenceFrame.World)] public void AddForce(in JVector force, in JVector position, bool wakeup = true) Parameters force JVector The force to be applied. position JVector The position where the force will be applied. wakeup bool If true (default), the body will be activated if it is currently sleeping. If false, the force is only applied if the body is already active; sleeping bodies will remain asleep and ignore the force. AddForce(in JVector, bool) Applies a force to the rigid body, thereby altering its velocity. public void AddForce(in JVector force, bool wakeup = true) Parameters force JVector The force to be applied. This force is effective for a single frame only and is reset to zero during the next call to Step(float, bool). wakeup bool If true (default), the body will be activated if it is currently sleeping. If false, the force is only applied if the body is already active; sleeping bodies will remain asleep and ignore the force. AddShape(RigidBodyShape, bool) Adds a shape to the body. public void AddShape(RigidBodyShape shape, bool setMassInertia = true) Parameters shape RigidBodyShape The shape to be added. setMassInertia bool If true, utilizes the shape's mass properties to determine the body's mass properties, assuming a unit density for the shape. If false, the inertia and mass remain unchanged. Exceptions ArgumentException Thrown if the shape is already registered elsewhere. AddShape(IEnumerable<RigidBodyShape>, bool) Adds several shapes to the rigid body at once. Mass properties are recalculated only once, if requested. public void AddShape(IEnumerable<RigidBodyShape> shapes, bool setMassInertia = true) Parameters shapes IEnumerable<RigidBodyShape> The shapes to add. setMassInertia bool If true, uses the mass properties of the shapes to determine the body's mass properties, assuming unit density for the shapes. If false, the inertia and mass remain unchanged. Exceptions ArgumentException Thrown if any shape is already attached to a body. ClearShapes(bool) Removes all shapes associated with the rigid body. [Obsolete(\"ClearShapes is deprecated, please use RemoveShape instead.\")] public void ClearShapes(bool setMassInertia = true) Parameters setMassInertia bool If set to false, the mass properties of the rigid body remain unchanged. Remarks This operation has a time complexity of O(n), where n is the number of shapes attached to the body. DebugDraw(IDebugDrawer) Generates a rough triangle approximation of the shapes of the body. Since the generation is slow this should only be used for debugging purposes. public void DebugDraw(IDebugDrawer drawer) Parameters drawer IDebugDrawer The debug drawer to receive the generated triangles. Remarks This method tessellates all attached shapes and is not suitable for real-time use. It uses a shared static list internally and is not thread-safe. PredictOrientation(float) Predicts the orientation of the body after a given time step using angular velocity. This does not simulate forces or collisions  it assumes constant angular velocity. public JQuaternion PredictOrientation(float dt) Parameters dt float The time step to extrapolate forward. Returns JQuaternion The predicted orientation after dt. PredictPose(float, out JVector, out JQuaternion) Predicts the pose (position and orientation) of the body after a given time step using simple extrapolation. This method is intended for rendering purposes and does not modify the simulation state. public void PredictPose(float dt, out JVector position, out JQuaternion orientation) Parameters dt float The time step to extrapolate forward. position JVector The predicted position after dt. orientation JQuaternion The predicted orientation after dt. PredictPosition(float) Predicts the position of the body after a given time step using linear extrapolation. This does not simulate forces or collisions  it assumes constant velocity. public JVector PredictPosition(float dt) Parameters dt float The time step to extrapolate forward. Returns JVector The predicted position after dt. RemoveShape(RigidBodyShape, bool) Removes a specified shape from the rigid body. public void RemoveShape(RigidBodyShape shape, bool setMassInertia = true) Parameters shape RigidBodyShape The shape to remove from the rigid body. setMassInertia bool Specifies whether to adjust the mass inertia properties of the rigid body after removing the shape. The default value is true. Remarks This operation has a time complexity of O(n), where n is the number of shapes attached to the body. Exceptions ArgumentException Thrown if the specified shape is not part of this rigid body. RemoveShape(IEnumerable<RigidBodyShape>, bool) Removes several shapes from the body. public void RemoveShape(IEnumerable<RigidBodyShape> shapes, bool setMassInertia = true) Parameters shapes IEnumerable<RigidBodyShape> The shapes to remove from the rigid body. setMassInertia bool Specifies whether to adjust the mass inertia properties of the rigid body after removal. The default value is true. Remarks This operation has a time complexity of O(n), where n is the number of shapes attached to the body. Exceptions ArgumentException Thrown if at least one shape is not part of this rigid body. SetActivationState(bool) Instructs the engine to activate or deactivate the body at the beginning of the next time step. The current state does not change immediately. public void SetActivationState(bool active) Parameters active bool If true, the body will be activated; if false, deactivated. SetMassInertia() Computes the mass and inertia of this body from all attached shapes, assuming unit density. public void SetMassInertia() Remarks The mass contributions of all shapes are summed. If no shapes are attached, the body is assigned a mass of 1 and an identity inertia tensor. Exceptions InvalidOperationException Thrown if the computed inertia matrix is not invertible. This may occur if a shape has invalid mass properties. SetMassInertia(in JMatrix, float, bool) Sets the new mass properties of this body by specifying both inertia and mass directly. public void SetMassInertia(in JMatrix inertia, float mass, bool setAsInverse = false) Parameters inertia JMatrix The inertia tensor (or inverse inertia tensor if setAsInverse is true) in body (local) space, about the center of mass. mass float The mass (or inverse mass if setAsInverse is true). When setting inverse mass, a value of zero represents infinite mass. setAsInverse bool If true, inertia and mass are interpreted as inverse values. Exceptions ArgumentException Thrown if: mass is zero or negative when setAsInverse is false. mass is negative or infinite when setAsInverse is true. inertia is not invertible when setAsInverse is false. SetMassInertia(float) Computes the inertia from all attached shapes, then uniformly scales it to match the specified mass. public void SetMassInertia(float mass) Parameters mass float The desired total mass of the body. Must be positive. Remarks This is equivalent to calling SetMassInertia() and then scaling the resulting inertia tensor so the body has the desired total mass. Use this when you want shape-derived inertia proportions but a specific total mass (e.g., for gameplay tuning). Exceptions ArgumentException Thrown if the specified mass is zero or negative. Events BeginCollide Event triggered when a new arbiter is created, indicating that two bodies have begun colliding. [CallbackThread(ThreadContext.MainThread)] public event Action<Arbiter>? BeginCollide Event Type Action<Arbiter> Remarks This event provides an Arbiter object which contains details about the collision. Use this event to handle logic that should occur at the start of a collision between two bodies. EndCollide Event triggered when an arbiter is destroyed, indicating that two bodies have stopped colliding. The reference to this arbiter becomes invalid after this call. [CallbackThread(ThreadContext.MainThread)] public event Action<Arbiter>? EndCollide Event Type Action<Arbiter> Remarks This event provides an Arbiter object which contains details about the collision that has ended. Use this event to handle logic that should occur when the collision between two bodies ends."
  },
  "api/Jitter2.Dynamics.RigidBodyData.html": {
    "href": "api/Jitter2.Dynamics.RigidBodyData.html",
    "title": "Struct RigidBodyData | Jitter2",
    "summary": "Struct RigidBodyData Namespace Jitter2.Dynamics Assembly Jitter2.dll Low-level simulation state for a RigidBody, stored in unmanaged memory. public struct RigidBodyData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This structure is layout-sensitive and intended for internal engine use. Prefer using RigidBody properties instead of accessing fields directly. All spatial values (position, velocity, orientation, inertia) are in world space. The Flags field is a bitfield: bits 01 encode MotionType, bit 2 indicates active state, and bit 3 enables gyroscopic forces. Fields AngularVelocity Angular velocity in world space, measured in radians per second. The vector direction is the rotation axis, and its magnitude is the rotation speed. public JVector AngularVelocity Field Value JVector DeltaAngularVelocity Accumulated angular velocity change for the current substep (from torques). Internal use only. public JVector DeltaAngularVelocity Field Value JVector DeltaVelocity Accumulated linear velocity change for the current substep (from forces and gravity). Internal use only. public JVector DeltaVelocity Field Value JVector Flags Bitfield encoding motion type (bits 01), active state (bit 2), and gyroscopic forces (bit 3). Use the corresponding properties instead of manipulating this directly. public int Flags Field Value int InverseInertiaWorld Inverse inertia tensor in world space. For dynamic bodies, this is recomputed each step from the body-space inverse inertia and current orientation. For static and kinematic bodies, this is zero (representing infinite inertia). public JMatrix InverseInertiaWorld Field Value JMatrix InverseMass Inverse mass of the body. A value of zero represents infinite mass (used for static and kinematic bodies in the solver). public float InverseMass Field Value float Orientation World-space orientation of the rigid body. public JQuaternion Orientation Field Value JQuaternion Position World-space position of the rigid body (center of mass). public JVector Position Field Value JVector Velocity Linear velocity in world space, measured in units per second. public JVector Velocity Field Value JVector _index Internal index used by the engine for handle management. Not stable across frames. public int _index Field Value int _lockFlag Internal synchronization flag used by the engine. Do not modify. public int _lockFlag Field Value int Properties EnableGyroscopicForces Gets or sets whether the implicit gyroscopic torque solver is enabled. See EnableGyroscopicForces for details. public bool EnableGyroscopicForces { readonly get; set; } Property Value bool IsActive Gets or sets whether the body is active (awake) and participating in simulation. Inactive bodies are considered sleeping and skip integration until reactivated. public bool IsActive { readonly get; set; } Property Value bool IsStaticOrInactive Returns true if the body is static or currently inactive (sleeping). [Obsolete(\"Use MotionType directly.\")] public bool IsStaticOrInactive { get; } Property Value bool MotionType Gets or sets how this body participates in the simulation. Encoded in bits 01 of Flags. public MotionType MotionType { get; set; } Property Value MotionType"
  },
  "api/Jitter2.Dynamics.html": {
    "href": "api/Jitter2.Dynamics.html",
    "title": "Namespace Jitter2.Dynamics | Jitter2",
    "summary": "Namespace Jitter2.Dynamics Classes Arbiter Manages contact information between two different rigid bodies. RigidBody Represents the primary entity in the Jitter physics world. Structs ArbiterKey Represents an ordered pair of identifiers used to look up an Arbiter. ContactData Holds up to four ContactData.Contact structs for a single shape-to-shape collision. ContactData.Contact Represents a single contact point between two rigid bodies. RigidBodyData Low-level simulation state for a RigidBody, stored in unmanaged memory. Enums ContactData.Contact.Flags Flags indicating contact state. ContactData.SolveMode Specifies which velocity components the solver should update for each body. MotionType Specifies how a rigid body participates in the simulation."
  },
  "api/Jitter2.IDebugDrawable.html": {
    "href": "api/Jitter2.IDebugDrawable.html",
    "title": "Interface IDebugDrawable | Jitter2",
    "summary": "Interface IDebugDrawable Namespace Jitter2 Assembly Jitter2.dll Defines an interface for objects that can be debug-drawn. public interface IDebugDrawable Methods DebugDraw(IDebugDrawer) Passes an IDebugDrawer to draw basic debug information for the object. void DebugDraw(IDebugDrawer drawer) Parameters drawer IDebugDrawer The debug drawer used for rendering debug information."
  },
  "api/Jitter2.IDebugDrawer.html": {
    "href": "api/Jitter2.IDebugDrawer.html",
    "title": "Interface IDebugDrawer | Jitter2",
    "summary": "Interface IDebugDrawer Namespace Jitter2 Assembly Jitter2.dll Defines an interface for drawing debug visualization elements. public interface IDebugDrawer Methods DrawPoint(in JVector) Draws a point at the specified position. void DrawPoint(in JVector p) Parameters p JVector The position of the point. DrawSegment(in JVector, in JVector) Draws a line segment between two points. void DrawSegment(in JVector pA, in JVector pB) Parameters pA JVector The start point of the segment. pB JVector The end point of the segment. DrawTriangle(in JVector, in JVector, in JVector) Draws a triangle defined by three vertices. void DrawTriangle(in JVector pA, in JVector pB, in JVector pC) Parameters pA JVector The first vertex of the triangle. pB JVector The second vertex of the triangle. pC JVector The third vertex of the triangle."
  },
  "api/Jitter2.LinearMath.JAngle.html": {
    "href": "api/Jitter2.LinearMath.JAngle.html",
    "title": "Struct JAngle | Jitter2",
    "summary": "Struct JAngle Namespace Jitter2.LinearMath Assembly Jitter2.dll A floating point variable of type float representing an angle. This structure exists to eliminate ambiguity between radians and degrees in the Jitter API. public struct JAngle : IEquatable<JAngle> Implements IEquatable<JAngle> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Degree Gets or sets the angle value in degrees. public float Degree { readonly get; set; } Property Value float Radian Gets or sets the angle value in radians. public float Radian { readonly get; set; } Property Value float Methods Equals(JAngle) Indicates whether the current object is equal to another object of the same type. public readonly bool Equals(JAngle p) Parameters p JAngle Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override readonly bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. FromDegree(float) Creates a JAngle from a value in degrees. public static JAngle FromDegree(float deg) Parameters deg float Returns JAngle FromRadian(float) Creates a JAngle from a value in radians. public static JAngle FromRadian(float rad) Parameters rad float Returns JAngle GetHashCode() Returns the hash code for this instance. public override readonly int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. ToString() Returns a string representation of the JAngle. public override readonly string ToString() Returns string Operators operator +(JAngle, JAngle) public static JAngle operator +(JAngle a, JAngle b) Parameters a JAngle b JAngle Returns JAngle operator ==(JAngle, JAngle) public static bool operator ==(JAngle l, JAngle r) Parameters l JAngle r JAngle Returns bool explicit operator float(JAngle) public static explicit operator float(JAngle angle) Parameters angle JAngle Returns float explicit operator JAngle(float) public static explicit operator JAngle(float angle) Parameters angle float Returns JAngle operator >(JAngle, JAngle) public static bool operator >(JAngle l, JAngle r) Parameters l JAngle r JAngle Returns bool operator >=(JAngle, JAngle) public static bool operator >=(JAngle l, JAngle r) Parameters l JAngle r JAngle Returns bool operator !=(JAngle, JAngle) public static bool operator !=(JAngle l, JAngle r) Parameters l JAngle r JAngle Returns bool operator <(JAngle, JAngle) public static bool operator <(JAngle l, JAngle r) Parameters l JAngle r JAngle Returns bool operator <=(JAngle, JAngle) public static bool operator <=(JAngle l, JAngle r) Parameters l JAngle r JAngle Returns bool operator -(JAngle, JAngle) public static JAngle operator -(JAngle a, JAngle b) Parameters a JAngle b JAngle Returns JAngle operator -(JAngle) public static JAngle operator -(JAngle a) Parameters a JAngle Returns JAngle"
  },
  "api/Jitter2.LinearMath.JBoundingBox.ContainmentType.html": {
    "href": "api/Jitter2.LinearMath.JBoundingBox.ContainmentType.html",
    "title": "Enum JBoundingBox.ContainmentType | Jitter2",
    "summary": "Enum JBoundingBox.ContainmentType Namespace Jitter2.LinearMath Assembly Jitter2.dll Describes how one bounding box relates to another spatially. public enum JBoundingBox.ContainmentType Fields Contains = 1 The other box is completely inside this box. Disjoint = 0 The two boxes are completely separated and do not touch or overlap. Intersects = 2 The boxes overlap, but neither completely contains the other."
  },
  "api/Jitter2.LinearMath.JBoundingBox.html": {
    "href": "api/Jitter2.LinearMath.JBoundingBox.html",
    "title": "Struct JBoundingBox | Jitter2",
    "summary": "Struct JBoundingBox Namespace Jitter2.LinearMath Assembly Jitter2.dll Represents an axis-aligned bounding box (AABB), a rectangular bounding box whose edges are parallel to the coordinate axes. public struct JBoundingBox : IEquatable<JBoundingBox> Implements IEquatable<JBoundingBox> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors JBoundingBox(JVector, JVector) Represents an axis-aligned bounding box (AABB), a rectangular bounding box whose edges are parallel to the coordinate axes. public JBoundingBox(JVector min, JVector max) Parameters min JVector max JVector Fields Epsilon public const float Epsilon = 1E-12 Field Value float LargeBox A bounding box covering the entire valid range of coordinates. public static readonly JBoundingBox LargeBox Field Value JBoundingBox Max The maximum corner of the bounding box (largest X, Y, Z coordinates). public JVector Max Field Value JVector Min The minimum corner of the bounding box (smallest X, Y, Z coordinates). public JVector Min Field Value JVector SmallBox An inverted bounding box initialized with Min > Max, useful for growing a box from scratch. public static readonly JBoundingBox SmallBox Field Value JBoundingBox Properties Center Gets the center point of the bounding box. public readonly JVector Center { get; } Property Value JVector Methods AddPoint(in JVector) [Obsolete(\"Use static AddPointInPlace instead.\")] public void AddPoint(in JVector point) Parameters point JVector AddPointInPlace(ref JBoundingBox, in JVector) Expands the bounding box to include the specified point. public static void AddPointInPlace(ref JBoundingBox box, in JVector point) Parameters box JBoundingBox The bounding box to expand. point JVector The point to include. Contains(in JBoundingBox) Determines the relationship between this box and another box. public readonly JBoundingBox.ContainmentType Contains(in JBoundingBox box) Parameters box JBoundingBox The other bounding box to test. Returns JBoundingBox.ContainmentType Disjoint if they do not touch. Contains if box is strictly inside this box. Intersects if they overlap but one does not strictly contain the other. Contains(in JBoundingBox, in JBoundingBox) Determines whether the outer box completely contains the inner box. public static bool Contains(in JBoundingBox outer, in JBoundingBox inner) Parameters outer JBoundingBox The outer bounding box. inner JBoundingBox The inner bounding box to test. Returns bool true if inner is entirely within the boundaries of outer; otherwise, false. Contains(in JVector) Determines whether the bounding box contains the specified point. public readonly bool Contains(in JVector point) Parameters point JVector Returns bool CreateFromPoints(IEnumerable<JVector>) Creates a bounding box that exactly encompasses a collection of points. public static JBoundingBox CreateFromPoints(IEnumerable<JVector> points) Parameters points IEnumerable<JVector> The collection of points to encompass. Returns JBoundingBox A bounding box containing all the points. CreateMerged(in JBoundingBox, in JBoundingBox) Creates a new bounding box that is the union of two other bounding boxes. public static JBoundingBox CreateMerged(in JBoundingBox original, in JBoundingBox additional) Parameters original JBoundingBox The first bounding box. additional JBoundingBox The second bounding box. Returns JBoundingBox A bounding box encompassing both inputs. CreateMerged(in JBoundingBox, in JBoundingBox, out JBoundingBox) Creates a new bounding box that is the union of two other bounding boxes. public static void CreateMerged(in JBoundingBox original, in JBoundingBox additional, out JBoundingBox result) Parameters original JBoundingBox The first bounding box. additional JBoundingBox The second bounding box. result JBoundingBox Output: A bounding box encompassing both inputs. CreateTransformed(in JBoundingBox, in JMatrix) Creates a new AABB that encloses the original box after it has been rotated by the given orientation matrix. public static JBoundingBox CreateTransformed(in JBoundingBox box, in JMatrix orientation) Parameters box JBoundingBox The original bounding box. orientation JMatrix The rotation matrix to apply. Returns JBoundingBox A new AABB enclosing the rotated box. Remarks Rotating an AABB usually results in a larger AABB to fit the rotated geometry. Disjoint(in JBoundingBox, in JBoundingBox) Determines whether the two boxes are completely separated (disjoint). public static bool Disjoint(in JBoundingBox left, in JBoundingBox right) Parameters left JBoundingBox The first bounding box. right JBoundingBox The second bounding box. Returns bool true if there is a gap between the boxes on at least one axis; otherwise, false. Encompasses(in JBoundingBox, in JBoundingBox) Determines whether the outer box completely contains the inner box. [Obsolete(\"Use Contains instead.\")] public static bool Encompasses(in JBoundingBox outer, in JBoundingBox inner) Parameters outer JBoundingBox inner JBoundingBox Returns bool Remarks This is an alias for Contains(in JBoundingBox, in JBoundingBox). Equals(JBoundingBox) Indicates whether the current object is equal to another object of the same type. public readonly bool Equals(JBoundingBox other) Parameters other JBoundingBox An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override readonly bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetCorners(Span<JVector>) Retrieves the 8 corners of the bounding box. public readonly void GetCorners(Span<JVector> destination) Parameters destination Span<JVector> A span of at least 8 JVectors to hold the corners. GetHashCode() Returns the hash code for this instance. public override readonly int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. GetSurfaceArea() Calculates the surface area of the bounding box. public readonly float GetSurfaceArea() Returns float GetVolume() Calculates the volume of the bounding box. public readonly float GetVolume() Returns float NotDisjoint(in JBoundingBox, in JBoundingBox) Determines whether the two boxes intersect or overlap. [Obsolete(\"Use !Disjoint instead.\")] public static bool NotDisjoint(in JBoundingBox left, in JBoundingBox right) Parameters left JBoundingBox right JBoundingBox Returns bool true if the boxes overlap; false if they are disjoint. RayIntersect(in JVector, in JVector) Checks if an infinite ray intersects this bounding box. public readonly bool RayIntersect(in JVector origin, in JVector direction) Parameters origin JVector The origin of the ray. direction JVector The direction of the ray (not necessarily normalized). Returns bool true if the ray intersects the box; otherwise, false. RayIntersect(in JVector, in JVector, out float) Checks if an infinite ray intersects this bounding box and calculates the entry distance. public readonly bool RayIntersect(in JVector origin, in JVector direction, out float enter) Parameters origin JVector The origin of the ray. direction JVector The direction of the ray (not necessarily normalized). enter float Outputs the distance along the direction vector where the ray enters the box. Returns 0 if the origin is inside. Returns bool true if the ray intersects the box; otherwise, false. SegmentIntersect(in JVector, in JVector) Checks if a finite line segment intersects this bounding box. public readonly bool SegmentIntersect(in JVector origin, in JVector direction) Parameters origin JVector The start point of the segment. direction JVector The vector from start to end (End = Origin + Direction). Returns bool true if the segment passes through the box; otherwise, false. ToString() Returns a string representation of the JBoundingBox. public override readonly string ToString() Returns string Transform(in JMatrix) [Obsolete(\"Use static CreateTransformed instead.\")] public void Transform(in JMatrix orientation) Parameters orientation JMatrix Operators operator ==(JBoundingBox, JBoundingBox) public static bool operator ==(JBoundingBox left, JBoundingBox right) Parameters left JBoundingBox right JBoundingBox Returns bool operator !=(JBoundingBox, JBoundingBox) public static bool operator !=(JBoundingBox left, JBoundingBox right) Parameters left JBoundingBox right JBoundingBox Returns bool"
  },
  "api/Jitter2.LinearMath.JMatrix.html": {
    "href": "api/Jitter2.LinearMath.JMatrix.html",
    "title": "Struct JMatrix | Jitter2",
    "summary": "Struct JMatrix Namespace Jitter2.LinearMath Assembly Jitter2.dll Represents a 3x3 matrix with components of type float. public struct JMatrix : IEquatable<JMatrix> Implements IEquatable<JMatrix> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors JMatrix(float, float, float, float, float, float, float, float, float) Represents a 3x3 matrix with components of type float. public JMatrix(float m11, float m12, float m13, float m21, float m22, float m23, float m31, float m32, float m33) Parameters m11 float m12 float m13 float m21 float m22 float m23 float m31 float m32 float m33 float Fields Identity The identity matrix. public static readonly JMatrix Identity Field Value JMatrix M11 public float M11 Field Value float M12 public float M12 Field Value float M13 public float M13 Field Value float M21 public float M21 Field Value float M22 public float M22 Field Value float M23 public float M23 Field Value float M31 public float M31 Field Value float M32 public float M32 Field Value float M33 public float M33 Field Value float Zero The zero matrix. public static readonly JMatrix Zero Field Value JMatrix Methods Absolute(in JMatrix, out JMatrix) Creates a matrix where each component is the absolute value of the input matrix component. public static void Absolute(in JMatrix matrix, out JMatrix result) Parameters matrix JMatrix The input matrix. result JMatrix Output: The absolute matrix. Add(JMatrix, JMatrix) Adds two matrices. public static JMatrix Add(JMatrix matrix1, JMatrix matrix2) Parameters matrix1 JMatrix The first matrix. matrix2 JMatrix The second matrix. Returns JMatrix The sum of the two matrices. Add(in JMatrix, in JMatrix, out JMatrix) Adds two matrices component-wise. public static void Add(in JMatrix matrix1, in JMatrix matrix2, out JMatrix result) Parameters matrix1 JMatrix The first matrix. matrix2 JMatrix The second matrix. result JMatrix Output: The sum of the two matrices. CreateCrossProduct(in JVector) Creates a skew-symmetric matrix from a vector, representing the cross product operation. public static JMatrix CreateCrossProduct(in JVector vec) Parameters vec JVector The vector. Returns JMatrix The skew-symmetric matrix. Remarks Result is equivalent to: [ 0 -z y ] [ z 0 -x ] [ -y x 0 ] CreateFromQuaternion(JQuaternion) Creates a rotation matrix from a quaternion. public static JMatrix CreateFromQuaternion(JQuaternion quaternion) Parameters quaternion JQuaternion The quaternion representing the rotation. Returns JMatrix The rotation matrix. CreateFromQuaternion(in JQuaternion, out JMatrix) Creates a rotation matrix from a quaternion. public static void CreateFromQuaternion(in JQuaternion quaternion, out JMatrix result) Parameters quaternion JQuaternion The quaternion representing the rotation. result JMatrix Output: The rotation matrix. CreateRotationMatrix(JVector, float) Creates a rotation matrix from an axis and an angle. public static JMatrix CreateRotationMatrix(JVector axis, float angle) Parameters axis JVector The axis to rotate around. angle float The angle of rotation in radians. Returns JMatrix The rotation matrix. CreateRotationX(float) Creates a rotation matrix around the X-axis. public static JMatrix CreateRotationX(float radians) Parameters radians float The angle of rotation in radians. Returns JMatrix The rotation matrix. CreateRotationY(float) Creates a rotation matrix around the Y-axis. public static JMatrix CreateRotationY(float radians) Parameters radians float The angle of rotation in radians. Returns JMatrix The rotation matrix. CreateRotationZ(float) Creates a rotation matrix around the Z-axis. public static JMatrix CreateRotationZ(float radians) Parameters radians float The angle of rotation in radians. Returns JMatrix The rotation matrix. CreateScale(in JVector) Creates a scaling matrix. public static JMatrix CreateScale(in JVector scale) Parameters scale JVector The scaling vector. Returns JMatrix The scaling matrix. CreateScale(float, float, float) Creates a scaling matrix. public static JMatrix CreateScale(float x, float y, float z) Parameters x float Scaling factor on the X-axis. y float Scaling factor on the Y-axis. z float Scaling factor on the Z-axis. Returns JMatrix The scaling matrix. Determinant() Calculates the determinant of the matrix. public readonly float Determinant() Returns float The determinant. Equals(JMatrix) Indicates whether the current object is equal to another object of the same type. public readonly bool Equals(JMatrix other) Parameters other JMatrix An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override readonly bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. FromColumns(in JVector, in JVector, in JVector) Creates a matrix from three column vectors. public static JMatrix FromColumns(in JVector col1, in JVector col2, in JVector col3) Parameters col1 JVector The first column vector. col2 JVector The second column vector. col3 JVector The third column vector. Returns JMatrix GetColumn(int) Gets a column vector by index. public JVector GetColumn(int index) Parameters index int The zero-based index of the column (0, 1, or 2). Returns JVector GetHashCode() Returns the hash code for this instance. public override readonly int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. Inverse(in JMatrix, out JMatrix) Calculates the inverse of the matrix. public static bool Inverse(in JMatrix matrix, out JMatrix result) Parameters matrix JMatrix The matrix to invert. result JMatrix Output: The inverted matrix, or a zero matrix if the determinant is zero. Returns bool true if the matrix can be inverted; otherwise, false. Multiply(JMatrix, float) Multiplies a matrix by a scalar factor. public static JMatrix Multiply(JMatrix matrix1, float scaleFactor) Parameters matrix1 JMatrix The matrix. scaleFactor float The scalar factor. Returns JMatrix The scaled matrix. Multiply(in JMatrix, in JMatrix) Multiplies two matrices. public static JMatrix Multiply(in JMatrix matrix1, in JMatrix matrix2) Parameters matrix1 JMatrix The first matrix. matrix2 JMatrix The second matrix. Returns JMatrix The product of the two matrices. Multiply(in JMatrix, in JMatrix, out JMatrix) Multiplies two matrices. public static void Multiply(in JMatrix matrix1, in JMatrix matrix2, out JMatrix result) Parameters matrix1 JMatrix The first matrix. matrix2 JMatrix The second matrix. result JMatrix Output: The product of the two matrices. Multiply(in JMatrix, float, out JMatrix) Multiplies a matrix by a scalar factor. public static void Multiply(in JMatrix matrix1, float scaleFactor, out JMatrix result) Parameters matrix1 JMatrix The matrix. scaleFactor float The scalar factor. result JMatrix Output: The scaled matrix. MultiplyTransposed(in JMatrix, in JMatrix) Calculates matrix1 * transpose(matrix2). public static JMatrix MultiplyTransposed(in JMatrix matrix1, in JMatrix matrix2) Parameters matrix1 JMatrix The first matrix. matrix2 JMatrix The second matrix (which will be transposed during multiplication). Returns JMatrix The result of the multiplication. MultiplyTransposed(in JMatrix, in JMatrix, out JMatrix) Calculates matrix1 * matrix2 (multiplying matrix1 by the transpose of matrix2). public static void MultiplyTransposed(in JMatrix matrix1, in JMatrix matrix2, out JMatrix result) Parameters matrix1 JMatrix The first matrix. matrix2 JMatrix The second matrix (transposed during operation). result JMatrix Output: The result of the multiplication. Subtract(in JMatrix, in JMatrix, out JMatrix) Subtracts the second matrix from the first component-wise. public static void Subtract(in JMatrix matrix1, in JMatrix matrix2, out JMatrix result) Parameters matrix1 JMatrix The first matrix. matrix2 JMatrix The second matrix. result JMatrix Output: The difference of the two matrices. ToString() Returns the fully qualified type name of this instance. public override readonly string ToString() Returns string The fully qualified type name. Trace() Calculates the trace (sum of diagonal elements) of the matrix. public readonly float Trace() Returns float The trace of the matrix. Transpose(in JMatrix) Transposes a matrix. public static JMatrix Transpose(in JMatrix matrix) Parameters matrix JMatrix The matrix to transpose. Returns JMatrix The transposed matrix. TransposedMultiply(in JMatrix, in JMatrix) Calculates transpose(matrix1) * matrix2. public static JMatrix TransposedMultiply(in JMatrix matrix1, in JMatrix matrix2) Parameters matrix1 JMatrix The first matrix (which will be transposed during multiplication). matrix2 JMatrix The second matrix. Returns JMatrix The result of the multiplication. TransposedMultiply(in JMatrix, in JMatrix, out JMatrix) Calculates matrix1 * matrix2 (multiplying the transpose of matrix1 by matrix2). public static void TransposedMultiply(in JMatrix matrix1, in JMatrix matrix2, out JMatrix result) Parameters matrix1 JMatrix The first matrix (transposed during operation). matrix2 JMatrix The second matrix. result JMatrix Output: The result of the multiplication. UnsafeGet(int) Gets a reference to a column vector by index using unsafe pointer arithmetic. public ref JVector UnsafeGet(int index) Parameters index int The zero-based index of the column (0, 1, or 2). Returns JVector Operators operator +(in JMatrix, in JMatrix) Adds two matrices. public static JMatrix operator +(in JMatrix value1, in JMatrix value2) Parameters value1 JMatrix value2 JMatrix Returns JMatrix operator ==(JMatrix, JMatrix) public static bool operator ==(JMatrix left, JMatrix right) Parameters left JMatrix right JMatrix Returns bool operator !=(JMatrix, JMatrix) public static bool operator !=(JMatrix left, JMatrix right) Parameters left JMatrix right JMatrix Returns bool operator *(in JMatrix, in JMatrix) Multiplies two matrices. public static JMatrix operator *(in JMatrix matrix1, in JMatrix matrix2) Parameters matrix1 JMatrix matrix2 JMatrix Returns JMatrix operator *(in JMatrix, float) Scales a matrix by a factor. public static JMatrix operator *(in JMatrix matrix, float factor) Parameters matrix JMatrix factor float Returns JMatrix operator *(float, in JMatrix) Scales a matrix by a factor. public static JMatrix operator *(float factor, in JMatrix matrix) Parameters factor float matrix JMatrix Returns JMatrix operator -(in JMatrix, in JMatrix) Subtracts the second matrix from the first. public static JMatrix operator -(in JMatrix value1, in JMatrix value2) Parameters value1 JMatrix value2 JMatrix Returns JMatrix"
  },
  "api/Jitter2.LinearMath.JQuaternion.html": {
    "href": "api/Jitter2.LinearMath.JQuaternion.html",
    "title": "Struct JQuaternion | Jitter2",
    "summary": "Struct JQuaternion Namespace Jitter2.LinearMath Assembly Jitter2.dll A structure representing a Quaternion: Q = xi + yj + z*k + w. Uses the Hamilton convention where i = j = k = ijk = -1. public struct JQuaternion : IEquatable<JQuaternion> Implements IEquatable<JQuaternion> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors JQuaternion(float, in JVector) Initializes a new instance of the JQuaternion struct. public JQuaternion(float w, in JVector v) Parameters w float The scalar (W) component. v JVector The vector (X, Y, Z) component. JQuaternion(float, float, float, float) A structure representing a Quaternion: Q = xi + yj + z*k + w. Uses the Hamilton convention where i = j = k = ijk = -1. public JQuaternion(float x, float y, float z, float w) Parameters x float y float z float w float Fields W public float W Field Value float X public float X Field Value float Y public float Y Field Value float Z public float Z Field Value float Properties Identity Gets the identity quaternion (0, 0, 0, 1). public static JQuaternion Identity { get; } Property Value JQuaternion Scalar Gets the scalar part (w) of the quaternion. public float Scalar { get; } Property Value float Vector Gets the vector part (x, y, z) of the quaternion. public JVector Vector { get; } Property Value JVector Methods Add(in JQuaternion, in JQuaternion) Adds two quaternions component-wise. public static JQuaternion Add(in JQuaternion quaternion1, in JQuaternion quaternion2) Parameters quaternion1 JQuaternion The first quaternion. quaternion2 JQuaternion The second quaternion. Returns JQuaternion The sum of the two quaternions. Add(in JQuaternion, in JQuaternion, out JQuaternion) Adds two quaternions component-wise. public static void Add(in JQuaternion quaternion1, in JQuaternion quaternion2, out JQuaternion result) Parameters quaternion1 JQuaternion The first quaternion. quaternion2 JQuaternion The second quaternion. result JQuaternion Output: The sum of the two quaternions. Conjugate() Returns the conjugate of the quaternion. public readonly JQuaternion Conjugate() Returns JQuaternion The conjugate of the quaternion. Remarks The conjugate is defined as (-x, -y, -z, w). Conjugate(in JQuaternion) Returns the conjugate of a quaternion. public static JQuaternion Conjugate(in JQuaternion value) Parameters value JQuaternion The quaternion to conjugate. Returns JQuaternion The conjugate of the quaternion. Remarks The conjugate is defined as (-x, -y, -z, w). For unit quaternions, the conjugate is equivalent to the inverse. ConjugateMultiply(in JQuaternion, in JQuaternion) Calculates conjugate(Q1) * Q2. public static JQuaternion ConjugateMultiply(in JQuaternion quaternion1, in JQuaternion quaternion2) Parameters quaternion1 JQuaternion The quaternion to conjugate and then multiply. quaternion2 JQuaternion The second quaternion. Returns JQuaternion ConjugateMultiply(in JQuaternion, in JQuaternion, out JQuaternion) Calculates conjugate(Q1) * Q2. public static void ConjugateMultiply(in JQuaternion quaternion1, in JQuaternion quaternion2, out JQuaternion result) Parameters quaternion1 JQuaternion The quaternion to conjugate and then multiply. quaternion2 JQuaternion The second quaternion. result JQuaternion Output: The resulting quaternion. CreateFromAxisAngle(in JVector, float) Creates a quaternion from a unit axis and an angle. public static JQuaternion CreateFromAxisAngle(in JVector axis, float angle) Parameters axis JVector The unit vector to rotate around (must be normalized). angle float The angle of rotation in radians. Returns JQuaternion A unit quaternion representing the rotation. Remarks The axis must be normalized. CreateFromMatrix(in JMatrix) Creates a quaternion from a rotation matrix. public static JQuaternion CreateFromMatrix(in JMatrix matrix) Parameters matrix JMatrix The rotation matrix. Returns JQuaternion The quaternion representing the rotation. CreateFromMatrix(in JMatrix, out JQuaternion) Creates a quaternion from a rotation matrix. public static void CreateFromMatrix(in JMatrix matrix, out JQuaternion result) Parameters matrix JMatrix The rotation matrix. result JQuaternion Output: The quaternion representing the rotation. CreateFromToRotation(JVector, JVector) Creates a quaternion that rotates the unit vector from into the unit vector to. public static JQuaternion CreateFromToRotation(JVector from, JVector to) Parameters from JVector Source direction (must be unit length). to JVector Target direction (must be unit length). Returns JQuaternion A unit quaternion representing the shortest rotation. Remarks This calculation relies on the half-angle formula. If the vectors are parallel (dot  1), Identity is returned. If the vectors are opposite (dot  -1), a rotation of 180 ( radians) around an arbitrary orthogonal axis is returned. CreateRotationX(float) Creates a quaternion representing a rotation around the X-axis. public static JQuaternion CreateRotationX(float radians) Parameters radians float The angle of rotation in radians. Returns JQuaternion The resulting quaternion. CreateRotationY(float) Creates a quaternion representing a rotation around the Y-axis. public static JQuaternion CreateRotationY(float radians) Parameters radians float The angle of rotation in radians. Returns JQuaternion The resulting quaternion. CreateRotationZ(float) Creates a quaternion representing a rotation around the Z-axis. public static JQuaternion CreateRotationZ(float radians) Parameters radians float The angle of rotation in radians. Returns JQuaternion The resulting quaternion. Dot(in JQuaternion, in JQuaternion) Calculates the dot product of two quaternions. public static float Dot(in JQuaternion quaternion1, in JQuaternion quaternion2) Parameters quaternion1 JQuaternion The first quaternion. quaternion2 JQuaternion The second quaternion. Returns float The dot product. Equals(JQuaternion) Indicates whether the current object is equal to another object of the same type. public readonly bool Equals(JQuaternion other) Parameters other JQuaternion An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override readonly bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetBasisX() Calculates the transformation of the X-axis (1, 0, 0) by this quaternion. public readonly JVector GetBasisX() Returns JVector The transformed vector. Remarks Mathematically equivalent to q  (1,0,0)  q. Result: [1 - 2(y + z), 2(xy + zw), 2(xz - yw)] GetBasisY() Calculates the transformation of the Y-axis (0, 1, 0) by this quaternion. public readonly JVector GetBasisY() Returns JVector The transformed vector. Remarks Mathematically equivalent to q  (0,1,0)  q. Result: [2(xy - zw), 1 - 2(x + z), 2(yz + xw)] GetBasisZ() Calculates the transformation of the Z-axis (0, 0, 1) by this quaternion. public readonly JVector GetBasisZ() Returns JVector The transformed vector. Remarks Mathematically equivalent to q  (0,0,1)  q. Result: [2(xz + yw), 2(yz - xw), 1 - 2(x + y)] GetHashCode() Returns the hash code for this instance. public override readonly int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. Inverse(in JQuaternion) Returns the inverse of a quaternion. public static JQuaternion Inverse(in JQuaternion value) Parameters value JQuaternion Returns JQuaternion Remarks Unlike Conjugate(in JQuaternion), this handles non-unit quaternions correctly by dividing by the squared length. Length() Calculates the Euclidean length of the quaternion. public readonly float Length() Returns float The length (magnitude). LengthSquared() Calculates the squared Euclidean length of the quaternion. public readonly float LengthSquared() Returns float The squared length. Lerp(in JQuaternion, in JQuaternion, float) Linearly interpolates between two quaternions and normalizes the result. public static JQuaternion Lerp(in JQuaternion quaternion1, in JQuaternion quaternion2, float amount) Parameters quaternion1 JQuaternion Source quaternion. quaternion2 JQuaternion Target quaternion. amount float Weight of the interpolation. Returns JQuaternion The interpolated unit quaternion. Multiply(in JQuaternion, in JQuaternion) Multiplies two quaternions (Hamilton Product). public static JQuaternion Multiply(in JQuaternion quaternion1, in JQuaternion quaternion2) Parameters quaternion1 JQuaternion The first quaternion. quaternion2 JQuaternion The second quaternion. Returns JQuaternion The product of the two quaternions. Remarks Non-commutative. Q1 * Q2 represents the rotation Q2 followed by Q1 (local frame) or Q1 followed by Q2 (global frame). Multiply(in JQuaternion, in JQuaternion, out JQuaternion) Multiplies two quaternions. public static void Multiply(in JQuaternion quaternion1, in JQuaternion quaternion2, out JQuaternion result) Parameters quaternion1 JQuaternion The first quaternion. quaternion2 JQuaternion The second quaternion. result JQuaternion Output: The product of the two quaternions. Multiply(in JQuaternion, float) Multiplies a quaternion by a scalar factor. public static JQuaternion Multiply(in JQuaternion quaternion1, float scaleFactor) Parameters quaternion1 JQuaternion The quaternion. scaleFactor float The scalar factor. Returns JQuaternion The scaled quaternion. Multiply(in JQuaternion, float, out JQuaternion) Multiplies a quaternion by a scalar factor. public static void Multiply(in JQuaternion quaternion1, float scaleFactor, out JQuaternion result) Parameters quaternion1 JQuaternion The quaternion. scaleFactor float The scalar factor. result JQuaternion Output: The scaled quaternion. MultiplyConjugate(in JQuaternion, in JQuaternion) Calculates Q1 * conjugate(Q2). public static JQuaternion MultiplyConjugate(in JQuaternion quaternion1, in JQuaternion quaternion2) Parameters quaternion1 JQuaternion The first quaternion. quaternion2 JQuaternion The quaternion to conjugate. Returns JQuaternion MultiplyConjugate(in JQuaternion, in JQuaternion, out JQuaternion) Calculates Q1 * conjugate(Q2). public static void MultiplyConjugate(in JQuaternion quaternion1, in JQuaternion quaternion2, out JQuaternion result) Parameters quaternion1 JQuaternion The first quaternion. quaternion2 JQuaternion The quaternion to conjugate. result JQuaternion Output: The resulting quaternion. Normalize() Normalizes the quaternion to unit length. [Obsolete(\"In-place Normalize() is deprecated; use the static Normalize method or NormalizeInPlace.\")] public void Normalize() Normalize(in JQuaternion) Returns a normalized version of the quaternion. public static JQuaternion Normalize(in JQuaternion value) Parameters value JQuaternion The source quaternion. Returns JQuaternion Normalize(in JQuaternion, out JQuaternion) Returns a normalized version of the quaternion. public static void Normalize(in JQuaternion value, out JQuaternion result) Parameters value JQuaternion The source quaternion. result JQuaternion Output: The normalized unit quaternion. NormalizeInPlace(ref JQuaternion) Normalizes the provided quaternion structure in place. public static void NormalizeInPlace(ref JQuaternion quaternion) Parameters quaternion JQuaternion The quaternion to normalize. Slerp(in JQuaternion, in JQuaternion, float) Interpolates between two quaternions using Spherical Linear Interpolation (SLERP). public static JQuaternion Slerp(in JQuaternion quaternion1, in JQuaternion quaternion2, float amount) Parameters quaternion1 JQuaternion Source quaternion. quaternion2 JQuaternion Target quaternion. amount float Weight of the interpolation. Returns JQuaternion The interpolated quaternion. Subtract(in JQuaternion, in JQuaternion) Subtracts the second quaternion from the first component-wise. public static JQuaternion Subtract(in JQuaternion quaternion1, in JQuaternion quaternion2) Parameters quaternion1 JQuaternion The first quaternion. quaternion2 JQuaternion The second quaternion. Returns JQuaternion The difference of the two quaternions. Subtract(in JQuaternion, in JQuaternion, out JQuaternion) Subtracts the second quaternion from the first component-wise. public static void Subtract(in JQuaternion quaternion1, in JQuaternion quaternion2, out JQuaternion result) Parameters quaternion1 JQuaternion The first quaternion. quaternion2 JQuaternion The second quaternion. result JQuaternion Output: The difference of the two quaternions. ToAxisAngle(JQuaternion, out JVector, out float) Decomposes a unit quaternion into an axis and an angle. public static void ToAxisAngle(JQuaternion quaternion, out JVector axis, out float angle) Parameters quaternion JQuaternion The unit quaternion to decompose. axis JVector Output: The unit rotation axis. angle float Output: The rotation angle (radians). Remarks Assumes quaternion is normalized. Returns the shortest arc (angle in [0, ]). ToString() Returns a string representing the quaternion in the format X=..., Y=..., Z=..., W=.... public override readonly string ToString() Returns string UnsafeAs<T>() Reinterprets the bits of this JQuaternion as T. public T UnsafeAs<T>() where T : unmanaged Returns T The reinterpreted value. Type Parameters T The target unmanaged type. Remarks Valid only if T has identical size and compatible layout. Memory order is X, Y, Z, W (W is last). UnsafeFrom<T>(in T) Reinterprets the bits of value as a JQuaternion. public static JQuaternion UnsafeFrom<T>(in T value) where T : unmanaged Parameters value T The value to reinterpret. Returns JQuaternion The reinterpreted quaternion. Type Parameters T The source unmanaged type. Remarks Valid only if T has identical size and compatible layout. Expects memory order X, Y, Z, W (W is last). Operators operator +(in JQuaternion, in JQuaternion) Adds two quaternions component-wise. public static JQuaternion operator +(in JQuaternion value1, in JQuaternion value2) Parameters value1 JQuaternion value2 JQuaternion Returns JQuaternion operator ==(JQuaternion, JQuaternion) public static bool operator ==(JQuaternion left, JQuaternion right) Parameters left JQuaternion right JQuaternion Returns bool implicit operator Quaternion(in JQuaternion) public static implicit operator Quaternion(in JQuaternion q) Parameters q JQuaternion Returns Quaternion implicit operator JQuaternion(in Quaternion) public static implicit operator JQuaternion(in Quaternion q) Parameters q Quaternion Returns JQuaternion implicit operator JQuaternion((float x, float y, float z, float w)) public static implicit operator JQuaternion((float x, float y, float z, float w) tuple) Parameters tuple (float x, float y, float z, float w) Returns JQuaternion operator !=(JQuaternion, JQuaternion) public static bool operator !=(JQuaternion left, JQuaternion right) Parameters left JQuaternion right JQuaternion Returns bool operator *(in JQuaternion, in JQuaternion) Multiplies two quaternions (Hamilton Product). public static JQuaternion operator *(in JQuaternion value1, in JQuaternion value2) Parameters value1 JQuaternion value2 JQuaternion Returns JQuaternion operator *(in JQuaternion, float) Scales a quaternion by a factor. public static JQuaternion operator *(in JQuaternion value1, float value2) Parameters value1 JQuaternion value2 float Returns JQuaternion operator *(float, in JQuaternion) Scales a quaternion by a factor. public static JQuaternion operator *(float value1, in JQuaternion value2) Parameters value1 float value2 JQuaternion Returns JQuaternion operator -(in JQuaternion, in JQuaternion) Subtracts the second quaternion from the first component-wise. public static JQuaternion operator -(in JQuaternion value1, in JQuaternion value2) Parameters value1 JQuaternion value2 JQuaternion Returns JQuaternion operator -(in JQuaternion) Flips the sign of each component of the quaternion. public static JQuaternion operator -(in JQuaternion value) Parameters value JQuaternion Returns JQuaternion"
  },
  "api/Jitter2.LinearMath.JTriangle.CullMode.html": {
    "href": "api/Jitter2.LinearMath.JTriangle.CullMode.html",
    "title": "Enum JTriangle.CullMode | Jitter2",
    "summary": "Enum JTriangle.CullMode Namespace Jitter2.LinearMath Assembly Jitter2.dll Specifies the face culling mode for triangles based on their winding order. Counter-clockwise (CCW) winding is considered front-facing. public enum JTriangle.CullMode Fields BackFacing = 1 Cull triangles that are back-facing. A triangle is back-facing if its vertices are ordered clockwise (CW). This is the most common culling mode. FrontFacing = 0 Cull triangles that are front-facing. A triangle is front-facing if its vertices are ordered counter-clockwise (CCW). None = 2 Do not perform face culling; both front- and back-facing triangles are processed."
  },
  "api/Jitter2.LinearMath.JTriangle.html": {
    "href": "api/Jitter2.LinearMath.JTriangle.html",
    "title": "Struct JTriangle | Jitter2",
    "summary": "Struct JTriangle Namespace Jitter2.LinearMath Assembly Jitter2.dll Represents a triangle defined by three vertices. public struct JTriangle : IEquatable<JTriangle> Implements IEquatable<JTriangle> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors JTriangle(in JVector, in JVector, in JVector) Represents a triangle defined by three vertices. public JTriangle(in JVector v0, in JVector v1, in JVector v2) Parameters v0 JVector v1 JVector v2 JVector Fields V0 The first vertex of the triangle. public JVector V0 Field Value JVector V1 The second vertex of the triangle. public JVector V1 Field Value JVector V2 The third vertex of the triangle. public JVector V2 Field Value JVector Methods ClosestPoint(JVector) Finds the closest point on the triangle surface to a specified point. public readonly JVector ClosestPoint(JVector point) Parameters point JVector The query point. Returns JVector The point on the triangle closest to the query point. Equals(JTriangle) Indicates whether the current object is equal to another object of the same type. public readonly bool Equals(JTriangle other) Parameters other JTriangle An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override readonly bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetArea() Calculates the area of the triangle. public readonly float GetArea() Returns float GetBoundingBox() Calculates the axis-aligned bounding box (AABB) of this triangle. public readonly JBoundingBox GetBoundingBox() Returns JBoundingBox GetCenter() Calculates the geometric center (centroid) of the triangle. public readonly JVector GetCenter() Returns JVector GetHashCode() Returns the hash code for this instance. public override readonly int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. GetNormal() Calculates the face normal of the triangle. The direction follows the Right-Hand Rule (counter-clockwise winding). public readonly JVector GetNormal() Returns JVector The non-normalized normal vector. RayIntersect(in JVector, in JVector, CullMode, out JVector, out float) Checks if a ray intersects the triangle. public readonly bool RayIntersect(in JVector origin, in JVector direction, JTriangle.CullMode cullMode, out JVector normal, out float lambda) Parameters origin JVector The starting point (origin) of the ray. direction JVector The direction vector of the ray. cullMode JTriangle.CullMode Determines whether to ignore triangles based on their winding order (Front/Back facing). normal JVector Output: The normalized surface normal at the point of intersection. lambda float Output: The distance along the direction vector where the intersection occurs (hit point = origin + lambda * direction). Returns bool true if the ray intersects the triangle; otherwise, false. ToString() Returns a string representation of the JTriangle. public override readonly string ToString() Returns string Operators operator ==(JTriangle, JTriangle) public static bool operator ==(JTriangle left, JTriangle right) Parameters left JTriangle right JTriangle Returns bool operator !=(JTriangle, JTriangle) public static bool operator !=(JTriangle left, JTriangle right) Parameters left JTriangle right JTriangle Returns bool"
  },
  "api/Jitter2.LinearMath.JVector.html": {
    "href": "api/Jitter2.LinearMath.JVector.html",
    "title": "Struct JVector | Jitter2",
    "summary": "Struct JVector Namespace Jitter2.LinearMath Assembly Jitter2.dll Represents a three-dimensional vector with components of type float. public struct JVector : IEquatable<JVector> Implements IEquatable<JVector> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors JVector(float) Creates a vector with all components set to the same value. public JVector(float xyz) Parameters xyz float The value for X, Y, and Z components. JVector(float, float, float) Represents a three-dimensional vector with components of type float. public JVector(float x, float y, float z) Parameters x float y float z float Fields MaxValue A vector with all components set to MaxValue. public static readonly JVector MaxValue Field Value JVector MinValue A vector with all components set to MinValue. public static readonly JVector MinValue Field Value JVector One A vector with all components set to one (1, 1, 1). public static readonly JVector One Field Value JVector UnitX The unit vector along the X-axis (1, 0, 0). public static readonly JVector UnitX Field Value JVector UnitY The unit vector along the Y-axis (0, 1, 0). public static readonly JVector UnitY Field Value JVector UnitZ The unit vector along the Z-axis (0, 0, 1). public static readonly JVector UnitZ Field Value JVector X public float X Field Value float Y public float Y Field Value float Z public float Z Field Value float Zero The zero vector (0, 0, 0). public static readonly JVector Zero Field Value JVector Properties this[int] public float this[int i] { get; set; } Parameters i int Property Value float Methods Abs(in JVector) Returns a vector containing the absolute values of the components of the specified vector. public static JVector Abs(in JVector value1) Parameters value1 JVector The input vector. Returns JVector A vector with absolute values of each component. Add(in JVector, in JVector) Adds two vectors. public static JVector Add(in JVector value1, in JVector value2) Parameters value1 JVector The first vector. value2 JVector The second vector. Returns JVector The sum of the two vectors. Add(in JVector, in JVector, out JVector) Adds two vectors. public static void Add(in JVector value1, in JVector value2, out JVector result) Parameters value1 JVector The first vector. value2 JVector The second vector. result JVector Output: The sum of the two vectors. ConjugatedTransform(in JVector, in JQuaternion) Transforms the vector by the conjugate of a quaternion (inverse rotation for unit quaternions). public static JVector ConjugatedTransform(in JVector vector, in JQuaternion quat) Parameters vector JVector The vector to transform. quat JQuaternion The quaternion (conjugated during operation). Returns JVector The inversely rotated vector. ConjugatedTransform(in JVector, in JQuaternion, out JVector) Transforms the vector by the conjugate of a quaternion (inverse rotation). public static void ConjugatedTransform(in JVector vector, in JQuaternion quaternion, out JVector result) Parameters vector JVector The vector to transform. quaternion JQuaternion The quaternion (conjugated during operation). result JVector Output: The inversely rotated vector. Cross(in JVector, in JVector) Calculates the cross product of two vectors (u  v). public static JVector Cross(in JVector vector1, in JVector vector2) Parameters vector1 JVector The first vector. vector2 JVector The second vector. Returns JVector The cross product. Cross(in JVector, in JVector, out JVector) Calculates the cross product of two vectors (u  v). public static void Cross(in JVector vector1, in JVector vector2, out JVector result) Parameters vector1 JVector The first vector. vector2 JVector The second vector. result JVector Output: The cross product. Dot(in JVector, in JVector) Calculates the dot product of two vectors (u  v). public static float Dot(in JVector vector1, in JVector vector2) Parameters vector1 JVector The first vector. vector2 JVector The second vector. Returns float The dot product. Equals(JVector) Indicates whether the current object is equal to another object of the same type. public readonly bool Equals(JVector other) Parameters other JVector An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override readonly bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override readonly int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. Length() Calculates the length of the vector (v). public readonly float Length() Returns float LengthSquared() Calculates the squared length of the vector (v). public readonly float LengthSquared() Returns float Max(in JVector, in JVector) Returns a vector containing the maximum components of the specified vectors. public static JVector Max(in JVector value1, in JVector value2) Parameters value1 JVector The first vector. value2 JVector The second vector. Returns JVector A vector with the maximum of each component. Max(in JVector, in JVector, out JVector) Returns a vector containing the maximum components of the specified vectors. public static void Max(in JVector value1, in JVector value2, out JVector result) Parameters value1 JVector The first vector. value2 JVector The second vector. result JVector Output: A vector with the maximum of each component. MaxAbs(in JVector) Returns the maximum absolute value among the vector's components. public static float MaxAbs(in JVector value1) Parameters value1 JVector The input vector. Returns float The maximum of |X|, |Y|, and |Z|. Min(in JVector, in JVector) Returns a vector containing the minimum components of the specified vectors. public static JVector Min(in JVector value1, in JVector value2) Parameters value1 JVector The first vector. value2 JVector The second vector. Returns JVector A vector with the minimum of each component. Min(in JVector, in JVector, out JVector) Returns a vector containing the minimum components of the specified vectors. public static void Min(in JVector value1, in JVector value2, out JVector result) Parameters value1 JVector The first vector. value2 JVector The second vector. result JVector Output: A vector with the minimum of each component. Multiply(in JVector, float) Multiplies a vector by a scalar. public static JVector Multiply(in JVector value1, float scaleFactor) Parameters value1 JVector The vector. scaleFactor float The scalar factor. Returns JVector The scaled vector. Multiply(in JVector, float, out JVector) Multiplies a vector by a scalar. public static void Multiply(in JVector value1, float scaleFactor, out JVector result) Parameters value1 JVector The vector. scaleFactor float The scalar factor. result JVector Output: The scaled vector. Negate() [Obsolete(\"Use static NegateInPlace instead.\")] public void Negate() Negate(in JVector) Returns a negated copy of the vector. public static JVector Negate(in JVector value) Parameters value JVector The vector to negate. Returns JVector The negated vector. Negate(in JVector, out JVector) Returns a negated copy of the vector. public static void Negate(in JVector value, out JVector result) Parameters value JVector The vector to negate. result JVector Output: The negated vector. NegateInPlace(ref JVector) Negates the vector in-place. public static void NegateInPlace(ref JVector vector) Parameters vector JVector The vector to negate. Normalize() [Obsolete(\"In-place Normalize() is deprecated; use the static Normalize method or NormalizeInPlace.\")] public void Normalize() Normalize(in JVector) Returns a normalized unit vector. public static JVector Normalize(in JVector value) Parameters value JVector The vector to normalize. Returns JVector The normalized unit vector. Normalize(in JVector, out JVector) Returns a normalized unit vector. public static void Normalize(in JVector value, out JVector result) Parameters value JVector The vector to normalize. result JVector Output: The normalized unit vector. NormalizeInPlace(ref JVector) Normalizes the vector in-place. public static void NormalizeInPlace(ref JVector toNormalize) Parameters toNormalize JVector The vector to normalize. NormalizeSafe(in JVector, float) Normalizes value; returns Zero when its squared-length is below epsilonSquared. public static JVector NormalizeSafe(in JVector value, float epsilonSquared = 1E-16) Parameters value JVector Vector to normalize. epsilonSquared float Cut-off for value; default is 1  10. Returns JVector Unit vector or zero. Outer(in JVector, in JVector) Calculates the outer product (tensor product) of two vectors. public static JMatrix Outer(in JVector u, in JVector v) Parameters u JVector The first vector. v JVector The second vector. Returns JMatrix A 3x3 matrix representing the outer product. Remarks Result is the matrix u * v. Set(float, float, float) [Obsolete(\"Do not use any longer.\")] public void Set(float x, float y, float z) Parameters x float y float z float Subtract(JVector, JVector) Subtracts the second vector from the first. public static JVector Subtract(JVector value1, JVector value2) Parameters value1 JVector The first vector. value2 JVector The second vector. Returns JVector The difference of the two vectors. Subtract(in JVector, in JVector, out JVector) Subtracts the second vector from the first. public static void Subtract(in JVector value1, in JVector value2, out JVector result) Parameters value1 JVector The first vector. value2 JVector The second vector. result JVector Output: The difference of the two vectors. Swap(ref JVector, ref JVector) Swaps the values of two vectors. public static void Swap(ref JVector vector1, ref JVector vector2) Parameters vector1 JVector vector2 JVector ToString() Returns a string representation of the JVector. public override readonly string ToString() Returns string Transform(in JVector, in JMatrix) Calculates matrix * vector (multiplying matrix by column vector). public static JVector Transform(in JVector vector, in JMatrix matrix) Parameters vector JVector The column vector. matrix JMatrix The matrix. Returns JVector The transformed vector. Transform(in JVector, in JMatrix, out JVector) Calculates matrix * vector (multiplying matrix by column vector). public static void Transform(in JVector vector, in JMatrix matrix, out JVector result) Parameters vector JVector The column vector. matrix JMatrix The matrix. result JVector Output: The transformed vector. Transform(in JVector, in JQuaternion) Transforms the vector by a quaternion rotation. public static JVector Transform(in JVector vector, in JQuaternion quat) Parameters vector JVector The vector to transform. quat JQuaternion The quaternion representing the rotation. Returns JVector The rotated vector. Transform(in JVector, in JQuaternion, out JVector) Transforms the vector by a quaternion rotation. public static void Transform(in JVector vector, in JQuaternion quaternion, out JVector result) Parameters vector JVector The vector to transform. quaternion JQuaternion The quaternion representing the rotation. result JVector Output: The rotated vector. TransposedTransform(in JVector, in JMatrix) Calculates matrix * vector (multiplying transposed matrix by column vector). public static JVector TransposedTransform(in JVector vector, in JMatrix matrix) Parameters vector JVector The column vector. matrix JMatrix The matrix (transposed during operation). Returns JVector The transformed vector. TransposedTransform(in JVector, in JMatrix, out JVector) Calculates matrix * vector (multiplying transposed matrix by column vector). public static void TransposedTransform(in JVector vector, in JMatrix matrix, out JVector result) Parameters vector JVector The column vector. matrix JMatrix The matrix (transposed during operation). result JVector Output: The transformed vector. UnsafeAs<T>() Reinterprets the bits of this JVector as T. public T UnsafeAs<T>() where T : unmanaged Returns T The reinterpreted value. Type Parameters T The target unmanaged type. Remarks Valid only if T has identical size and compatible layout. UnsafeFrom<T>(in T) Reinterprets the bits of value as a JVector. public static JVector UnsafeFrom<T>(in T value) where T : unmanaged Parameters value T The value to reinterpret. Returns JVector The reinterpreted vector. Type Parameters T The source unmanaged type. Remarks Valid only if T has identical size and compatible layout. UnsafeGet(int) public ref float UnsafeGet(int index) Parameters index int Returns float Operators operator +(in JVector, in JVector) Adds two vectors. public static JVector operator +(in JVector value1, in JVector value2) Parameters value1 JVector value2 JVector Returns JVector operator ==(JVector, JVector) public static bool operator ==(JVector value1, JVector value2) Parameters value1 JVector value2 JVector Returns bool implicit operator Vector3(in JVector) public static implicit operator Vector3(in JVector v) Parameters v JVector Returns Vector3 implicit operator JVector(in Vector3) public static implicit operator JVector(in Vector3 v) Parameters v Vector3 Returns JVector implicit operator JVector((float x, float y, float z)) public static implicit operator JVector((float x, float y, float z) tuple) Parameters tuple (float x, float y, float z) Returns JVector operator !=(JVector, JVector) public static bool operator !=(JVector value1, JVector value2) Parameters value1 JVector value2 JVector Returns bool operator %(in JVector, in JVector) Calculates the cross product of two vectors (u  v). public static JVector operator %(in JVector vector1, in JVector vector2) Parameters vector1 JVector vector2 JVector Returns JVector operator *(in JVector, in JVector) Calculates the dot product of two vectors (u  v). public static float operator *(in JVector vector1, in JVector vector2) Parameters vector1 JVector vector2 JVector Returns float operator *(in JVector, float) Multiplies a vector by a scalar. public static JVector operator *(in JVector value1, float value2) Parameters value1 JVector value2 float Returns JVector operator *(float, in JVector) Multiplies a vector by a scalar. public static JVector operator *(float value1, in JVector value2) Parameters value1 float value2 JVector Returns JVector operator -(in JVector, in JVector) Subtracts the second vector from the first. public static JVector operator -(in JVector value1, in JVector value2) Parameters value1 JVector value2 JVector Returns JVector operator -(in JVector) Negates the vector. public static JVector operator -(in JVector left) Parameters left JVector Returns JVector operator +(in JVector) Returns the vector itself. public static JVector operator +(in JVector left) Parameters left JVector Returns JVector"
  },
  "api/Jitter2.LinearMath.MathHelper.html": {
    "href": "api/Jitter2.LinearMath.MathHelper.html",
    "title": "Class MathHelper | Jitter2",
    "summary": "Class MathHelper Namespace Jitter2.LinearMath Assembly Jitter2.dll Provides mathematical helper methods for linear algebra and physics calculations. public static class MathHelper Inheritance object MathHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CheckOrthonormalBasis(in JMatrix, float) Verifies whether the columns of the given matrix constitute an orthonormal basis. public static bool CheckOrthonormalBasis(in JMatrix matrix, float epsilon = 1E-06) Parameters matrix JMatrix The input matrix to check. epsilon float The tolerance for floating-point comparisons. Returns bool true if the columns are mutually perpendicular and have unit length; otherwise, false. CloseToZero(in JVector, float) Determines whether the length of the given vector is zero or close to zero. public static bool CloseToZero(in JVector v, float epsilonSq = 1E-16) Parameters v JVector The vector to evaluate. epsilonSq float Threshold for squared magnitude. Returns bool true if the squared length is less than epsilonSq; otherwise, false. CreateOrthonormal(in JVector) Calculates an orthonormal vector to the given vector. public static JVector CreateOrthonormal(in JVector vec) Parameters vec JVector The input vector (must be non-zero, does not need to be normalized). Returns JVector A unit vector orthogonal to the input. Remarks The input vector must be non-zero. Debug builds assert this condition. InverseSquareRoot(JMatrix, int) Calculates (MM)^(-1/2) using Jacobi iterations. public static JMatrix InverseSquareRoot(JMatrix m, int sweeps = 2) Parameters m JMatrix The input matrix. sweeps int The number of Jacobi iterations. Returns JMatrix The inverse square root of MM. IsRotationMatrix(in JMatrix, float) Checks if matrix is a pure rotation matrix. public static bool IsRotationMatrix(in JMatrix matrix, float epsilon = 1E-06) Parameters matrix JMatrix The matrix to check. epsilon float The tolerance for floating-point comparisons. Returns bool true if the matrix is orthonormal with determinant 1; otherwise, false. IsZero(in JVector, float) Checks if all entries of a vector are close to zero. public static bool IsZero(in JVector vector, float epsilon = 1E-06) Parameters vector JVector The vector to check. epsilon float The tolerance for each component. Returns bool true if all components are within epsilon of zero; otherwise, false. IsZero(float, float) Checks if a value is close to zero. public static bool IsZero(float value, float epsilon = 1E-06) Parameters value float The value to check. epsilon float The tolerance. Returns bool true if the absolute value is less than epsilon; otherwise, false. RotationQuaternion(in JVector, float) Calculates the rotation quaternion corresponding to the given (constant) angular velocity vector and time step. public static JQuaternion RotationQuaternion(in JVector omega, float dt) Parameters omega JVector The angular velocity vector in radians per second. dt float The time step in seconds. Returns JQuaternion A unit quaternion representing the rotation. SignBit(double) Gets the sign of value purely from its IEEE-754 sign bit. public static int SignBit(double value) Parameters value double The number to test. Returns int +1 when the sign bit is clear (positive, +0, or a positive-sign NaN), -1 when the sign bit is set (negative, 0, or a negative-sign NaN). Never returns 0, unlike Sign(float). SignBit(float) Gets the sign of value purely from its IEEE-754 sign bit. public static int SignBit(float value) Parameters value float The number to test. Returns int +1 when the sign bit is clear (positive, +0, or a positive-sign NaN), -1 when the sign bit is set (negative, 0, or a negative-sign NaN). Never returns 0, unlike Sign(float). UnsafeIsZero(ref JMatrix, float) Checks if all entries of a matrix are close to zero. public static bool UnsafeIsZero(ref JMatrix matrix, float epsilon = 1E-06) Parameters matrix JMatrix The matrix to check. epsilon float The tolerance for each element. Returns bool true if all elements are within epsilon of zero; otherwise, false."
  },
  "api/Jitter2.LinearMath.html": {
    "href": "api/Jitter2.LinearMath.html",
    "title": "Namespace Jitter2.LinearMath | Jitter2",
    "summary": "Namespace Jitter2.LinearMath Classes MathHelper Provides mathematical helper methods for linear algebra and physics calculations. Structs JAngle A floating point variable of type float representing an angle. This structure exists to eliminate ambiguity between radians and degrees in the Jitter API. JBoundingBox Represents an axis-aligned bounding box (AABB), a rectangular bounding box whose edges are parallel to the coordinate axes. JMatrix Represents a 3x3 matrix with components of type float. JQuaternion A structure representing a Quaternion: Q = xi + yj + z*k + w. Uses the Hamilton convention where i = j = k = ijk = -1. JTriangle Represents a triangle defined by three vertices. JVector Represents a three-dimensional vector with components of type float. Enums JBoundingBox.ContainmentType Describes how one bounding box relates to another spatially. JTriangle.CullMode Specifies the face culling mode for triangles based on their winding order. Counter-clockwise (CCW) winding is considered front-facing."
  },
  "api/Jitter2.Logger.LogLevel.html": {
    "href": "api/Jitter2.Logger.LogLevel.html",
    "title": "Enum Logger.LogLevel | Jitter2",
    "summary": "Enum Logger.LogLevel Namespace Jitter2 Assembly Jitter2.dll Defines the severity levels for logging messages. public enum Logger.LogLevel Fields Error = 2 Information = 0 Warning = 1"
  },
  "api/Jitter2.Logger.html": {
    "href": "api/Jitter2.Logger.html",
    "title": "Class Logger | Jitter2",
    "summary": "Class Logger Namespace Jitter2 Assembly Jitter2.dll Provides logging functionality. public static class Logger Inheritance object Logger Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Listener Gets or sets a listener which receives log messages. public static Action<Logger.LogLevel, string>? Listener { get; set; } Property Value Action<Logger.LogLevel, string> Methods Error(scoped ReadOnlySpan<char>) Logs an error message. public static void Error(scoped ReadOnlySpan<char> format) Parameters format ReadOnlySpan<char> The message to log. Error<T1>(scoped ReadOnlySpan<char>, T1) Logs an error message. public static void Error<T1>(scoped ReadOnlySpan<char> format, T1 arg1) Parameters format ReadOnlySpan<char> The message to log. arg1 T1 Type Parameters T1 Error<T1, T2>(scoped ReadOnlySpan<char>, T1, T2) Logs an error message. public static void Error<T1, T2>(scoped ReadOnlySpan<char> format, T1 arg1, T2 arg2) Parameters format ReadOnlySpan<char> The message to log. arg1 T1 arg2 T2 Type Parameters T1 T2 Error<T1, T2, T3>(scoped ReadOnlySpan<char>, T1, T2, T3) Logs an error message. public static void Error<T1, T2, T3>(scoped ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3) Parameters format ReadOnlySpan<char> The message to log. arg1 T1 arg2 T2 arg3 T3 Type Parameters T1 T2 T3 Information(scoped ReadOnlySpan<char>) Logs an informational message. public static void Information(scoped ReadOnlySpan<char> format) Parameters format ReadOnlySpan<char> The message to log. Information<T1>(scoped ReadOnlySpan<char>, T1) Logs an informational message. public static void Information<T1>(scoped ReadOnlySpan<char> format, T1 arg1) Parameters format ReadOnlySpan<char> The message to log. arg1 T1 Type Parameters T1 Information<T1, T2>(scoped ReadOnlySpan<char>, T1, T2) Logs an informational message. public static void Information<T1, T2>(scoped ReadOnlySpan<char> format, T1 arg1, T2 arg2) Parameters format ReadOnlySpan<char> The message to log. arg1 T1 arg2 T2 Type Parameters T1 T2 Information<T1, T2, T3>(scoped ReadOnlySpan<char>, T1, T2, T3) Logs an informational message. public static void Information<T1, T2, T3>(scoped ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3) Parameters format ReadOnlySpan<char> The message to log. arg1 T1 arg2 T2 arg3 T3 Type Parameters T1 T2 T3 Warning(scoped ReadOnlySpan<char>) Logs a warning message. public static void Warning(scoped ReadOnlySpan<char> format) Parameters format ReadOnlySpan<char> The message to log. Warning<T1>(scoped ReadOnlySpan<char>, T1) Logs a warning message. public static void Warning<T1>(scoped ReadOnlySpan<char> format, T1 arg1) Parameters format ReadOnlySpan<char> The message to log. arg1 T1 Type Parameters T1 Warning<T1, T2>(scoped ReadOnlySpan<char>, T1, T2) Logs a warning message. public static void Warning<T1, T2>(scoped ReadOnlySpan<char> format, T1 arg1, T2 arg2) Parameters format ReadOnlySpan<char> The message to log. arg1 T1 arg2 T2 Type Parameters T1 T2 Warning<T1, T2, T3>(scoped ReadOnlySpan<char>, T1, T2, T3) Logs a warning message. public static void Warning<T1, T2, T3>(scoped ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3) Parameters format ReadOnlySpan<char> The message to log. arg1 T1 arg2 T2 arg3 T3 Type Parameters T1 T2 T3"
  },
  "api/Jitter2.Parallelization.Parallel.Batch.html": {
    "href": "api/Jitter2.Parallelization.Parallel.Batch.html",
    "title": "Struct Parallel.Batch | Jitter2",
    "summary": "Struct Parallel.Batch Namespace Jitter2.Parallelization Assembly Jitter2.dll Represents a batch defined by a start index, an end index, and a batch index. This struct is utilized in ForBatch(int, int, int, Action<Batch>, bool) to facilitate multithreaded batch processing within a for-loop. public readonly struct Parallel.Batch Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Batch(int, int) Represents a batch defined by a start index, an end index, and a batch index. This struct is utilized in ForBatch(int, int, int, Action<Batch>, bool) to facilitate multithreaded batch processing within a for-loop. public Batch(int start, int end) Parameters start int end int Fields End The exclusive end index of the batch. public readonly int End Field Value int Start The inclusive start index of the batch. public readonly int Start Field Value int Methods ToString() Returns a string representation of the batch. public override string ToString() Returns string"
  },
  "api/Jitter2.Parallelization.Parallel.html": {
    "href": "api/Jitter2.Parallelization.Parallel.html",
    "title": "Class Parallel | Jitter2",
    "summary": "Class Parallel Namespace Jitter2.Parallelization Assembly Jitter2.dll Provides methods and structures for parallel batch processing within the Jitter physics engine. public static class Parallel Inheritance object Parallel Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class is used internally to distribute work across worker threads via ThreadPool. Methods ForBatch(int, int, int, Action<Batch>, bool) Executes tasks in parallel by dividing the work into batches using the ThreadPool. public static void ForBatch(int lower, int upper, int numTasks, Action<Parallel.Batch> action, bool execute = true) Parameters lower int The inclusive lower bound of the range to be processed. upper int The exclusive upper bound of the range to be processed. numTasks int The number of batches to divide the work into. action Action<Parallel.Batch> The callback function to execute for each batch. execute bool Indicates whether to execute the tasks immediately after adding them to the thread pool. Remarks This method splits the range [lower, upper) into numTasks batches and processes each batch in parallel. The action callback is invoked for each batch, which is represented by a Parallel.Batch struct. If execute is true, the method will call Execute() to start executing the tasks. GetBounds(int, int, int, out int, out int) Computes the start and end indices for a specific part of an evenly divided range. public static void GetBounds(int numElements, int numDivisions, int part, out int start, out int end) Parameters numElements int The total number of elements to divide. numDivisions int The number of divisions (parts). part int The zero-based index of the part. start int The inclusive start index for the specified part. end int The exclusive end index for the specified part. Remarks Distributes remainder elements across the first parts. For example, with 14 elements and 4 divisions: part 0 gets [0,4), part 1 gets [4,8), part 2 gets [8,11), part 3 gets [11,14)."
  },
  "api/Jitter2.Parallelization.ParallelExtensions.html": {
    "href": "api/Jitter2.Parallelization.ParallelExtensions.html",
    "title": "Class ParallelExtensions | Jitter2",
    "summary": "Class ParallelExtensions Namespace Jitter2.Parallelization Assembly Jitter2.dll Provides parallel batch processing extension methods for collections used by the physics engine. public static class ParallelExtensions Inheritance object ParallelExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks These methods divide collections into batches and distribute them across worker threads. The batch count is determined by the task threshold and available threads. Methods ParallelForBatch(Array, int, Action<Batch>, bool) Processes array elements in parallel batches. public static int ParallelForBatch(this Array array, int taskThreshold, Action<Parallel.Batch> action, bool execute = true) Parameters array Array The array to process. taskThreshold int Minimum elements per batch. Fewer elements result in a single batch. action Action<Parallel.Batch> The callback to invoke for each batch. execute bool If true, calls Execute() to start execution. Returns int The number of batches generated. ParallelForBatch<T>(ReadOnlyPartitionedSet<T>, int, Action<Batch>, bool) Processes active elements of a ReadOnlyPartitionedSet<T> in parallel batches. public static int ParallelForBatch<T>(this ReadOnlyPartitionedSet<T> list, int taskThreshold, Action<Parallel.Batch> action, bool execute = true) where T : class, IPartitionedSetIndex Parameters list ReadOnlyPartitionedSet<T> The set to process. taskThreshold int Minimum elements per batch. Fewer elements result in a single batch. action Action<Parallel.Batch> The callback to invoke for each batch. execute bool If true, calls Execute() to start execution. Returns int The number of batches generated. Type Parameters T The element type. ParallelForBatch<T>(PartitionedBuffer<T>, int, Action<Batch>, bool) Processes active elements of a PartitionedBuffer<T> in parallel batches. public static int ParallelForBatch<T>(this PartitionedBuffer<T> list, int taskThreshold, Action<Parallel.Batch> action, bool execute = true) where T : unmanaged Parameters list PartitionedBuffer<T> The buffer to process. taskThreshold int Minimum elements per batch. Fewer elements result in a single batch. action Action<Parallel.Batch> The callback to invoke for each batch. execute bool If true, calls Execute() to start execution. Returns int The number of batches generated. Type Parameters T The unmanaged element type."
  },
  "api/Jitter2.Parallelization.ReaderWriterLock.html": {
    "href": "api/Jitter2.Parallelization.ReaderWriterLock.html",
    "title": "Struct ReaderWriterLock | Jitter2",
    "summary": "Struct ReaderWriterLock Namespace Jitter2.Parallelization Assembly Jitter2.dll Provides a lightweight reader-writer lock optimized for rare write operations. public struct ReaderWriterLock Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Multiple readers can hold the lock concurrently, but writers have exclusive access. This implementation uses spin-waiting and is best suited for short critical sections. Thread-safe. All methods use atomic operations and memory barriers. Methods EnterReadLock() Acquires the read lock. Blocks while a writer holds the lock. public void EnterReadLock() Remarks Multiple threads can hold the read lock simultaneously. Call ExitReadLock() to release. EnterWriteLock() Acquires the write lock with exclusive access. Blocks until all readers and writers release. public void EnterWriteLock() Remarks Only one thread can hold the write lock at a time. Call ExitWriteLock() to release. ExitReadLock() Exits the read section. public void ExitReadLock() ExitWriteLock() Exits the write section. public void ExitWriteLock()"
  },
  "api/Jitter2.Parallelization.ThreadPool.html": {
    "href": "api/Jitter2.Parallelization.ThreadPool.html",
    "title": "Class ThreadPool | Jitter2",
    "summary": "Class ThreadPool Namespace Jitter2.Parallelization Assembly Jitter2.dll Provides a persistent worker thread pool for parallel task execution within the physics engine. public sealed class ThreadPool Inheritance object ThreadPool Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Worker threads are kept alive for the lifetime of the pool to avoid wake-up overhead. Tasks are distributed via per-thread queues with work stealing for load balancing. The main thread participates as \"worker 0\" during Execute() calls. Use ResumeWorkers() and PauseWorkers() to control thread activity between simulation steps. Thread-safe. All task queuing and execution methods are safe to call from multiple threads. Fields ThreadsPerProcessor The fraction of available processors to use for worker threads. public const float ThreadsPerProcessor = 0.9 Field Value float Properties Instance Implements the singleton pattern to provide a single instance of the ThreadPool. public static ThreadPool Instance { get; } Property Value ThreadPool InstanceInitialized Indicates whether the ThreadPool instance is initialized. public static bool InstanceInitialized { get; } Property Value bool true if initialized; otherwise, false. ThreadCount Gets the number of worker threads managed by this pool. public int ThreadCount { get; } Property Value int Includes the main thread as worker 0. ThreadCountSuggestion Gets the suggested number of threads based on available processors. public static int ThreadCountSuggestion { get; } Property Value int At least 1, computed as ThreadsPerProcessor  processor count. Methods AddTask<T>(Action<T>, T) Adds a task to the queue for later execution. public void AddTask<T>(Action<T> action, T parameter) Parameters action Action<T> The action to execute. parameter T The parameter to pass to the action. Type Parameters T The type of the task parameter. Remarks Tasks are not executed until Execute() is called. This method is thread-safe. ChangeThreadCount(int) Changes the number of worker threads. public void ChangeThreadCount(int numThreads) Parameters numThreads int The new thread count. Remarks Existing worker threads are stopped and new ones are created. This operation blocks until all previous threads have terminated. Execute() Executes all queued tasks and blocks until completion. public void Execute() Remarks Tasks are distributed to per-thread queues in round-robin order. The main thread participates as worker 0 and performs work stealing from other queues. This method automatically calls ResumeWorkers() at the start. PauseWorkers() Pauses all worker threads after they finish their current tasks. public void PauseWorkers() Remarks Workers will block on a wait handle until ResumeWorkers() is called. This reduces CPU usage between simulation steps. ResumeWorkers() Resumes all worker threads so they can process queued tasks. public void ResumeWorkers() Remarks Called automatically by Execute(). Manual calls are typically only needed when using Persistent."
  },
  "api/Jitter2.Parallelization.html": {
    "href": "api/Jitter2.Parallelization.html",
    "title": "Namespace Jitter2.Parallelization | Jitter2",
    "summary": "Namespace Jitter2.Parallelization Classes Parallel Provides methods and structures for parallel batch processing within the Jitter physics engine. ParallelExtensions Provides parallel batch processing extension methods for collections used by the physics engine. ThreadPool Provides a persistent worker thread pool for parallel task execution within the physics engine. Structs Parallel.Batch Represents a batch defined by a start index, an end index, and a batch index. This struct is utilized in ForBatch(int, int, int, Action<Batch>, bool) to facilitate multithreaded batch processing within a for-loop. ReaderWriterLock Provides a lightweight reader-writer lock optimized for rare write operations."
  },
  "api/Jitter2.Precision.html": {
    "href": "api/Jitter2.Precision.html",
    "title": "Class Precision | Jitter2",
    "summary": "Class Precision Namespace Jitter2 Assembly Jitter2.dll Provides constants and utilities related to floating-point precision configuration. The library can be compiled with single-precision (float) or double-precision (double) by defining the USE_DOUBLE_PRECISION symbol. public static class Precision Inheritance object Precision Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields ConstraintSizeFull The size in bytes of a full constraint data structure. public const int ConstraintSizeFull = 256 Field Value int ConstraintSizeSmall The size in bytes of a small constraint data structure. public const int ConstraintSizeSmall = 128 Field Value int RigidBodyDataSize The size in bytes of the RigidBodyData structure. public const int RigidBodyDataSize = 128 Field Value int Properties IsDoublePrecision Gets a value indicating whether the engine is configured to use double-precision floating-point numbers. public static bool IsDoublePrecision { get; } Property Value bool"
  },
  "api/Jitter2.ReferenceFrame.html": {
    "href": "api/Jitter2.ReferenceFrame.html",
    "title": "Enum ReferenceFrame | Jitter2",
    "summary": "Enum ReferenceFrame Namespace Jitter2 Assembly Jitter2.dll Enum representing reference frames. public enum ReferenceFrame Fields Local = 0 World = 1"
  },
  "api/Jitter2.ReferenceFrameAttribute.html": {
    "href": "api/Jitter2.ReferenceFrameAttribute.html",
    "title": "Class ReferenceFrameAttribute | Jitter2",
    "summary": "Class ReferenceFrameAttribute Namespace Jitter2 Assembly Jitter2.dll Attribute to specify the reference frame of a member. [AttributeUsage(AttributeTargets.All)] public sealed class ReferenceFrameAttribute : Attribute Inheritance object Attribute ReferenceFrameAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ReferenceFrameAttribute(ReferenceFrame) Initializes a new instance of the ReferenceFrameAttribute class. public ReferenceFrameAttribute(ReferenceFrame frame) Parameters frame ReferenceFrame The reference frame. Properties Frame Gets or sets the reference frame. public ReferenceFrame Frame { get; set; } Property Value ReferenceFrame"
  },
  "api/Jitter2.SoftBodies.BroadPhaseCollisionFilter.html": {
    "href": "api/Jitter2.SoftBodies.BroadPhaseCollisionFilter.html",
    "title": "Class BroadPhaseCollisionFilter | Jitter2",
    "summary": "Class BroadPhaseCollisionFilter Namespace Jitter2.SoftBodies Assembly Jitter2.dll A broad-phase filter that handles collisions involving soft body shapes. It delegates collision detection to the narrow phase and registers contacts with the closest rigid body vertices of the soft body. public class BroadPhaseCollisionFilter : IBroadPhaseFilter Inheritance object BroadPhaseCollisionFilter Implements IBroadPhaseFilter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BroadPhaseCollisionFilter(World) Initializes a new instance of the BroadPhaseCollisionFilter class. public BroadPhaseCollisionFilter(World world) Parameters world World The world instance. Methods Filter(IDynamicTreeProxy, IDynamicTreeProxy) Called for each pair of proxies whose bounding boxes overlap. public bool Filter(IDynamicTreeProxy proxyA, IDynamicTreeProxy proxyB) Parameters proxyA IDynamicTreeProxy The first proxy. proxyB IDynamicTreeProxy The second proxy. Returns bool true to continue with narrowphase detection; false to skip this pair."
  },
  "api/Jitter2.SoftBodies.DynamicTreeCollisionFilter.html": {
    "href": "api/Jitter2.SoftBodies.DynamicTreeCollisionFilter.html",
    "title": "Class DynamicTreeCollisionFilter | Jitter2",
    "summary": "Class DynamicTreeCollisionFilter Namespace Jitter2.SoftBodies Assembly Jitter2.dll Provides a collision filter that prevents self-collisions within soft bodies and shapes attached to the same rigid body. public static class DynamicTreeCollisionFilter Inheritance object DynamicTreeCollisionFilter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Filter(IDynamicTreeProxy, IDynamicTreeProxy) Filters collision pairs to exclude self-collisions. public static bool Filter(IDynamicTreeProxy proxyA, IDynamicTreeProxy proxyB) Parameters proxyA IDynamicTreeProxy The first proxy. proxyB IDynamicTreeProxy The second proxy. Returns bool true if the pair should be processed for collision; false if it should be skipped."
  },
  "api/Jitter2.SoftBodies.SoftBody.html": {
    "href": "api/Jitter2.SoftBodies.SoftBody.html",
    "title": "Class SoftBody | Jitter2",
    "summary": "Class SoftBody Namespace Jitter2.SoftBodies Assembly Jitter2.dll Represents a soft body in the physics simulation. A soft body is composed of vertices (rigid bodies), springs (constraints), and shapes. public class SoftBody Inheritance object SoftBody Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SoftBody(World) Initializes a new instance of the SoftBody class. public SoftBody(World world) Parameters world World The world in which the soft body will be created. Properties IsActive Gets a value indicating whether the soft body is active. A soft body is considered active if its first vertex is active. public bool IsActive { get; } Property Value bool Shapes Gets the list of shapes that define the geometry of the soft body. public List<SoftBodyShape> Shapes { get; } Property Value List<SoftBodyShape> Springs Gets the list of springs (constraints) that connect the vertices of the soft body. public List<Constraint> Springs { get; } Property Value List<Constraint> Vertices Gets the list of vertices (rigid bodies) that make up the soft body. public List<RigidBody> Vertices { get; } Property Value List<RigidBody> World Gets the world in which the soft body exists. public World World { get; } Property Value World Methods AddShape(SoftBodyShape) Adds a shape to the soft body and registers it with the world's dynamic tree. public void AddShape(SoftBodyShape shape) Parameters shape SoftBodyShape The shape to add. AddSpring(Constraint) Adds a spring (constraint) to the soft body. public void AddSpring(Constraint constraint) Parameters constraint Constraint The constraint to add. Destroy() Destroys the soft body, removing all its components from the simulation world. public virtual void Destroy() WorldOnPostStep(float) Called after each world step to update the activation state of the soft body's shapes. protected virtual void WorldOnPostStep(float dt) Parameters dt float The time step."
  },
  "api/Jitter2.SoftBodies.SoftBodyShape.html": {
    "href": "api/Jitter2.SoftBodies.SoftBodyShape.html",
    "title": "Class SoftBodyShape | Jitter2",
    "summary": "Class SoftBodyShape Namespace Jitter2.SoftBodies Assembly Jitter2.dll Abstract base class for shapes used in soft body simulations. public abstract class SoftBodyShape : Shape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape SoftBodyShape Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Derived SoftBodyTetrahedron SoftBodyTriangle Inherited Members Shape.ShapeId Shape.WorldBoundingBox Shape.SweptExpandBoundingBox(float) Shape.Velocity Shape.UpdateWorldBoundingBox(float) Shape.SupportMap(in JVector, out JVector) Shape.GetCenter(out JVector) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties SoftBody Gets the soft body instance this shape belongs to. public SoftBody SoftBody { get; } Property Value SoftBody Methods GetClosest(in JVector) Gets the rigid body closest to the specified position. public abstract RigidBody GetClosest(in JVector pos) Parameters pos JVector The position in world coordinates. Returns RigidBody The closest rigid body (vertex) of this shape. RayCast(in JVector, in JVector, out JVector, out float) Performs a ray cast against this object. public override bool RayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda) Parameters origin JVector The starting point of the ray. direction JVector The direction of the ray. Does not need to be normalized. normal JVector The surface normal at the intersection point. lambda float The distance along the ray to the intersection: hitPoint = origin + lambda * direction. Returns bool true if the ray intersects with the object; otherwise, false."
  },
  "api/Jitter2.SoftBodies.SoftBodyTetrahedron.html": {
    "href": "api/Jitter2.SoftBodies.SoftBodyTetrahedron.html",
    "title": "Class SoftBodyTetrahedron | Jitter2",
    "summary": "Class SoftBodyTetrahedron Namespace Jitter2.SoftBodies Assembly Jitter2.dll Represents a tetrahedral shape in a soft body simulation. public sealed class SoftBodyTetrahedron : SoftBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape SoftBodyShape SoftBodyTetrahedron Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Inherited Members SoftBodyShape.SoftBody SoftBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors SoftBodyTetrahedron(SoftBody, RigidBody, RigidBody, RigidBody, RigidBody) Initializes a new instance of the SoftBodyTetrahedron class. public SoftBodyTetrahedron(SoftBody body, RigidBody v1, RigidBody v2, RigidBody v3, RigidBody v4) Parameters body SoftBody The soft body this shape belongs to. v1 RigidBody The first vertex. v2 RigidBody The second vertex. v3 RigidBody The third vertex. v4 RigidBody The fourth vertex. Properties Velocity Gets the velocity of the entity, used for bounding box expansion. public override JVector Velocity { get; } Property Value JVector Vertices Gets the four vertices (rigid bodies) of the tetrahedron. public RigidBody[] Vertices { get; } Property Value RigidBody[] Methods GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. GetClosest(in JVector) Gets the rigid body closest to the specified position. public override RigidBody GetClosest(in JVector pos) Parameters pos JVector The position in world coordinates. Returns RigidBody The closest rigid body (vertex) of this shape. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction. UpdateWorldBoundingBox(float) Recomputes the world-space bounding box. public override void UpdateWorldBoundingBox(float dt = 0) Parameters dt float The timestep for velocity-based expansion. Default is zero."
  },
  "api/Jitter2.SoftBodies.SoftBodyTriangle.html": {
    "href": "api/Jitter2.SoftBodies.SoftBodyTriangle.html",
    "title": "Class SoftBodyTriangle | Jitter2",
    "summary": "Class SoftBodyTriangle Namespace Jitter2.SoftBodies Assembly Jitter2.dll Represents a triangular shape in a soft body simulation. public sealed class SoftBodyTriangle : SoftBodyShape, IDynamicTreeProxy, IPartitionedSetIndex, IUpdatableBoundingBox, ISupportMappable, IRayCastable Inheritance object Shape SoftBodyShape SoftBodyTriangle Implements IDynamicTreeProxy IPartitionedSetIndex IUpdatableBoundingBox ISupportMappable IRayCastable Inherited Members SoftBodyShape.SoftBody SoftBodyShape.RayCast(in JVector, in JVector, out JVector, out float) Shape.ShapeId Shape.WorldBoundingBox object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors SoftBodyTriangle(SoftBody, RigidBody, RigidBody, RigidBody) Initializes a new instance of the SoftBodyTriangle class. public SoftBodyTriangle(SoftBody body, RigidBody v1, RigidBody v2, RigidBody v3) Parameters body SoftBody The soft body this shape belongs to. v1 RigidBody The first vertex. v2 RigidBody The second vertex. v3 RigidBody The third vertex. Properties Thickness Gets or sets the thickness of the triangle. public float Thickness { get; set; } Property Value float Velocity Gets the velocity of the entity, used for bounding box expansion. public override JVector Velocity { get; } Property Value JVector Vertex1 Gets the first vertex (rigid body) of the triangle. public RigidBody Vertex1 { get; } Property Value RigidBody Vertex2 Gets the second vertex (rigid body) of the triangle. public RigidBody Vertex2 { get; } Property Value RigidBody Vertex3 Gets the third vertex (rigid body) of the triangle. public RigidBody Vertex3 { get; } Property Value RigidBody Methods GetCenter(out JVector) Computes a point deep within the shape, used as an initial search point in GJK-based algorithms. public override void GetCenter(out JVector point) Parameters point JVector A point guaranteed to be inside the convex hull, typically the center of mass. GetClosest(in JVector) Gets the rigid body closest to the specified position. public override RigidBody GetClosest(in JVector pos) Parameters pos JVector The position in world coordinates. Returns RigidBody The closest rigid body (vertex) of this shape. SupportMap(in JVector, out JVector) Computes the point on the shape that is furthest in the specified direction. public override void SupportMap(in JVector direction, out JVector result) Parameters direction JVector The search direction in local space. Does not need to be normalized. result JVector The point on the shape's surface furthest along direction. UpdateWorldBoundingBox(float) Recomputes the world-space bounding box. public override void UpdateWorldBoundingBox(float dt = 0) Parameters dt float The timestep for velocity-based expansion. Default is zero."
  },
  "api/Jitter2.SoftBodies.SpringConstraint.SpringData.html": {
    "href": "api/Jitter2.SoftBodies.SpringConstraint.SpringData.html",
    "title": "Struct SpringConstraint.SpringData | Jitter2",
    "summary": "Struct SpringConstraint.SpringData Namespace Jitter2.SoftBodies Assembly Jitter2.dll Low-level data for the spring constraint, stored in unmanaged memory. public struct SpringConstraint.SpringData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulse public float AccumulatedImpulse Field Value float Bias public float Bias Field Value float BiasFactor public float BiasFactor Field Value float Body1 public JHandle<RigidBodyData> Body1 Field Value JHandle<RigidBodyData> Body2 public JHandle<RigidBodyData> Body2 Field Value JHandle<RigidBodyData> Distance public float Distance Field Value float EffectiveMass public float EffectiveMass Field Value float Jacobian public JVector Jacobian Field Value JVector LocalAnchor1 public JVector LocalAnchor1 Field Value JVector LocalAnchor2 public JVector LocalAnchor2 Field Value JVector Softness public float Softness Field Value float"
  },
  "api/Jitter2.SoftBodies.SpringConstraint.html": {
    "href": "api/Jitter2.SoftBodies.SpringConstraint.html",
    "title": "Class SpringConstraint | Jitter2",
    "summary": "Class SpringConstraint Namespace Jitter2.SoftBodies Assembly Jitter2.dll Constrains two bodies to maintain a target distance between anchor points, applying spring-like forces. Removes one translational degree of freedom along the line connecting the anchors. public class SpringConstraint : Constraint<SpringConstraint.SpringData>, IDebugDrawable Inheritance object Constraint Constraint<SpringConstraint.SpringData> SpringConstraint Implements IDebugDrawable Inherited Members Constraint<SpringConstraint.SpringData>.Data Constraint<SpringConstraint.SpringData>.IsSmallConstraint Constraint.Body1 Constraint.Body2 Constraint.Handle Constraint.SmallHandle Constraint.CheckDataSize<T>() Constraint.VerifyNotZero() Constraint.Iterate Constraint.PrepareForIteration Constraint.IsEnabled Constraint.DebugDraw(IDebugDrawer) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The spring behavior is controlled by Softness and Bias, which can be set directly or computed from physical parameters using SetSpringParameters(float, float, float). Properties Anchor1 Gets or sets the anchor point on the first body in world space. public JVector Anchor1 { get; set; } Property Value JVector Anchor2 Gets or sets the anchor point on the second body in world space. public JVector Anchor2 { get; set; } Property Value JVector Bias Gets or sets the bias factor (error correction strength) of the spring constraint. public float Bias { get; set; } Property Value float Default is 0.2. Higher values correct distance errors more aggressively. Distance Gets the current distance between the anchor points. public float Distance { get; } Property Value float Impulse Gets the accumulated impulse applied by the spring. public float Impulse { get; } Property Value float Softness Gets or sets the softness (compliance) of the spring constraint. public float Softness { get; set; } Property Value float Default is 0.001. Higher values allow more positional error but produce a softer spring. Scaled by inverse timestep during solving. TargetDistance Gets or sets the target resting distance of the spring. public float TargetDistance { get; set; } Property Value float Units: meters. Default is the initial distance between anchors at initialization. Methods Create() Initializes the function pointers for Iterate and PrepareForIteration. Override this in derived classes. protected override void Create() Initialize(JVector, JVector) Initializes the constraint from world-space anchor points. public void Initialize(JVector anchor1, JVector anchor2) Parameters anchor1 JVector Anchor point on the first rigid body, in world space. anchor2 JVector Anchor point on the second rigid body, in world space. Remarks Computes local anchor offsets from the current body positions. Default values: Softness = 0.001, Bias = 0.2. The TargetDistance is set to the initial distance between the anchors. IterateSpringConstraint(ref ConstraintData, float) Performs one iteration of the spring constraint solver. public static void IterateSpringConstraint(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData The constraint data reference. idt float The inverse substep duration (1/dt). PrepareForIterationSpringConstraint(ref ConstraintData, float) Prepares the spring constraint for iteration. public static void PrepareForIterationSpringConstraint(ref ConstraintData constraint, float idt) Parameters constraint ConstraintData The constraint data reference. idt float The inverse substep duration (1/dt). SetSpringParameters(float, float, float) Sets the spring parameters using physical properties. This method calculates and sets the Softness and Bias properties. It assumes that the mass of the involved bodies and the timestep size does not change. public void SetSpringParameters(float frequency, float damping, float dt) Parameters frequency float The frequency in Hz. damping float The damping ratio (0 = no damping, 1 = critical damping). dt float The timestep of the simulation."
  },
  "api/Jitter2.SoftBodies.html": {
    "href": "api/Jitter2.SoftBodies.html",
    "title": "Namespace Jitter2.SoftBodies | Jitter2",
    "summary": "Namespace Jitter2.SoftBodies Classes BroadPhaseCollisionFilter A broad-phase filter that handles collisions involving soft body shapes. It delegates collision detection to the narrow phase and registers contacts with the closest rigid body vertices of the soft body. DynamicTreeCollisionFilter Provides a collision filter that prevents self-collisions within soft bodies and shapes attached to the same rigid body. SoftBody Represents a soft body in the physics simulation. A soft body is composed of vertices (rigid bodies), springs (constraints), and shapes. SoftBodyShape Abstract base class for shapes used in soft body simulations. SoftBodyTetrahedron Represents a tetrahedral shape in a soft body simulation. SoftBodyTriangle Represents a triangular shape in a soft body simulation. SpringConstraint Constrains two bodies to maintain a target distance between anchor points, applying spring-like forces. Removes one translational degree of freedom along the line connecting the anchors. Structs SpringConstraint.SpringData Low-level data for the spring constraint, stored in unmanaged memory."
  },
  "api/Jitter2.ThreadContext.html": {
    "href": "api/Jitter2.ThreadContext.html",
    "title": "Enum ThreadContext | Jitter2",
    "summary": "Enum ThreadContext Namespace Jitter2 Assembly Jitter2.dll Specifies the threading context in which code executes or a callback is invoked. public enum ThreadContext Fields Any = 2 Could be called from either. Handle with care. MainThread = 0 Called from the main thread (or the thread calling World.Step). Safe to access global state. ParallelWorker = 1 Called from background worker threads. Code must be thread-safe and lock-free."
  },
  "api/Jitter2.Unmanaged.JHandle-1.html": {
    "href": "api/Jitter2.Unmanaged.JHandle-1.html",
    "title": "Struct JHandle<T> | Jitter2",
    "summary": "Struct JHandle<T> Namespace Jitter2.Unmanaged Assembly Jitter2.dll Handle for an unmanaged object stored in a PartitionedBuffer<T>. The handle remains stable even when the underlying memory is resized. public readonly struct JHandle<T> : IEquatable<JHandle<T>> where T : unmanaged Type Parameters T The unmanaged type of the data. Implements IEquatable<JHandle<T>> Inherited Members ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Validity: A handle is valid only while the owning PartitionedBuffer<T> exists and the element has not been freed via Free(JHandle<T>). Do not cache the Data reference across operations that may resize the buffer. Use the handle to obtain a fresh reference when needed. Fields Zero A handle representing a null/invalid reference. public static readonly JHandle<T> Zero Field Value JHandle<T> Properties Data Gets a reference to the underlying data. public ref T Data { get; } Property Value T IsZero Gets a value indicating whether this handle is null/invalid. public bool IsZero { get; } Property Value bool Methods AsHandle<TConvert>(JHandle<T>) Reinterprets a handle as a handle to a different type. Both types must have compatible layouts. public static JHandle<TConvert> AsHandle<TConvert>(JHandle<T> handle) where TConvert : unmanaged Parameters handle JHandle<T> The handle to reinterpret. Returns JHandle<TConvert> A handle reinterpreted as the target type. Type Parameters TConvert The target unmanaged type to reinterpret as. Remarks Safety: The caller must ensure that T and TConvert have compatible memory layouts. No runtime validation is performed. Equals(JHandle<T>) Indicates whether the current object is equal to another object of the same type. public bool Equals(JHandle<T> other) Parameters other JHandle<T> An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. Operators operator ==(JHandle<T>, JHandle<T>) public static bool operator ==(JHandle<T> left, JHandle<T> right) Parameters left JHandle<T> right JHandle<T> Returns bool operator !=(JHandle<T>, JHandle<T>) public static bool operator !=(JHandle<T> left, JHandle<T> right) Parameters left JHandle<T> right JHandle<T> Returns bool"
  },
  "api/Jitter2.Unmanaged.MemoryHelper.IsolatedInt.html": {
    "href": "api/Jitter2.Unmanaged.MemoryHelper.IsolatedInt.html",
    "title": "Struct MemoryHelper.IsolatedInt | Jitter2",
    "summary": "Struct MemoryHelper.IsolatedInt Namespace Jitter2.Unmanaged Assembly Jitter2.dll Represents an integer value isolated in memory to prevent false sharing between multiple threads operating on adjacent data. public struct MemoryHelper.IsolatedInt Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The struct is padded to 132 bytes (64-byte padding on each side of the value) to ensure the Value field resides on its own cache line. Fields Value public int Value Field Value int"
  },
  "api/Jitter2.Unmanaged.MemoryHelper.MemBlock12Real.html": {
    "href": "api/Jitter2.Unmanaged.MemoryHelper.MemBlock12Real.html",
    "title": "Struct MemoryHelper.MemBlock12Real | Jitter2",
    "summary": "Struct MemoryHelper.MemBlock12Real Namespace Jitter2.Unmanaged Assembly Jitter2.dll A memory block with a size equivalent to twelve instances of the float type. public struct MemoryHelper.MemBlock12Real Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The struct uses sequential layout and a fixed size to ensure consistent memory alignment and layout."
  },
  "api/Jitter2.Unmanaged.MemoryHelper.MemBlock16Real.html": {
    "href": "api/Jitter2.Unmanaged.MemoryHelper.MemBlock16Real.html",
    "title": "Struct MemoryHelper.MemBlock16Real | Jitter2",
    "summary": "Struct MemoryHelper.MemBlock16Real Namespace Jitter2.Unmanaged Assembly Jitter2.dll A memory block with a size equivalent to sixteen instances of the float type. public struct MemoryHelper.MemBlock16Real Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The struct uses sequential layout and a fixed size to ensure consistent memory alignment and layout."
  },
  "api/Jitter2.Unmanaged.MemoryHelper.MemBlock6Real.html": {
    "href": "api/Jitter2.Unmanaged.MemoryHelper.MemBlock6Real.html",
    "title": "Struct MemoryHelper.MemBlock6Real | Jitter2",
    "summary": "Struct MemoryHelper.MemBlock6Real Namespace Jitter2.Unmanaged Assembly Jitter2.dll A memory block with a size equivalent to six instances of the float type. public struct MemoryHelper.MemBlock6Real Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The struct uses sequential layout and a fixed size to ensure consistent memory alignment and layout."
  },
  "api/Jitter2.Unmanaged.MemoryHelper.MemBlock9Real.html": {
    "href": "api/Jitter2.Unmanaged.MemoryHelper.MemBlock9Real.html",
    "title": "Struct MemoryHelper.MemBlock9Real | Jitter2",
    "summary": "Struct MemoryHelper.MemBlock9Real Namespace Jitter2.Unmanaged Assembly Jitter2.dll A memory block with a size equivalent to nine instances of the float type. public struct MemoryHelper.MemBlock9Real Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The struct uses sequential layout and a fixed size to ensure consistent memory alignment and layout."
  },
  "api/Jitter2.Unmanaged.MemoryHelper.html": {
    "href": "api/Jitter2.Unmanaged.MemoryHelper.html",
    "title": "Class MemoryHelper | Jitter2",
    "summary": "Class MemoryHelper Namespace Jitter2.Unmanaged Assembly Jitter2.dll Provides helper methods for allocating and managing unmanaged memory. public static class MemoryHelper Inheritance object MemoryHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Safety: All pointers returned by allocation methods must be freed using the corresponding Free(void*) or AlignedFree(void*) method. Failure to do so will result in memory leaks. Threading: These methods are thread-safe, but the caller is responsible for synchronizing access to the allocated memory. Methods AlignedAllocateHeap(int, int) Allocates a block of aligned unmanaged memory of the specified length in bytes. public static void* AlignedAllocateHeap(int len, int alignment) Parameters len int The length of the memory block to allocate, in bytes. alignment int The memory alignment in bytes (must be a power of 2). Returns void* A pointer to the allocated memory block. Remarks Safety: The caller must free the returned pointer using AlignedFree(void*). The memory is not zero-initialized. AlignedAllocateHeap<T>(int, int) Allocates a block of aligned unmanaged memory for an array of the specified type. public static T* AlignedAllocateHeap<T>(int num, int alignment) where T : unmanaged Parameters num int The number of elements to allocate memory for. alignment int The memory alignment in bytes (must be a power of 2). Returns T* A pointer to the allocated memory block. Type Parameters T The unmanaged type of the elements to allocate memory for. Remarks Safety: The caller must free the returned pointer using AlignedFree(void*). The memory is not zero-initialized. AlignedFree(void*) Frees a block of aligned unmanaged memory previously allocated. public static void AlignedFree(void* ptr) Parameters ptr void* A pointer to the aligned memory block to free. AllocateHeap(int) Allocates a block of unmanaged memory of the specified length in bytes. public static void* AllocateHeap(int len) Parameters len int The length of the memory block to allocate, in bytes. Returns void* A pointer to the allocated memory block. Remarks Safety: The caller must free the returned pointer using Free(void*). The memory is not zero-initialized. AllocateHeap<T>(int) Allocates a block of unmanaged memory for an array of the specified type. public static T* AllocateHeap<T>(int num) where T : unmanaged Parameters num int The number of elements to allocate memory for. Returns T* A pointer to the allocated memory block. Type Parameters T The unmanaged type of the elements to allocate memory for. Remarks Safety: The caller must free the returned pointer using Free<T>(T*). The memory is not zero-initialized. Free(void*) Frees a block of unmanaged memory previously allocated. public static void Free(void* ptr) Parameters ptr void* A pointer to the memory block to free. Free<T>(T*) Frees a block of unmanaged memory previously allocated for an array of the specified type. public static void Free<T>(T* ptr) where T : unmanaged Parameters ptr T* A pointer to the memory block to free. Type Parameters T The unmanaged type of the elements in the memory block. MemSet(void*, int) Zeros out unmanaged memory. public static void MemSet(void* buffer, int len) Parameters buffer void* A pointer to the memory block to zero out. len int The length of the memory block to zero out, in bytes."
  },
  "api/Jitter2.Unmanaged.PartitionedBuffer-1.MaximumSizeException.html": {
    "href": "api/Jitter2.Unmanaged.PartitionedBuffer-1.MaximumSizeException.html",
    "title": "Class PartitionedBuffer<T>.MaximumSizeException | Jitter2",
    "summary": "Class PartitionedBuffer<T>.MaximumSizeException Namespace Jitter2.Unmanaged Assembly Jitter2.dll Exception thrown when the buffer's internal indirection table reaches its maximum capacity. public class PartitionedBuffer<T>.MaximumSizeException : Exception, ISerializable Inheritance object Exception PartitionedBuffer<T>.MaximumSizeException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors MaximumSizeException() public MaximumSizeException() MaximumSizeException(string) public MaximumSizeException(string message) Parameters message string MaximumSizeException(string, Exception) public MaximumSizeException(string message, Exception inner) Parameters message string inner Exception"
  },
  "api/Jitter2.Unmanaged.PartitionedBuffer-1.html": {
    "href": "api/Jitter2.Unmanaged.PartitionedBuffer-1.html",
    "title": "Class PartitionedBuffer<T> | Jitter2",
    "summary": "Class PartitionedBuffer<T> Namespace Jitter2.Unmanaged Assembly Jitter2.dll Manages memory for unmanaged structs, storing them sequentially in contiguous memory blocks. Each struct can either be active or inactive. public sealed class PartitionedBuffer<T> : IDisposable where T : unmanaged Type Parameters T The unmanaged type to store. Must be at least 4 bytes in size. Inheritance object PartitionedBuffer<T> Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods ParallelExtensions.ParallelForBatch<T>(PartitionedBuffer<T>, int, Action<Parallel.Batch>, bool) Remarks Memory Layout Requirement: The type T must reserve its first 4 bytes (sizeof(int)) for internal bookkeeping. This memory region is used to store the stable ID that maps the data back to its JHandle<T>. Do not modify these bytes manually. A compatible struct should look like this: [StructLayout(LayoutKind.Sequential)] public struct RigidBodyData { private readonly int _internalIndex; // Reserved by PartitionedBuffer public JVector Position; public JQuaternion Orientation; // ... other fields } Threading: Concurrent calls to Allocate(bool, bool) may trigger a resize. Use ResizeLock to synchronize access when reading data concurrently with allocations. Disposal: This class owns unmanaged memory and must be disposed to avoid memory leaks. Constructors PartitionedBuffer(int, bool) Initializes a new instance of the class. public PartitionedBuffer(int initialSize = 1024, bool aligned64 = false) Parameters initialSize int The initial size of the contiguous memory block. aligned64 bool Indicates whether the memory should be aligned to 64 bytes. Fields ResizeLock Reader-writer lock. Locked by a writer when a resize occurs. Resizing moves the contiguous data memory addresses. Use a reader lock to access data if concurrent calls to Allocate are made. public ReaderWriterLock ResizeLock Field Value ReaderWriterLock Properties Active A span for all elements marked as active. public Span<T> Active { get; } Property Value Span<T> Remarks Do not cache: This span is invalidated when the buffer resizes. Aligned64 Indicates whether the allocated memory is aligned to a 64-byte boundary. public bool Aligned64 { get; } Property Value bool Count Gets the number of allocated elements in the buffer. public int Count { get; } Property Value int Elements A span for all elements. public Span<T> Elements { get; } Property Value Span<T> Remarks Do not cache: This span is invalidated when the buffer resizes. Inactive A span for all elements marked as inactive. public Span<T> Inactive { get; } Property Value Span<T> Remarks Do not cache: This span is invalidated when the buffer resizes. TotalBytesAllocated Returns the total amount of unmanaged memory allocated in bytes (data + indirection pages). public long TotalBytesAllocated { get; } Property Value long Methods Allocate(bool, bool) Allocates an unmanaged object. Growth is dynamic. public JHandle<T> Allocate(bool active = false, bool clear = false) Parameters active bool If true, the element is added to the active partition. clear bool If true, the element's memory (excluding the internal ID) is zeroed. Returns JHandle<T> A handle to the newly allocated element. Remarks Threading: This method may resize the buffer, which moves all data. Use ResizeLock when calling concurrently with data access. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() ~PartitionedBuffer() protected ~PartitionedBuffer() Free(JHandle<T>) Removes the associated native structure from the buffer and invalidates the handle. public void Free(JHandle<T> handle) Parameters handle JHandle<T> The handle to free. Remarks Safety: After calling this method, the handle becomes invalid. Do not use the handle or any cached references to its data. GetHandle(ref T) Returns the handle of the object. O(1) operation. public JHandle<T> GetHandle(ref T t) Parameters t T A reference to the element in the buffer. Returns JHandle<T> The handle for the element. GetIndex(JHandle<T>) Retrieves the target index of the handle. public int GetIndex(JHandle<T> handle) Parameters handle JHandle<T> The handle to get the index for. Returns int The index of the element in the buffer. IsActive(JHandle<T>) Checks if the element is stored as an active element. O(1). public bool IsActive(JHandle<T> handle) Parameters handle JHandle<T> The handle to check. Returns bool true if the element is active; otherwise, false. MoveToActive(JHandle<T>) Moves an object from inactive to active. public void MoveToActive(JHandle<T> handle) Parameters handle JHandle<T> The handle of the element to move. MoveToInactive(JHandle<T>) Moves an object from active to inactive. public void MoveToInactive(JHandle<T> handle) Parameters handle JHandle<T> The handle of the element to move. Swap(int, int) Swap two entries based on their index. Adjusts handles accordingly. public void Swap(int i, int j) Parameters i int The index of the first element. j int The index of the second element."
  },
  "api/Jitter2.Unmanaged.html": {
    "href": "api/Jitter2.Unmanaged.html",
    "title": "Namespace Jitter2.Unmanaged | Jitter2",
    "summary": "Namespace Jitter2.Unmanaged Classes MemoryHelper Provides helper methods for allocating and managing unmanaged memory. PartitionedBuffer<T> Manages memory for unmanaged structs, storing them sequentially in contiguous memory blocks. Each struct can either be active or inactive. PartitionedBuffer<T>.MaximumSizeException Exception thrown when the buffer's internal indirection table reaches its maximum capacity. Structs JHandle<T> Handle for an unmanaged object stored in a PartitionedBuffer<T>. The handle remains stable even when the underlying memory is resized. MemoryHelper.IsolatedInt Represents an integer value isolated in memory to prevent false sharing between multiple threads operating on adjacent data. MemoryHelper.MemBlock12Real A memory block with a size equivalent to twelve instances of the float type. MemoryHelper.MemBlock16Real A memory block with a size equivalent to sixteen instances of the float type. MemoryHelper.MemBlock6Real A memory block with a size equivalent to six instances of the float type. MemoryHelper.MemBlock9Real A memory block with a size equivalent to nine instances of the float type."
  },
  "api/Jitter2.World.InvalidCollisionTypeException.html": {
    "href": "api/Jitter2.World.InvalidCollisionTypeException.html",
    "title": "Class World.InvalidCollisionTypeException | Jitter2",
    "summary": "Class World.InvalidCollisionTypeException Namespace Jitter2 Assembly Jitter2.dll Thrown when the narrow phase encounters a pair of proxy types it cannot process. public class World.InvalidCollisionTypeException : Exception, ISerializable Inheritance object Exception World.InvalidCollisionTypeException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Remarks This typically indicates that non-RigidBodyShape proxies were inserted into the world's DynamicTree. Use BroadPhaseFilter to filter such pairs, or ensure only supported proxy types are added. Constructors InvalidCollisionTypeException(Type, Type) Thrown when the narrow phase encounters a pair of proxy types it cannot process. public InvalidCollisionTypeException(Type proxyA, Type proxyB) Parameters proxyA Type proxyB Type Remarks This typically indicates that non-RigidBodyShape proxies were inserted into the world's DynamicTree. Use BroadPhaseFilter to filter such pairs, or ensure only supported proxy types are added."
  },
  "api/Jitter2.World.SpanData.html": {
    "href": "api/Jitter2.World.SpanData.html",
    "title": "Struct World.SpanData | Jitter2",
    "summary": "Struct World.SpanData Namespace Jitter2 Assembly Jitter2.dll Provides access to objects in unmanaged memory. This operation is potentially unsafe. public readonly struct World.SpanData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The returned spans are backed by unmanaged memory and are only valid until the next world modification that may resize internal buffers (e.g., creating or removing bodies, constraints, contacts, or calling Step(float, bool)). Do not cache these spans. Not safe to use concurrently with Step(float, bool). Constructors SpanData(World) Provides access to objects in unmanaged memory. This operation is potentially unsafe. public SpanData(World world) Parameters world World Remarks The returned spans are backed by unmanaged memory and are only valid until the next world modification that may resize internal buffers (e.g., creating or removing bodies, constraints, contacts, or calling Step(float, bool)). Do not cache these spans. Not safe to use concurrently with Step(float, bool). Properties ActiveConstraints Span over active constraint data. public Span<ConstraintData> ActiveConstraints { get; } Property Value Span<ConstraintData> ActiveContacts Span over active contact data. public Span<ContactData> ActiveContacts { get; } Property Value Span<ContactData> ActiveRigidBodies Span over active (awake) rigid body data. public Span<RigidBodyData> ActiveRigidBodies { get; } Property Value Span<RigidBodyData> ActiveSmallConstraints Span over active small constraint data. public Span<SmallConstraintData> ActiveSmallConstraints { get; } Property Value Span<SmallConstraintData> Constraints Span over all constraint data (active and inactive). public Span<ConstraintData> Constraints { get; } Property Value Span<ConstraintData> Contacts Span over all contact data (active and inactive). public Span<ContactData> Contacts { get; } Property Value Span<ContactData> InactiveConstraints Span over inactive constraint data. public Span<ConstraintData> InactiveConstraints { get; } Property Value Span<ConstraintData> InactiveContacts Span over inactive contact data. public Span<ContactData> InactiveContacts { get; } Property Value Span<ContactData> InactiveRigidBodies Span over inactive (sleeping) rigid body data. public Span<RigidBodyData> InactiveRigidBodies { get; } Property Value Span<RigidBodyData> InactiveSmallConstraints Span over inactive small constraint data. public Span<SmallConstraintData> InactiveSmallConstraints { get; } Property Value Span<SmallConstraintData> RigidBodies Span over all rigid body data (active and inactive). public Span<RigidBodyData> RigidBodies { get; } Property Value Span<RigidBodyData> SmallConstraints Span over all small constraint data (active and inactive). public Span<SmallConstraintData> SmallConstraints { get; } Property Value Span<SmallConstraintData> TotalBytesAllocated Returns the total amount of unmanaged memory allocated in bytes. public long TotalBytesAllocated { get; } Property Value long"
  },
  "api/Jitter2.World.ThreadModelType.html": {
    "href": "api/Jitter2.World.ThreadModelType.html",
    "title": "Enum World.ThreadModelType | Jitter2",
    "summary": "Enum World.ThreadModelType Namespace Jitter2 Assembly Jitter2.dll Controls how internal worker threads behave between calls to Step(float, bool). public enum World.ThreadModelType Fields Persistent = 1 Worker threads remain active between steps to reduce wake-up latency, at the cost of higher background CPU usage. Regular = 0 Worker threads may yield when the engine is idle. Lower background CPU usage."
  },
  "api/Jitter2.World.Timings.html": {
    "href": "api/Jitter2.World.Timings.html",
    "title": "Enum World.Timings | Jitter2",
    "summary": "Enum World.Timings Namespace Jitter2 Assembly Jitter2.dll Profiling buckets for DebugTimings, representing stages of Step(float, bool). public enum World.Timings Fields AddArbiter = 2 Time spent creating deferred arbiters. BroadPhase = 9 Time spent updating the dynamic tree (broadphase). CheckDeactivation = 4 Time spent evaluating body deactivation (sleeping). Last = 11 Sentinel value for array sizing. Not a real timing bucket. NarrowPhase = 1 Time spent in narrow phase collision detection and contact generation. PostStep = 10 Time spent in PostStep callbacks. PreStep = 0 Time spent in PreStep callbacks. RemoveArbiter = 6 Time spent removing broken arbiters. ReorderContacts = 3 Time spent reordering contacts for cache efficiency. Solve = 5 Time spent in substeps: force integration, constraint solving, and velocity integration. UpdateBodies = 8 Time spent finalizing body state and broadphase proxy updates. UpdateContacts = 7 Time spent updating contact state after solving."
  },
  "api/Jitter2.World.WorldStep.html": {
    "href": "api/Jitter2.World.WorldStep.html",
    "title": "Delegate World.WorldStep | Jitter2",
    "summary": "Delegate World.WorldStep Namespace Jitter2 Assembly Jitter2.dll Delegate for per-step and per-substep callbacks. public delegate void World.WorldStep(float dt) Parameters dt float The duration in seconds: the full step duration for PreStep/PostStep, or the substep duration for PreSubStep/PostSubStep."
  },
  "api/Jitter2.World.html": {
    "href": "api/Jitter2.World.html",
    "title": "Class World | Jitter2",
    "summary": "Class World Namespace Jitter2 Assembly Jitter2.dll Represents a simulation environment that holds and manages the state of all simulation objects. public sealed class World : IDisposable Inheritance object World Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors World() Creates an instance of the World class. public World() Properties AllowDeactivation Specifies whether the deactivation mechanism of Jitter is enabled. Does not activate inactive objects if set to false. public bool AllowDeactivation { get; set; } Property Value bool BroadPhaseFilter Hook into the broadphase collision detection pipeline. The default value is null. public IBroadPhaseFilter? BroadPhaseFilter { get; set; } Property Value IBroadPhaseFilter Remarks Use this to intercept shape pairs before narrowphase detection, implement custom collision layers, or handle collisions for custom proxy types. When Step(float, bool) is called with multiThread=true, this may be invoked concurrently. Implementations must be thread-safe. DebugTimings Contains timings for the stages of the last call to Step(float, bool). Array elements correspond to the values in World.Timings. It can be used to identify bottlenecks. public double[] DebugTimings { get; } Property Value double[] Remarks Values are in milliseconds and are overwritten on each call to Step(float, bool). Index using (int)Timings.XYZ. DynamicTree Access to the DynamicTree instance. The instance should only be modified by Jitter. public DynamicTree DynamicTree { get; } Property Value DynamicTree EnableAuxiliaryContactPoints Enables the generation of additional contacts for flat surfaces that are in contact. Traditionally, the collision system reports the deepest collision point between two objects. A full contact manifold is then generated over several time steps using contact caching, which can be unstable. This method attempts to build a fuller or complete contact manifold within a single time step. public bool EnableAuxiliaryContactPoints { get; set; } Property Value bool Gravity Default gravity, see also AffectedByGravity. public JVector Gravity { get; set; } Property Value JVector Islands All collision islands in this world. public ReadOnlyPartitionedSet<Island> Islands { get; } Property Value ReadOnlyPartitionedSet<Island> NarrowPhaseFilter Hook into the narrowphase collision detection pipeline. The default instance is of type TriangleEdgeCollisionFilter. public INarrowPhaseFilter? NarrowPhaseFilter { get; set; } Property Value INarrowPhaseFilter Remarks Use this to intercept collisions after contact generation, modify contact data, or implement custom collision responses. When Step(float, bool) is called with multiThread=true, this may be invoked concurrently. Implementations must be thread-safe. NullBody A fixed body, pinned to the world. Can be used to create constraints with. public RigidBody NullBody { get; } Property Value RigidBody RawData Grants access to objects residing in unmanaged memory. This operation can be potentially unsafe. Use the corresponding managed properties where possible to mitigate risk. public World.SpanData RawData { get; } Property Value World.SpanData RigidBodies All rigid bodies in this world. public ReadOnlyPartitionedSet<RigidBody> RigidBodies { get; } Property Value ReadOnlyPartitionedSet<RigidBody> SolverIterations Gets or sets the number of iterations per substep for the constraint solver and velocity relaxation. public (int solver, int relaxation) SolverIterations { get; set; } Property Value (int solver, int relaxation) Remarks Higher solver iterations improve constraint accuracy at the cost of performance. Relaxation iterations help reduce velocity errors after solving. Default value: (solver: 6, relaxation: 4). Exceptions ArgumentException Thrown if solver is less than 1 or relaxation is negative. SpeculativeRelaxationFactor A speculative contact slows a body down such that it does not penetrate or tunnel through an obstacle within one frame. The SpeculativeRelaxationFactor scales the slowdown, ranging from 0 (where the body stops immediately during this frame) to 1 (where the body and the obstacle just touch after the next velocity integration). A value below 1 is preferred, as the leftover velocity might be enough to trigger another speculative contact in the next frame. public float SpeculativeRelaxationFactor { get; set; } Property Value float SpeculativeVelocityThreshold Speculative contacts are generated when the velocity towards an obstacle exceeds the threshold value. To prevent bodies with a diameter of D from tunneling through thin walls, this threshold should be set to approximately D / timestep, e.g., 100 for a unit cube and a timestep of 0.01. public float SpeculativeVelocityThreshold { get; set; } Property Value float SubstepCount The number of substeps for each call to Step(float, bool). Sub-stepping is deactivated when set to one. public int SubstepCount { get; set; } Property Value int ThreadModel Defines the two available thread models. The Persistent model keeps the worker threads active continuously, even when the Step(float, bool) is not in operation, which might consume more CPU cycles and possibly affect the performance of other operations such as rendering. However, it ensures that the threads remain 'warm' for the next invocation of Step(float, bool). Conversely, the Regular model allows the worker threads to yield and undertake other tasks. public World.ThreadModelType ThreadModel { get; set; } Property Value World.ThreadModelType Methods Clear() Removes all entities from the simulation world. Also clears all proxies from the dynamic tree, including any user-added proxies not owned by the world. public void Clear() CreateConstraint<T>(RigidBody, RigidBody) Constructs a constraint of the specified type. After creation, initialize the constraint by calling its Initialize method. public T CreateConstraint<T>(RigidBody body1, RigidBody body2) where T : Constraint, new() Parameters body1 RigidBody The first rigid body involved in the constraint. body2 RigidBody The second rigid body involved in the constraint. Returns T A new instance of the specified constraint type, already registered with the world. Type Parameters T The specific type of constraint to create. Exceptions ArgumentException Thrown if body1 and body2 are the same. PartitionedBuffer<T>.MaximumSizeException Raised when the maximum size limit is exceeded. CreateRigidBody() Creates and adds a new rigid body to the simulation world. public RigidBody CreateRigidBody() Returns RigidBody A newly created instance of RigidBody. Exceptions PartitionedBuffer<T>.MaximumSizeException Raised when the maximum size limit is exceeded. DefaultDynamicTreeFilter(IDynamicTreeProxy, IDynamicTreeProxy) Default filter function for the DynamicTree. Returns true if both proxies are of type RigidBodyShape and belong to different RigidBody instances. public static bool DefaultDynamicTreeFilter(IDynamicTreeProxy proxyA, IDynamicTreeProxy proxyB) Parameters proxyA IDynamicTreeProxy proxyB IDynamicTreeProxy Returns bool Dispose() Releases all unmanaged memory buffers used by this simulation world. public void Dispose() Remarks After disposal, the world instance is unusable. All bodies, constraints, and contacts become invalid. GetArbiter(ulong, ulong, out Arbiter) Retrieves an existing Arbiter instance for the given pair of IDs. public bool GetArbiter(ulong id0, ulong id1, out Arbiter arbiter) Parameters id0 ulong The first identifier (e.g., shape ID). id1 ulong The second identifier. arbiter Arbiter When this method returns true, contains the arbiter; otherwise, null. Returns bool true if an arbiter exists for the ordered ID pair; otherwise, false. Remarks The order of id0 and id1 matters. For arbiters created by the engine, id0 < id1 holds for RigidBodyShapes. GetOrCreateArbiter(ulong, ulong, RigidBody, RigidBody, out Arbiter) Retrieves an existing Arbiter instance for the given pair of IDs, or creates a new one if none exists. public void GetOrCreateArbiter(ulong id0, ulong id1, RigidBody body1, RigidBody body2, out Arbiter arbiter) Parameters id0 ulong The first identifier associated with the contact (e.g., shape or feature ID). id1 ulong The second identifier associated with the contact. body1 RigidBody The first rigid body. Used only if a new arbiter is created. body2 RigidBody The second rigid body. Used only if a new arbiter is created. arbiter Arbiter The resulting Arbiter instance associated with the ID pair. Remarks This method ensures there is a unique Arbiter for each ordered pair of IDs. If an arbiter already exists, it is returned via the arbiter out parameter. Otherwise, a new arbiter is allocated, initialized with the provided body1 and body2, and registered internally. The body arguments are used only when a new arbiter is created. This method is thread-safe. Note: The order of id0 and id1 does matter. LockTwoBody(ref RigidBodyData, ref RigidBodyData) Acquires locks on two rigid bodies using a spin-wait loop. The lock order is determined by memory address to prevent deadlocks. public static void LockTwoBody(ref RigidBodyData b1, ref RigidBodyData b2) Parameters b1 RigidBodyData Reference to the first rigid body data. b2 RigidBodyData Reference to the second rigid body data. RegisterContact(Arbiter, in JVector, in JVector, in JVector, SolveMode) Registers a single contact point into an existing Arbiter. public void RegisterContact(Arbiter arbiter, in JVector point1, in JVector point2, in JVector normal, ContactData.SolveMode removeFlags = SolveMode.None) Parameters arbiter Arbiter The existing Arbiter instance to which the contact will be added. point1 JVector The contact point on the first body, in world space. point2 JVector The contact point on the second body, in world space. normal JVector The contact normal, in world space. Must be normalized. removeFlags ContactData.SolveMode A bitmask of ContactData.SolveMode flags to be removed from the full contact solution (see Full). Remarks This method adds a contact point to the specified arbiter, using the provided contact points and normal. All input vectors must be in world space. The normal vector must be normalized. This method assumes that the arbiter is already valid and mapped to the correct pair of bodies. RegisterContact(ulong, ulong, RigidBody, RigidBody, in JVector, ref CollisionManifold, SolveMode) Registers one or more contact points between two rigid bodies using a CollisionManifold, creating an Arbiter if one does not already exist. public void RegisterContact(ulong id0, ulong id1, RigidBody body1, RigidBody body2, in JVector normal, ref CollisionManifold manifold, ContactData.SolveMode removeFlags = SolveMode.None) Parameters id0 ulong The first identifier associated with the contact (e.g., shape or feature ID). id1 ulong The second identifier associated with the contact. body1 RigidBody The first rigid body involved in the contact. body2 RigidBody The second rigid body involved in the contact. normal JVector The contact normal, in world space. Must be a unit vector pointing from body1 toward body2. manifold CollisionManifold A CollisionManifold containing contact point pairs in world space. removeFlags ContactData.SolveMode A bitmask of ContactData.SolveMode flags to be removed from the full contact solution (see Full). Remarks This method ensures that contact information between the specified ID pair is tracked by an Arbiter. If no arbiter exists for the given IDs, one is created using body1 and body2. This method is thread-safe. Note: The order of id0 and id1 does matter. RegisterContact(ulong, ulong, RigidBody, RigidBody, in JVector, in JVector, in JVector, SolveMode) Registers a contact point between two rigid bodies, creating an Arbiter if one does not already exist. public void RegisterContact(ulong id0, ulong id1, RigidBody body1, RigidBody body2, in JVector point1, in JVector point2, in JVector normal, ContactData.SolveMode removeFlags = SolveMode.None) Parameters id0 ulong The first identifier associated with the contact (e.g., shape or feature ID). id1 ulong The second identifier associated with the contact. body1 RigidBody The first rigid body involved in the contact. body2 RigidBody The second rigid body involved in the contact. point1 JVector The contact point on body1, in world space. point2 JVector The contact point on body2, in world space. normal JVector The contact normal, in world space. Must be a unit vector pointing from body1 toward body2. removeFlags ContactData.SolveMode A bitmask of ContactData.SolveMode flags to be removed from the full contact solution (see Full). Remarks This method ensures that contact information between the specified ID pair is tracked by an Arbiter. If no arbiter exists for the given IDs, one is created using body1 and body2. The provided contact points and normal must be in world space. The normal vector must be normalized. This method is thread-safe. Note: The order of id0 and id1 does matter. Remove(Arbiter) Removes a particular arbiter from the world. public void Remove(Arbiter arbiter) Parameters arbiter Arbiter Remove(Constraint) Removes a specific constraint from the world. For temporary deactivation of constraints, consider using the IsEnabled property. public void Remove(Constraint constraint) Parameters constraint Constraint The constraint to be removed. Remove(RigidBody) Removes the specified body from the world. This operation also automatically discards any associated contacts and constraints. public void Remove(RigidBody body) Parameters body RigidBody The rigid body to remove. RequestId() Generates a unique ID. public static ulong RequestId() Returns ulong A monotonically increasing unique identifier. RequestId(int) Generates a range of unique IDs. public static (ulong min, ulong max) RequestId(int count) Parameters count int The number of IDs to generate. Returns (ulong min, ulong max) A tuple containing the minimum and maximum request IDs in the generated range. The upper bound is exclusive. Exceptions ArgumentOutOfRangeException Thrown when count is less than 1. Step(float, bool) Performs a single simulation step. public void Step(float dt, bool multiThread = true) Parameters dt float The duration of time to simulate in seconds. Should remain fixed and typically not exceed 1/60 s. multiThread bool If true, uses the internal thread pool for parallel execution. Set to false for single-threaded execution (useful for debugging or platforms without threading). Remarks The step is divided into SubstepCount substeps for improved stability. Callbacks (PreStep, PostStep, etc.) are invoked on the calling thread. When multiThread is true, BroadPhaseFilter and NarrowPhaseFilter may be called concurrently from worker threads. Exceptions ArgumentException Thrown if dt is negative. TryLockTwoBody(ref RigidBodyData, ref RigidBodyData) Attempts to lock two rigid bodies. Briefly waits on contention, then backs off if unsuccessful. The lock order is determined by memory address to prevent deadlocks. public static bool TryLockTwoBody(ref RigidBodyData b1, ref RigidBodyData b2) Parameters b1 RigidBodyData Reference to the first rigid body data. b2 RigidBodyData Reference to the second rigid body data. Returns bool true if both locks were acquired; otherwise, false. UnlockTwoBody(ref RigidBodyData, ref RigidBodyData) Releases locks on two rigid bodies previously acquired by LockTwoBody(ref RigidBodyData, ref RigidBodyData) or TryLockTwoBody(ref RigidBodyData, ref RigidBodyData). public static void UnlockTwoBody(ref RigidBodyData b1, ref RigidBodyData b2) Parameters b1 RigidBodyData Reference to the first rigid body data. b2 RigidBodyData Reference to the second rigid body data. Events PostStep Raised at the end of a simulation step, after all substeps, collision handling, and integration have completed. [CallbackThread(ThreadContext.MainThread)] public event World.WorldStep? PostStep Event Type World.WorldStep Remarks This event is invoked once per call to Step(float, bool) and receives the full step time dt. At this point, all body states represent the final results of the step. PostSubStep Raised at the end of each substep during a simulation step. [CallbackThread(ThreadContext.MainThread)] public event World.WorldStep? PostSubStep Event Type World.WorldStep Remarks This event is invoked once per substep and receives the substep duration. It is called after integration and constraint solving for the substep have completed. PreStep Raised at the beginning of a simulation step, before any collision detection, constraint solving, or integration is performed. [CallbackThread(ThreadContext.MainThread)] public event World.WorldStep? PreStep Event Type World.WorldStep Remarks This event is invoked once per call to Step(float, bool) and receives the full step time dt. It can be used to apply external forces, modify bodies, or gather per-step diagnostics before the simulation advances. PreSubStep Raised at the beginning of each substep during a simulation step. [CallbackThread(ThreadContext.MainThread)] public event World.WorldStep? PreSubStep Event Type World.WorldStep Remarks A simulation step may be divided into multiple substeps for stability. This event is invoked once per substep and receives the substep duration (dt / substepCount). It is called immediately before force integration and constraint solving for the substep."
  },
  "api/Jitter2.html": {
    "href": "api/Jitter2.html",
    "title": "Namespace Jitter2 | Jitter2",
    "summary": "Namespace Jitter2 Classes CallbackThreadAttribute Indicates the thread context in which a callback or event is expected to be invoked. This attribute is primarily informational and used for documentation purposes. Logger Provides logging functionality. Precision Provides constants and utilities related to floating-point precision configuration. The library can be compiled with single-precision (float) or double-precision (double) by defining the USE_DOUBLE_PRECISION symbol. ReferenceFrameAttribute Attribute to specify the reference frame of a member. World Represents a simulation environment that holds and manages the state of all simulation objects. World.InvalidCollisionTypeException Thrown when the narrow phase encounters a pair of proxy types it cannot process. Structs World.SpanData Provides access to objects in unmanaged memory. This operation is potentially unsafe. Interfaces IDebugDrawable Defines an interface for objects that can be debug-drawn. IDebugDrawer Defines an interface for drawing debug visualization elements. Enums Logger.LogLevel Defines the severity levels for logging messages. ReferenceFrame Enum representing reference frames. ThreadContext Specifies the threading context in which code executes or a callback is invoked. World.ThreadModelType Controls how internal worker threads behave between calls to Step(float, bool). World.Timings Profiling buckets for DebugTimings, representing stages of Step(float, bool). Delegates World.WorldStep Delegate for per-step and per-substep callbacks."
  },
  "docs/changelog.html": {
    "href": "docs/changelog.html",
    "title": "Changelog | Jitter2",
    "summary": "Changelog Jitter 2.7.8 (2026-01-18) Fixed degraded tree quality for large proxies in DynamicTree. Added JQuaternion.Lerp, JQuaternion.Slerp, JQuaternion.Dot, and JQuaternion.Inverse methods for quaternion interpolation and math. Added JTriangle.GetCenter, JTriangle.GetNormal, JTriangle.GetArea, JTriangle.GetBoundingBox, and JTriangle.ClosestPoint helper methods. Added JBoundingBox.Disjoint and JBoundingBox.Contains methods (also in TreeBox). Added World.GetArbiter(id0, id1) to retrieve existing arbiters without creating new ones. Improved XML documentation throughout the codebase. Fixed CalculateMassInertia in TransformedShape returning incorrect values. Fixed normalization bug in TriangleEdgeCollisionFilter. Fixed validation in SphereShape radius setter. Fixed a bug in speculative contact implementation. Improved TriangleMesh. Added option to build directly from vertices and indices. Added overloads for Span throughout the engine (in TriangleMesh, ShapeHelper, PointCloudShape, ConvexHullShape). Jitter 2.7.7 (2026-01-08) Added vector.UnsafeAs<T> and JVector.UnsafeFrom<T>. Same for JQuaternion. Added world.PreSubStep and world.PostSubStep events. Jitter 2.7.6 (2025-12-18) Removed World.Capacity. Number of entities in World no longer has to be specified in advance. Fixed a bug in TwistAngle. Added WeldJoint. Exposed more properties in ConeLimit. Jitter 2.7.5 (2025-11-16) Improved cost heuristic for DynamicTree. Jitter 2.7.4 (2025-10-29) Add MotionType property to RigidBody instances. Bodies might me Dynamic, Static or Kinematic. Static bodies with non-zero velocity are no longer supported, kinematic bodies must be used instead. The contact graph information is used to optimize the memory layout for contacts (ReorderContacts step). This makes the solver more cache friendly. Reduced overhead of CheckDeactivation step in the engine. Jitter 2.7.3 (2025-10-19) Improved multi-threading performance. Jitter 2.7.2 (2025-09-21) Reduced GC in DynamicTree.Optimize. Default to LocalRayCast if body is not set for RigidBodyShape. Added wakeup parameter to AddForce overloads for finer activation state control. Added generic ICloneableShape<T> interface for type-safe shape cloning. Jitter 2.7.1 (2025-06-28) Added RigidBody.EnableGyroscopicForces to include gyroscopic forces. Jitter 2.7.0 (2025-06-14) Dropped .NET7 support Added JQuaternion.ToAxisAngle method Renamed JBBox to JBoundingBoxand TreeBBox to TreeBox. Various smaller API changes. Jitter 2.6.7 (2025-06-09) Introduced SIMD accelerated TreeBBox for DynamicTree. Jitter 2.6.6 (2025-05-31) Implicit conversion for JVector and JQuaternion from tuples, e.g. cube.Position = (1, 2, 3);. Added PreStep and PostStep to World.Timings. Added NarrowPhase.Sweep overload which calculates time of impact (TOI) for rotating shapes. RegisterContact no longer requires a penetration and a speculative parameter. Bugfix: MathHelper.RotationQuaternion, fixed wrong/not normalized quaternion generation for large dt. Added an additional normal out-parameter to NarrowPhase.Distance. Renamed JVector.TransposedTransform(in JVector vector, in JQuaternion quat) to ConjugatedTransform. Added Anchor1 and Anchor2 properties to BallSocket. Bugfix: Skipping degenerate triangles in TriangleMesh now works correctly. Jitter 2.6.5 (2025-05-21) Rigid bodies now activate on velocity or force changes. Removed FatTriangleShape. Renamed 'Active' to 'ActiveCount' and add span-based accessors in ReadOnlyPartitionedSet. Fixed bug in TriangleEdgeCollisionFilter. Jitter 2.6.4 (2025-05-19) Breaking Change: Triangle winding order in TriangleMesh is now counter-clockwise (CCW) for front-facing triangles. If you're using TriangleMesh, swap the vertex order to maintain correct normal orientation. Added JTriangle.RayIntersect method. Renamed ConvexHullIntersection to CollisionManifold. Modified support function for BoxShape. Jitter 2.6.3 (2025-05-17) Aligned rigid bodies (RigidBodyData) to a 64-byte boundary (reduce false sharing). Bugfix in speculative contacts. Jitter 2.6.2 (2025-05-06) Use Generics in NarrowPhase.cs (avoid boxing for structs implementing the ISupportMappable interface). Added special code paths in Contact.cs for static bodies (avoid unnecessary cache line invalidation). Added PredictPosition, PredictOrientation and PredictPose to RigidBody. Added CreateFromAxisAngle and Normalize methods in JQuaternion. Jitter 2.6.1 (2025-04-24) Bugfix in TriangleEdgeCollisionFilter for speculative contacts. Jitter 2.6.0 (2025-04-24) Added SampleHull and MakeHull to ShapeHelper. Fixed hill climbing getting stuck for ConvexHullShapes. Added SIMD support for PointCloudShapes. Added option to ignore degenerated triangles in TriangleMesh. Made thickness parameter mandatory in FatTriangleShape. Added Fisher-Yates shuffle to DynamicTree.Optimize. Optimized TriangleEdgeCollisionFilter. Jitter 2.5.9 (2025-04-17) Use CollideEpsilon 1e-5 in MPREPA. Fixed a bug in ShardedDictionary. Jitter 2.5.8 (2025-04-16) Fixed DynamicTree.Optimize messing up collision pairs. Refactored SoftBody.cs Improved TriangleEdgeCollisionFilter. Further reduced GC. Jitter 2.5.7 (2025-04-06) Fixed possible crash when dynamically making bodies static. Improved memory footprint and reduced GC. Added Logger as a replacement for Trace. Jitter 2.5.6 (2025-03-08) Fixed concurrency bug in world.GetArbiter. Jitter 2.5.5 (2025-03-02) Added implicit conversion operators for System.Numerics Vector3 and Quaternion. Replaced Trace.WriteLine with Trace.Information, Warning, Error. Jitter 2.5.4 (2025-02-08) Renamed JAngle.Radiant to JAngle.Radian. Renamed namespace Jitter2.UnmanagedMemory to Jitter2.Unmanaged. Fixed body.AddShape(IEnumerable<RigidBodyShape> shapes) for one-time-use iterators. Smaller improvements in XML-documentation. Jitter 2.5.3 (2025-01-12) DynamicTree, Optimize takes a delegate now. Fixed TriangleShape ray cast not returning a normalized normal. Removed the CollisionHelper class. Renamed ActiveList and UnmanagedActiveList to PartitionedSet and PartitionedBuffer, respectively. Various smaller improvements (ToString() overloads, IEquality<T> implementations, XML-documentation) Jitter 2.5.2 (2025-01-08) Added enumeration method to DynamicTree and made PairHashSet internal. Breaking Change: Removed UseFullEPASolver option. Further improved simulation performance under high lock contention scenarios. Jitter 2.5.1 (2024-12-31) Bugfix in PairHashSet. Jitter 2.5.0 (2024-12-23) Better utilization of multi core systems. Bugfix in collision detection (possible NaN values). Jitter 2.4.9 (2024-12-18) Huge improvements for the DynamicTree implementation. Jitter 2.4.8 (2024-11-27) Add option to build in double precision mode. Made Constraint constructor public to allow for custom constraints. Jitter 2.4.7 (2024-11-18) Breaking Change: Dropped .NET6 support, added .NET9. SIMD for contacts. Contact manifold overflow fix. Changed default damping. Improved auxiliary contact points. Minor API changes. Jitter 2.4.6 (2024-10-28) Breaking Change: Jitter world is now constructed using World.Capacity. Breaking Change: World.RayCast moved to World.DynamicTree.RayCast. Breaking Change: Renamed NumberSubsteps to SubstepCount. Added split impulses. Breaking Change: SolverIterations property is now a tuple. Several smaller improvements in the API. Jitter 2.4.5 (2024-10-07) Added new methods to NarrowPhase: Distance and Overlap. Breaking Change: Renamed NarrowPhase.SweepTest to NarrowPhase.Sweep. Breaking Change: Renamed NarrowPhase.GJKEPA to NarrowPhase.Collision. Made PointTest, Raycast and SweepTest to use new SimplexSolver and SimplexSolverAB implementations. Fixed normal in GJKEPA for separating case. Jitter 2.4.4 (2024-09-14) Implemented fixes and workarounds for using Jitter with a debugger attached. Jitter 2.4.3 (2024-08-31) Correct corner case beeing wrong in MPR collision detection due to typo (bug fix). FatTriangleShape level did not properly take transformations into account (bug fix). Jitter 2.4.2 (2024-08-26) Added FatTriangleShape to give triangles thickness which can be useful for static triangle meshes. Removal from potential pairs in DynamicTree ignores filters from now on (bug fix). Use sweep tests for speculative contacts, vastly improving simulation quality in this scenario. Breaking Change: Redefinition of NarrowPhase.SweepTest results. Improved TriangleEdgeCollisionFilter. Jitter 2.4.1 (2024-08-21) Improved TriangleEdgeCollisionFilter. Implemented analytical box and sphere ray casting. Made Restitution and Friction public in Contact. Improved DynamicTree interface. Added Debug.Asserts in ActiveList. Marked ArbiterKey as readonly. Added enumerator to PairHashSet. Changed ShapeHelper.MakeHull to take a generic of type ICollection. Jitter 2.4.0 (2024-08-10) Improved TrimPotentialPairs logic. Optimized quaternion vector transformation. Extended functionality of ContactData.UsageMask. Breaking Change: Overhauled the shape system. Regular shapes (box, sphere, capsule, ...) now derive from RigidBodyShape. Some method signatures changed slightly, e.g. ray casting. Improved exceptions. Added ReferenceFrameAttribute. Jitter 2.3.1 (2024-06-02) ReadOnly wrappers (ReadOnlyList, ReadOnlyHashset) are now structs. Shapes with very small dimensions might have close to zero or zero mass/inertia. Creating rigid bodies from them now throws an exception (use body.AddShape(shape, setMassInertia: false) to not use the shape's mass properties). Added BeginCollide and EndCollide events per body. Jitter 2.3.0 (2024-05-20) Added RigidBody.RemoveShape overload to remove multiple shapes at once. Marked Rigid.ClearShapes deprecated. Breaking Change: Use JQuaternion for orientations. Sorry for the API break. Jitter 2.2.1 (2024-04-29) Add optional activate parameter to world.AddShape. Add NarrowPhase.SweepTest. EPA collision detection: various improvements. Improve exit condition for RayCast and PointTest. Remove redundant ArgumentException for zero mass shapes. Handle zero time steps. Throw ArgumentException for negative time steps. Add joint base class to joint classes. Jitter 2.2.0 (2024-01-02) Breaking Change: Renamed Raycast to RayCast. world.Remove(world.NullBody) does now remove all shapes, constraints and contacts associated with NullBody. world.AddShape(shape) respects the activation state of the associated rigid body. Most notable: performance improvement when directly adding TriangleShapes to world.NullBody for static geometry. Performance improvements for ConvexHullShape. Improved termination condition in GJKEPA collision detection. Jitter 2.1.1 (2023-12-17) Fixed O(n^2) problem in TriangleMesh due to hash collisions. WorldBoundingBox of Shape is now updated even if no RigidBody is attached. Jitter 2.1.0 (2023-12-10) Added debug drawing for rigid bodies (RigidBody.DebugDraw). Fixed a bug in CalculateMassInertia within TransformedShape.cs. Improved ray casting performance and introduced NarrowPhase.PointTest. Breaking Change: Inverted behavior of BroadPhaseCollisionFilter. Breaking Change: Inverted definition of damping factors in RigidBody.Damping (0 = no damping, 1 = immediate halt). Added RigidBody.SetMassInertia overload to enable setting the inverse inertia to zero. An exception is now thrown when a body's mass is set to zero. Fixed a bug in the friction handling in Contact.cs. Jitter 2.0.1 (2023-10-28) Fixed a bug in contact initialization which affected soft body physics. Jitter 2.0.0 (2023-10-22) Initial stable Release."
  },
  "docs/documentation/bodies.html": {
    "href": "docs/documentation/bodies.html",
    "title": "Rigid Bodies | Jitter2",
    "summary": "Rigid Bodies Rigid bodies represent the main entity of the dynamics system of the engine. Creating a body Rigid bodies are associated to an instance of the World class. They can be created like this: var world = new World(); var body = world.CreateRigidBody(); Adding shapes Multiple shapes can be added to a rigid body, for example: body.AddShape([new SphereShape(radius: 2), new BoxShape(size: 1)]); Shapes determine how bodies collide with each other. Warning Creating many bodies at once When calling body.AddShape(shape), the shape is registered in the collision system of the engine and immediately added to the spatial tree structure (DynamicTree) for efficient broad-phase collision detection. Registering many objects at \\((0, 0, 0)\\) must be prevented by specifying the rigid body position, before adding shapes. Warning Passing the same instance to multiple bodies Passing the same instance of a shape to multiple bodies is not allowed in Jitter and will throw an exception. In Jitter, the sphere shape is defined so that its geometric center aligns with the (local) coordinate system's center at \\((0, 0, 0)\\). The same holds for all basic primitives (sphere, box, capsule, cone, cylinder). After adding a shape to Jitter the mass properties (mass and inertia) of the associated rigid body are calculated accordingly. Jitter assumes unit density for the calculations. Adding just a sphere body.AddShape(new SphereShape(radius: 1)); will result in a body with the textbook inertia and mass of a unit-density sphere of radius one. Of course, the mass properties of the body can be set directly, using body.SetMassInertia. Setting setMassProperties: false in body.AddShape(...) prevents Jitter from using the shapes' mass properties. In Jitter the position of the rigid body has to align with the center of mass. So in the local reference frame of the body, the center of mass is \\((0, 0, 0)\\). Shapes or combinations of shapes must be translated accordingly. Debugging shapes The RigidBody class offers the body.DebugDraw(IDebugDrawer drawer) method which creates a triangle hull for each shape added to the body and calls the drawer.DrawTriangle method in the provided IDebugDrawer implementation. The coordinates of the triangles are in world space and can be drawn to debug the collision shape of the rigid body. Warning body.DebugDraw performance Every call to body.DebugDraw the triangle hulls are generated on the fly. Since this is a slow operation the method should only be called for debugging purposes. Gravity The gravity for the world can be set using world.Gravity. The property body.AffectedByGravity can be used to disable gravity for individual bodies. Damping Jitter uses a very simple damping system to slow rigid bodies down. This improves simulation stability and also resembles mechanical systems 'losing' energy in the real world. In Jitter there is a linear and an angular damping factor for each body which can be set using body.Damping. With each world.Step, Jitter multiplies the angular and linear velocity of each rigid body by \\(1-\\gamma\\), where \\(\\gamma\\) is the damping factor. For performance reasons there is no time dependency for the damping system. As a result, bodies in a simulation with smaller timesteps experience greater damping. Speculative contacts Speculative contacts can be utilized to prevent fast and small objects from tunneling through thin objects. An object moving quickly enough might 'miss' a collision since the distance traveled between two frames exceeds the thickness of another object. Speculative contacts can be enabled on a per-body basis using body.EnableSpeculativeContacts. The world.SpeculativeRelaxationFactor and world.SpeculativeVelocityThreshold can be adjusted to fine-tune speculative contacts for specific use cases. However, it should be noted that an accurate simulation of fast-moving objects is only possible using smaller time steps. Speculative contacts may involve a trade-off of less accurate collision detection and response. Friction and Restitution Friction and restitution coefficients may be set through body.Friction and body.Restitution. For a collision of two bodies with different coefficients the maximum value of each body is taken. Collide events An instance of RigidBody provides two events: BeginCollide and EndCollide. These events are triggered whenever an arbiter (Contact) is created or removed which involves the rigid body. By default, arbiters are created between colliding shapes. For example, the BeginCollide event can be used to modify the coefficient of friction of a contact: body.BeginCollide += BodyOnBeginCollide; private void BodyOnBeginCollide(Arbiter arb) { arb.Handle.Data.Friction = 0.0f; } Activation/Deactivation A rigid body is always assigned to an island. Islands are formed by bodies which are pairwise interacting with each other trough contacts or constraints. Different islands are not interacting with each other in any way. Active rigid bodies may be marked for deactivation by the world once their angular and linear velocity remain below the thresholds defined in body.DeactivationThreshold for a period defined by body.DeactivationTime. If all bodies within an island are marked for deactivation the whole island gets deactivated. The simulation cost for inactive bodies is effectively zero. Islands (and their associated bodies) might get waken up, as soon as a collision with an active body is registered. Using body.SetActivationState, the user can reset the internal deactivation time clock for the rigid body. It will not immediately change the activation state of the body (body.IsActive). Jitter will then in the next world.Step consider this body and it's connected island for activation or deactivation. Calling e.g. body.SetActivationState(false) on a falling body with a velocity greater than body.DeactivationThreshold will have no effect. Static bodies Static bodies (body.BodyType == BodyType.Static) have infinite mass and therefore are not affected by collisions or constraints. They also do not join islands. Static bodies do not generate collisions with other static or inactive bodies. Because of this, the position of static bodies should not be altered while in contact with other bodies. Kinematic bodies In Jitter kinematic bodies (body.BodyType == BodyType.Kinematic) are bodies which can have a velocity and therefore change their position. They act similar to static bodies during collisions - their velocity is not changed when colliding with a regular body. They do take part in collision islands. Caution Kinematic bodies Having an unstoppable object colliding with a static (immovable object) or another unstoppable object might crash the solver. It must be ensured that no contact points are generated in such cases."
  },
  "docs/documentation/constraints.html": {
    "href": "docs/documentation/constraints.html",
    "title": "Constraints | Jitter2",
    "summary": "Constraints Constraints constraint various degrees of freedom of rigid bodies. In Jitter, constraints always act between two bodies. A joint is a collection of multiple constraints, so it may act on multiple bodies. Default constraints Default constraints available are: AngularMotor, BallSocket, ConeLimit, DistanceLimit, FixedAngle, HingeAngle, LinearMotor, PointOnLine, PointOnPlane, TwistAngle, SpringConstraint Available joints: HingeJoint, PrismaticJoint, UniversalJoint, Weld Creating constraints Similar to rigid bodies but unlike shapes, constraints are instantiated through a create method in the world class: var constraint = world.CreateConstraint<ConstraintType>(body1, body2); Jitter allocates and assigns unmanaged memory to constraints internally, allowing them to be used like regular classes. The solver interacts with unmanaged memory structures of type ConstraintData (256 bytes) or SmallConstraintData (128 bytes), depending on whether constraint.IsSmallConstraint is set. Small constraints are designed for simpler constraints with a smaller memory footprint, such as spring constraints for soft bodies. Caution Constraint Initialization For all default constraints in Jitter, constraint.Initialize must be called once after world.CreateConstraint. Example: Hinge joint A swinging door may be implemented by a combination of two constraints: A HingeAngle constraint which removes two degrees of angular freedom (i.e. the bodies can only rotate around a single axis), and a BallSocket constraint removing all three degrees of freedom (there is no translation possible): var hingeAngle = world.CreateConstraint<HingeAngle>(body1, body2); hingeAngle.Initialize(hingeAxis, AngularLimit.Full); var ballSocket = world.CreateConstraint<BallSocket>(body1, body2); ballSocket.Initialize(hingeCenter); Alternatively the HingeJoint might be used for convenience: var hinge = new HingeJoint(world, body1, body2, hingeCenter, hingeAxis); Fixed constraints To constrain a rigid body relative to world space, use world.NullBody as one of the bodies. For example, to keep a capsule upright, a constraint can be set up as follows: var upright = world.CreateConstraint<HingeAngle>(capsule, world.NullBody); upright.Initialize(JVector.UnitY, AngularLimit.Full); Softness and Bias For most constraints a softness and bias value can be set. These values define how strict the constraint limits are enforced. Softer constraints might improve simulation stability but do not fully enforce the constraint limits. The softness and bias parameters can be tweaked for optimal results. Better constraint behaviour can also be archived by sub-stepping, see world.Step. Enable/Disable constraints Constraints can be temporarily enabled or disables using constraint.IsEnabled."
  },
  "docs/documentation/dynamictree.html": {
    "href": "docs/documentation/dynamictree.html",
    "title": "Dynamic tree | Jitter2",
    "summary": "Dynamic tree The dynamic tree in Jitter holds instances which implement the IDynamicTreeProxy interface. The main task of the tree is to efficiently determine if a proxy's axis-aligned bounding box is overlapping with the axis-aligned bounding box of any other proxy in the world. In a naive implementation this requires \\(\\mathcal{O}\\left(n\\right)\\) operations (checking for an overlap with every of the \\(n-1\\) entities). The tree structure does accelerate this to \\(\\mathcal{O}\\left(\\mathrm{log}(n)\\right)\\). Since proxies are dynamic and can move, the tree must be continuously updated. To less frequently trigger updates, entities are enclosed within slightly larger bounding boxes than their actual size. This bounding box extension is defined by the Velocity property of the IDynamicTreeProxy interface. Adding proxies Jitter automatically registers all shapes added to a rigid body (body.AddShape) with the world.DynamicTree. However, users are free to add own implementations of IDynamicTreeProxy to the world's tree, using tree.AddProxy. In this case the user has to implement a BroadPhaseFilter and register it (using world.BroadPhaseFilter) to handle any collisions with the custom proxy, otherwise an InvalidCollisionTypeException is thrown. Enumerate Overlaps The tree implementation in Jitter needs to be updated using tree.Update. This is done automatically for the dynamic tree owned by the world class (world.DynamicTree). Internally UpdateWorldBoundingBox is called for the active proxies implementing the IUpdatableBoundingBox interface and the internal book-keeping of overlapping pairs is updated. Overlaps may be queried using tree.EnumerateOverlaps. Querying the tree All tree proxies that overlap a given axis aligned box can be queried public void Query<T>(T hits, in JBBox box) where T : ICollection<IDynamicTreeProxy> as well as all proxies which overlap with a ray public void Query<T>(T hits, JVector rayOrigin, JVector rayDirection) where T : ICollection<IDynamicTreeProxy> Custom queries can easily be implemented. An implementation which queries all proxies which have an overlap with a single point can be implemented like this: var stack = new Stack<int>(); stack.Push(tree.Root); while (stack.TryPop(out int id)) { ref DynamicTree.Node node = ref tree.Nodes[id]; if (node.ExpandedBox.Contains(point)) { if (node.IsLeaf) { Console.WriteLine($'{node.Proxy} contains {point}.'); } else { stack.Push(node.Left); stack.Push(node.Right); } } } Ray casting All proxies in the tree which implement the IRayCastable interface can be raycasted. This includes all shapes: public bool RayCast(JVector origin, JVector direction, RayCastFilterPre? pre, RayCastFilterPost? post, out IDynamicTreeProxy? proxy, out JVector normal, out float lambda) The pre- and post-filters can be used to discard hits during the ray cast. Jitter shoots a ray from the origin into the specified direction. The function returns true if a hit was found. It also reports the point of collision which is given by $$$ \\mathbf{hit} = \\mathbf{origin} + \\lambda{},\\times,\\mathbf{direction}, \\quad \\textrm{with} \\quad \\lambda \\in [0,\\infty). $$$ The returned normal is the normalized surface normal at the hit point."
  },
  "docs/documentation/filters.html": {
    "href": "docs/documentation/filters.html",
    "title": "Collision Filters | Jitter2",
    "summary": "Collision Filters There are three types of collision filters in Jitter: world.DynamicTree.Filter, world.BroadPhaseFilter and world.NarrowPhaseFilter. Dynamic tree filter The world.DynamicTree.Filter public Func<IDynamicTreeProxy, IDynamicTreeProxy, bool> Filter { get; set; } is the earliest filter applied during a world.Step and set by default to World.DefaultDynamicTreeFilter: public static bool DefaultDynamicTreeFilter(IDynamicTreeProxy proxyA, IDynamicTreeProxy proxyB) { if (proxyA is RigidBodyShape rbsA && proxyB is RigidBodyShape rbsB) { return rbsA.RigidBody != rbsB.RigidBody; } return true; } This filters out collisions between shapes that belong to the same body. The dynamic tree will ignore these collisions, and no potential pairs will be created. For soft bodies, another collision filter is typically used (defined in SoftBodies.DynamicTreeCollisionFilter.Filter), which also filters out collisions between shapes belonging to the same soft body. Broad phase filter By default world.BroadPhaseFilter public IBroadPhaseFilter? BroadPhaseFilter { get; set; } is null. It is used to filter out collisions that passed broad phase collision detection - that is, after the DynamicTree has added the collision to the PotentialPair hash set. This can be useful if custom collision proxies got added to world.DynamicTree. Since the Jitter world only knows how to handle collisions between RigidBodyShapes, a filter must handle the detected collision (i.e. implement custom collision response code and filter out the collision) such that no InvalidCollisionTypeException is thrown. Jitter's soft body implementation is based on this kind of filter (see SoftBodies.BroadPhaseCollisionFilter). Example: Collision groups Collision groups might be easily implemented using a broad phase filter. In this example, there are two 'teams', team blue and team red. A filter that disregards all collisions between team members (rigid bodies) of different colors is implemented: public class TeamFilter : IBroadPhaseFilter { public class TeamMember { } public static TeamMember TeamRed = new(); public static TeamMember TeamBlue = new(); public bool Filter(Shape shapeA, Shape shapeB) { if (shapeA.RigidBody.Tag is not TeamMember || shapeB.RigidBody.Tag is not TeamMember) { // Handle collision normally if at least one body is not a member of any team return true; } // There is no collision between team red and team blue. return shapeA.RigidBody.Tag == shapeB.RigidBody.Tag; } } The TeamFilter class can then be instantiated and assigned to world.BroadPhaseFilter, ensuring that rigid bodies of different colors will not interact: world.BroadPhaseFilter = new TeamFilter(); ... bodyA.Tag = TeamFilter.TeamBlue; bodyB.Tag = TeamFilter.TeamRed; bodyC.Tag = TeamFilter.TeamRed; Narrow phase filter The world.NarrowPhaseFilter public INarrowPhaseFilter? NarrowPhaseFilter { get; set; } operates similarly. However, this callback is called after narrow phase collision detection, meaning detailed collision information (such as normal, penetration depth, and collision points) is available at this stage. The filter can not only exclude collisions but also modify collision information. The default narrow phase collision filter in Jitter is assigned to an instance of TriangleEdgeCollisionFilter, which filters out so-called 'internal edges' for TriangleShapes. These internal edges typically cause collision artifacts when rigid bodies slide over the edges of connected triangles forming static geometry. In the literature, this problem is also known as 'ghost collisions'."
  },
  "docs/documentation/shapes.html": {
    "href": "docs/documentation/shapes.html",
    "title": "Shapes | Jitter2",
    "summary": "Shapes Shapes in Jitter define how the rigid body collides with other objects. Shapes implement the ISupportMappable interface and are always convex. They can be passed to static methods defined in the NarrowPhase class for collision detection. They also implement the IDynamicTreeEntry interface and can therefore be added to the DynamicTree class: When a shape is added to a rigid body this is done automatically (world.DynamicTree). Note Concave Shapes A concave shape can be represented by combining multiple convex shapes on a single rigid body. Third-party libraries for 'convex decomposition' can be used to generate convex hulls from arbitrary meshes. Default types The inheritance hierarchy for the default shapes in Jitter is shown here: Shape  RigidBodyShape   BoxShape   CapsuleShape   ConeShape   ConvexHullShape   CylinderShape   PointCloudShape   TransformedShape   TriangleShape  SoftBodyShape  SoftBodyTetrahedron  SoftBodyTriangle Most shapes are self-explanatory (additional details are in the API documentation), while some specifics are outlined below. ConvexHullShape The constructor of the ConvexHullShape takes a list of triangles. public ConvexHullShape(List<JTriangle> triangles) The triangles provided must form a convex hull. The validity of the convex shape is not checked. Invalid shapes can lead to glitched collisions and/or non-terminating algorithms during collision detection. The triangles are used to construct an internal acceleration structure that speeds up collision detection for this shape through hill-climbing. The convexHullShape.Clone() method can be used to clone the shape: The internal data structure is then used for both shapes. PointCloudShape The PointCloudShape is very similar to the ConvexHullShape. The constructor takes a list of vertices. public PointCloudShape(List<JVector> vertices) The vertices do not need to form a convex hull; however, collision detection will 'shrink-wrap' these vertices, so the final collision shape is convex. For example, passing the 8 vertices of a cube to the constructor generates a cube shape; adding a 9th vertex at the cube's center has no effect. Warning Number of vertices PointCloudShapes should only be used for a small to moderate number of vertices (\\(\\approx{}300\\)). Larger numbers of vertices can negatively impact performance. ConvexHullShapes are the better choice for more complex hulls. TransformedShape The TransformedShape takes another shape as input and transforms it. public TransformedShape(RigidBodyShape shape, in JVector translation, in JMatrix transform) Any affine transformation is possible. The wrapped shape might be translated, rotated, scaled and sheared. For example, a sphere shape could be transformed into an ellipsoid. TriangleShape The TriangleShape has no volume. It is mostly used for static geometry, although it can be added to non-static bodies. The TriangleShape is constructed with a TriangleMesh and an index. public TriangleShape(TriangleMesh mesh, int index) A TriangleMesh.Triangle stores information about neighbour triangles. This information is used in the TriangleEdgeCollisionFilter (enabled by default) to resolve collision artifacts that occur when shapes slide over the edges between connected triangles. These edges are often referred to as 'internal edges' and can cause major problems when adding level geometry to a game. SoftBodyShape The vertices of the SoftBodyShape are represented by rigid bodies. The shapes (triangle and tetrahedron) are dynamically defined by the position of the vertices. A SoftBodyShape is not added to a body. Custom shapes Custom shapes can easily be implemented in Jitter. A shape is defined by its support function - which can be looked up or derived. The following example demonstrates implementing a half-sphere (symmetry axis aligned with the y-axis) with a radius of one in Jitter. public class HalfSphereShape : RigidBodyShape { public override void SupportMap(in JVector direction, out JVector result) { const float centerOfMassOffset = 3.0f / 8.0f; if (direction.Y >= 0.0f) { result = JVector.Normalize(direction); } else { JVector pDir = new JVector(direction.X, 0.0f, direction.Z); float pDirSq = pDir.LengthSquared(); if (pDirSq < 1e-12f) result = JVector.Zero; else result = (1.0f / MathF.Sqrt(pDirSq)) * pDir; } // shift, such that (0, 0, 0) is the center of mass result.Y -= centerOfMassOffset; } public override void GetCenter(out JVector point) { point = JVector.Zero; } } Mass properties and bounding boxes are automatically calculated from the support map using methods in the ShapeHelper class. Performance can be optimized by providing overrides directly in the shape class: public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBBox box) public override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass) public override bool LocalRayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda) The ShapeHelper class can also be used to generate a triangle mesh representation of the shape (or any class implementing ISupportMappable), via public static IEnumerable<JTriangle> MakeHull(ISupportMappable support, int subdivisions = 3)"
  },
  "docs/documentation/world.html": {
    "href": "docs/documentation/world.html",
    "title": "Jitter World | Jitter2",
    "summary": "Jitter World An instance of the Jitter World class contains all entities in the physics simulation and provides the World.Step method to advance the simulation by a single time step. World.Step Forward the world by a single time step using Step(float dt, bool multiThread = true) Time step size Note Units in Jitter The unit system of Jitter is not explicitly defined. The engine utilizes 32-bit floating-point arithmetic and is optimized for objects with a size of 1 [len_unit]. For example, the collision system uses length thresholds on the order of 1e-04 [len_unit]. It assumes a unit density of 1 [mass_unit/len_unit] for the mass properties of shapes. Consequently, the default mass of a unit cube is 1 [mass_unit]. The default value for gravity in Jitter is 9.81 [len_unit/time_unit], which aligns with the gravitational acceleration on Earth in metric units (m/s). Therefore, it is reasonable to use metric units (kg, m, s) when conceptualizing these values. The smaller the time step size, the more stable the simulation. Timesteps larger then \\(\\mathrm{dt}=1/60\\,\\mathrm{s}\\) are not adviced. It is also recommend to use fixed time steps. Typical code accumulates delta times and calls world.Step only at fixed time intervals, as shown in the following example. private float accumulatedTime = 0.0f; public void FixedTimeStep(float dt, int maxSteps = 4) { const float fixedStep = 1.0f / 100.0f; int steps = 0; accumulatedTime += dt; while (accumulatedTime > fixedStep) { world.Step(fixedStep, multiThread); accumulatedTime -= fixedStep; // we can not keep up with the real time, i.e. the simulation // is running slower than the real time is passing. if (++steps >= maxSteps) return; } } Multithreading Jitter employs its own thread pool (Parallelization.ThreadPool) to distribute tasks across multiple threads, potentially processed by multiple cores. Jitter utilizes the thread pool when the world.Step method is invoked with the multiThread argument set to true. By default Jitter spawns ThreadPool.ThreadCountSuggestion\\(-1\\) additional threads, where the suggestion is caculated by public const float ThreadsPerProcessor = 0.9f; public static int ThreadCountSuggestion => Math.Max((int)(Environment.ProcessorCount * ThreadsPerProcessor), 1); The number of worker threads managed by the thread pool can be adjusted using ChangeThreadCount(int numThreads). A singleton pattern is used here, as demonstrated below: ThreadPool.Instance.ChangeThreadCount(4); This adjusts the number of additional (with respect to the main thread) worker threads to \\(4-1=3\\). The world.ThreadModel property may be used to keep the thread pool in a tight loop waiting for work to be processed after world.Step has been run (ThreadModelType.Persistent), or to yield threads afterwards (ThreadModelType.Regular). The latter option is recommend to free processing power for other code, such as rendering. Solver Iterations Jitter employs an iterative solver to solve contacts and constraints. The number of iterations can be raised to improve simulation quality (world.SolverIterations). world.SolverIterations = (solver: 6, relaxation: 4); Jitter solves physical contacts (and constraints) on the velocity level ('solver iterations'). Jitter also adds velocities to rigid bodies to resolve unphysical interpenetrations of bodies. These additional velocities add unwanted energy to the system which can be removed by an additional relaxation phase after integrating the new positions from these velocities. The number of iterations in the relaxation phase ('relaxation iterations') is specified here as well. The runtime for solving contacts and constraints scales linearly with the number of iterations. Substep Count The time step can be divided into smaller steps, defined by world.SubstepCount. These smaller time steps are solved similiar to a regular full steps, however collision information is not updated. Each sub step is solved with the number of solver iterations specified in world.SolverIterations. For example world.SubstepCount = 4; world.SolverIterations = (solver: 2, relaxation: 1); does perform \\(12\\) solver iterations in total for each call to world.Step. The runtime is slower than a single regular step with \\(12\\) iterations but this approach enhances the stability of the simulation. Substepping is excellent for enhancing the overall quality of constraints, stabilizing large stacks of objects, and simulating large mass ratios (like heavy objects resting on light objects) with greater accuracy. Auxiliary Contacts Jitter employs a technique termed 'auxiliary contacts', where additional contacts are generated for the general case where two flat surfaces of shapes are in contact. These additional contacts are calculated within one frame, generating the full contact manifold in a 'single pass' and preventing jitter commonly encountered with incrementally constructed collision manifolds. The world.EnableAuxiliaryContactPoints property can be used to enable or disable the usage of auxiliary contact point generation. Rigid Bodies All rigid bodies registered with the world can be accessed using world.RigidBodies where RigidBodies is of type ReadOnlyActiveList<RigidBody>. The bodies are in no particular order and maybe reordered during calls to world.Step. Raw Data RigidBodies, Arbiters, and (Small)Constraints are regular C# classes that reside on the managed heap. However, these objects are linked to their unmanaged counterparts: RigidBodyData, ContactData, and (Small)ConstraintData which can be accessed using: world.RawData Jitter relocates native structures so that active objects are stored in contiguous memory, enabling efficient access by the iterative solver. Caution Raw Memory Access Accessing raw memory is generally not required when utilizing the standard functionalities of Jitter. Although reading the raw data of objects is generally safe, modifying data can corrupt the internal state of the engine. Warning Accessing Removed Entities Instances of RigidBody, Arbiter, and Constraint store some of their data in unmanaged memory, which is automatically freed once the entities are removed (world.Remove) from the world. These entities must not be used any longer, i.e., their functions and properties must not be called or accessed, otherwise, a NullReferenceException is thrown."
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Welcome | Jitter2",
    "summary": "Welcome You will find tutorials and documentation here. Work in progress. You can help by editing or adding new content."
  },
  "docs/tutorials/boxes/hello-world.html": {
    "href": "docs/tutorials/boxes/hello-world.html",
    "title": "Hello World | Jitter2",
    "summary": "Hello World We will now add physics to the scene. We do this by creating a new instance of the World class and adding several rigid bodies to it. Replace the content of Program.cs with the following code (marked lines indicate the additions to the source code): using System.Numerics; using Raylib_cs; using Jitter2; using Jitter2.Collision.Shapes; using Jitter2.Dynamics; using Jitter2.LinearMath; using static Raylib_cs.Raylib; static Matrix4x4 GetRayLibTransformMatrix(RigidBody body) { JMatrix ori = JMatrix.CreateFromQuaternion(body.Orientation); JVector pos = body.Position; return new Matrix4x4(ori.M11, ori.M12, ori.M13, pos.X, ori.M21, ori.M22, ori.M23, pos.Y, ori.M31, ori.M32, ori.M33, pos.Z, 0, 0, 0, 1.0f); } static Texture2D GenCheckedTexture(int size, int checks, Color colorA, Color colorB) { Image imageMag = GenImageChecked(size, size, checks, checks, colorA, colorB); Texture2D textureMag = LoadTextureFromImage(imageMag); UnloadImage(imageMag); return textureMag; } const int NumberOfBoxes = 12; // set a hint for anti-aliasing SetConfigFlags(ConfigFlags.Msaa4xHint); // initialize a 1200x800 px window with a title InitWindow(1200, 800, \"BoxDrop example\"); // dynamically create a plane model Texture2D texture = GenCheckedTexture(10, 1, Color.LightGray, Color.Gray); Model planeModel = LoadModelFromMesh(GenMeshPlane(10, 10, 10, 10)); SetMaterialTexture(ref planeModel, 0, MaterialMapIndex.Diffuse, ref texture); // dynamically create a box model texture = GenCheckedTexture(2, 1, Color.White, Color.Magenta); Mesh boxMesh = GenMeshCube(1, 1, 1); Material boxMat = LoadMaterialDefault(); SetMaterialTexture(ref boxMat, MaterialMapIndex.Diffuse, texture); // initialize the Jitter physics world World world = new (); world.SubstepCount = 4; // add a body representing the plane RigidBody planeBody = world.CreateRigidBody(); planeBody.AddShape(new BoxShape(10)); planeBody.Position = new JVector(0, -5, 0); planeBody.MotionType = MotionType.Static; // add NumberOfBoxes cubes for(int i = 0; i < NumberOfBoxes; i++) { RigidBody body = world.CreateRigidBody(); body.AddShape(new BoxShape(1)); body.Position = new JVector(0, i * 2 + 0.5f, 0); } // create a camera Camera3D camera = new () { Position = new Vector3(-20.0f, 8.0f, 10.0f), Target = new Vector3(0.0f, 4.0f, 0.0f), Up = new Vector3(0.0f, 1.0f, 0.0f), FovY = 45.0f, Projection = CameraProjection.Perspective }; // 100 fps target SetTargetFPS(100); // simple render loop while (!WindowShouldClose()) { BeginDrawing(); ClearBackground(Color.Blue); BeginMode3D(camera); DrawModel(planeModel, Vector3.Zero, 1.0f, Color.White); world.Step(1.0f / 100.0f, true); foreach(var body in world.RigidBodies) { if (body == planeBody || body == world.NullBody) continue; // do not draw this DrawMesh(boxMesh, boxMat, GetRayLibTransformMatrix(body)); } EndMode3D(); DrawText($\"{GetFPS()} fps\", 10, 10, 20, Color.White); EndDrawing(); } CloseWindow(); Running your program, you should now see a few boxes dynamically falling onto the ground."
  },
  "docs/tutorials/boxes/project-setup.html": {
    "href": "docs/tutorials/boxes/project-setup.html",
    "title": "Project Setup | Jitter2",
    "summary": "Project Setup In this project we will use Raylib and Jitter to implement a simple scene of boxes falling to the ground. Requirements Install the .NET 10 SDK. Ensure that dotnet is correctly set up by executing the following command: dotnet --version Create a New Console Application and Add Jitter and Raylib First, create a new directory named \"BoxDrop\" and navigate into it: mkdir BoxDrop && cd BoxDrop Next, create a new console application in this directory and add Raylib-cs and Jitter2: dotnet new console dotnet add package Raylib-cs --version 6.1.1 dotnet add package Jitter2 You have completed the setup. If you now execute the following command: dotnet run Your console should display: \"Hello, World!\"."
  },
  "docs/tutorials/boxes/render-loop.html": {
    "href": "docs/tutorials/boxes/render-loop.html",
    "title": "Render Loop | Jitter2",
    "summary": "Render Loop The first thing we need to do is to familiarize ourselves a bit with Raylib_cs. Replace the content of Program.cs with the following code: using System.Numerics; using Raylib_cs; using static Raylib_cs.Raylib; static Texture2D GenCheckedTexture(int size, int checks, Color colorA, Color colorB) { Image imageMag = GenImageChecked(size, size, checks, checks, colorA, colorB); Texture2D textureMag = LoadTextureFromImage(imageMag); UnloadImage(imageMag); return textureMag; } // set a hint for anti-aliasing SetConfigFlags(ConfigFlags.Msaa4xHint); // initialize a 1200x800 px window with a title InitWindow(1200, 800, \"BoxDrop example\"); // dynamically create a plane model Texture2D texture = GenCheckedTexture(10, 1, Color.LightGray, Color.Gray); Model planeModel = LoadModelFromMesh(GenMeshPlane(10, 10, 10, 10)); SetMaterialTexture(ref planeModel, 0, MaterialMapIndex.Diffuse, ref texture); // create a camera Camera3D camera = new () { Position = new Vector3(-20.0f, 8.0f, 10.0f), Target = new Vector3(0.0f, 4.0f, 0.0f), Up = new Vector3(0.0f, 1.0f, 0.0f), FovY = 45.0f, Projection = CameraProjection.Perspective }; // 100 fps target SetTargetFPS(100); // simple render loop while (!WindowShouldClose()) { BeginDrawing(); ClearBackground(Color.Blue); BeginMode3D(camera); DrawModel(planeModel, Vector3.Zero, 1.0f, Color.White); EndMode3D(); DrawText($\"{GetFPS()} fps\", 10, 10, 20, Color.White); EndDrawing(); } CloseWindow(); Running your program should now display a plane: We will add some physically simulated boxes in the next chapter."
  },
  "docs/tutorials/teapots/aftermath.html": {
    "href": "docs/tutorials/teapots/aftermath.html",
    "title": "Aftermath | Jitter2",
    "summary": "Aftermath PointCloudShape vs ConvexHullShape In this example, we used the PointCloudShape to simulate a rigid body with a convex hull. As the name suggests, this shape only requires a set of points  they don't need to lie exactly on a convex surface. By design, Jitter treats the convex hull of these points as the actual shape for collision detection. Although the algorithm used here is brute-force, it can be extremely fast: the data is stored in a linear memory layout, and SIMD instructions are used to accelerate the support function. Because of this, PointCloudShape is usually the best choice for quickly and efficiently adding simple convex geometry to your simulation. The ConvexHullShape, on the other hand, is intended for more complex and detailed convex models. Unlike PointCloudShape, this shape requires a precomputed convex hull provided as a list of triangles (List<JTriangle>). Jitter does not generate this for you  you'll need to use third-party tools like Blender or dedicated convex hull libraries. The input mesh must be strictly convex for collision detection to work correctly. Internally, ConvexHullShape uses a hill-climbing algorithm to compute the support function. While this approach is algorithmically more efficient than brute-force, the performance benefits only become noticeable with larger shapes. As a general rule of thumb, ConvexHullShape starts to outperform PointCloudShape at around 300 vertices or more."
  },
  "docs/tutorials/teapots/hello-world.html": {
    "href": "docs/tutorials/teapots/hello-world.html",
    "title": "Hello World | Jitter2",
    "summary": "Hello World Creating the PointCloudShape We can now create a PointCloudShape from the sampled vertices: // find a few points on the convex hull of the teapot. var vertices = ShapeHelper.SampleHull(allVertices, subdivisions: 3); // use these points to create a PointCloudShape. var pointCloudShape = new PointCloudShape(vertices); However, we need to be a bit careful here. If we add this shape to a rigid body as-is, the body may not behave as intuitively expected. This is because the center of mass of a rigid body is always located at (0, 0, 0) in its local coordinate frame. If you open teapot.obj in a model editor, you'll notice that the model is not centered around the origin. To correct this, we either need to center the model manually in a model editoror, more conveniently, use the Shift property of PointCloudShape to align the center of mass with the origin: // find a few points on the convex hull of the teapot. var vertices = ShapeHelper.SampleHull(allVertices, subdivisions: 3); // use these points to create a PointCloudShape. var pointCloudShape = new PointCloudShape(vertices); // shift the shape so its center of mass is at the origin. pointCloudShape.GetCenter(out JVector centerOfMass); pointCloudShape.Shift = -centerOfMass; // pointCloudShape.GetCenter(out centerOfMass); // now returns (0, 0, 0) // finally, create the rigid body for the teapot var rigidBody = world.CreateRigidBody(); rigidBody.AddShape(pointCloudShape); Warning The shift applied to the shape must also be taken into account when rendering the model, to ensure it aligns visually with the simulation. Creating Multiple Instances of the Same Shape In Jitter, it is not valid to add the same shape instance to multiple rigid bodies. To create additional instances of a shape, use the Clone() method of PointCloudShape. This method creates a new shape object that shares the underlying data structure, saving both memory and computation time: var shapeInstance1 = new PointCloudShape(vertices); var shapeInstance2 = shapeInstance1.Clone(); // Safe to use in a second body This approach is especially useful when many bodies share the same geometry, such as multiple identical props or characters in a simulation. Putting it all together using System.Numerics; using Raylib_cs; using Jitter2; using Jitter2.Collision.Shapes; using Jitter2.Dynamics; using Jitter2.LinearMath; using static Raylib_cs.Raylib; static Matrix4x4 GetRayLibTransformMatrix(RigidBody body) { JMatrix ori = JMatrix.CreateFromQuaternion(body.Orientation); JVector pos = body.Position; return new Matrix4x4(ori.M11, ori.M12, ori.M13, pos.X, ori.M21, ori.M22, ori.M23, pos.Y, ori.M31, ori.M32, ori.M33, pos.Z, 0, 0, 0, 1.0f); } static Texture2D GenCheckedTexture(int size, int checks, Color colorA, Color colorB) { Image imageMag = GenImageChecked(size, size, checks, checks, colorA, colorB); Texture2D textureMag = LoadTextureFromImage(imageMag); UnloadImage(imageMag); return textureMag; } const int numberOfTeapots = 12; // set a hint for anti-aliasing SetConfigFlags(ConfigFlags.Msaa4xHint); // initialize a 1200x800 px window with a title InitWindow(1200, 800, \"TeaDrop example\"); // dynamically create a plane model Texture2D texture = GenCheckedTexture(10, 1, Color.LightGray, Color.Gray); Model planeModel = LoadModelFromMesh(GenMeshPlane(20, 20, 10, 10)); SetMaterialTexture(ref planeModel, 0, MaterialMapIndex.Diffuse, ref texture); // load the teapot model from file Model teapotModel = LoadModel(\"teapot.obj\"); // load the mesh vertices if (teapotModel.MeshCount == 0) throw new Exception(\"Model could not be loaded!\"); Mesh teapotMesh; unsafe { teapotMesh = teapotModel.Meshes[0]; } var allVertices = teapotMesh.VerticesAs<JVector>(); // sample vertices on the convex hull var vertices = ShapeHelper.SampleHull(allVertices, 4); // create the PointCloudShape from the reduced vertices var pointCloudShape = new PointCloudShape(vertices); // shift the shape, such that the center of mass is at the origin pointCloudShape.GetCenter(out JVector center); pointCloudShape.Shift = -center; // we need to take the transpose here, since Raylib and System.Numerics // use a different convention Matrix4x4 shift = Matrix4x4.CreateTranslation(-center); shift = Matrix4x4.Transpose(shift); texture = GenCheckedTexture(16, 2, Color.White, Color.Magenta); Material teapotMat = LoadMaterialDefault(); SetMaterialTexture(ref teapotMat, MaterialMapIndex.Diffuse, texture); // initialize the Jitter physics world World world = new (); world.SubstepCount = 4; // add a body representing the plane RigidBody planeBody = world.CreateRigidBody(); planeBody.AddShape(new BoxShape(20)); planeBody.Position = new JVector(0, -10, 0); planeBody.MotionType = MotionType.Static; // add numberOfTeapots teapots for(int i = 0; i < numberOfTeapots; i++) { RigidBody body = world.CreateRigidBody(); body.AddShape(pointCloudShape.Clone()); body.Position = new JVector(0, i * 4 + 0.5f, 0); } // create a camera Camera3D camera = new () { Position = new Vector3(-40.0f, 16.0f, 20.0f), Target = new Vector3(0.0f, 4.0f, 0.0f), Up = new Vector3(0.0f, 1.0f, 0.0f), FovY = 45.0f, Projection = CameraProjection.Perspective }; // 100 fps target SetTargetFPS(100); // simple render loop while (!WindowShouldClose()) { BeginDrawing(); ClearBackground(Color.Blue); BeginMode3D(camera); DrawModel(planeModel, Vector3.Zero, 1.0f, Color.White); world.Step(1.0f / 100.0f, true); foreach(var body in world.RigidBodies) { if (body == planeBody || body == world.NullBody) continue; // do not draw this DrawMesh(teapotMesh, teapotMat, GetRayLibTransformMatrix(body) * shift); } EndMode3D(); DrawText($\"{GetFPS()} fps\", 10, 10, 20, Color.White); EndDrawing(); } CloseWindow();"
  },
  "docs/tutorials/teapots/hull-sampling.html": {
    "href": "docs/tutorials/teapots/hull-sampling.html",
    "title": "Hull Sampling | Jitter2",
    "summary": "Hull Sampling The teapot is a concave shape, which we will approximate using its convex hull (Wikipedia). As a first step, we will reduce the number of vertices used to construct the convex hull. Note Sampling We could work with the entire set of vertices, but this comes with two main disadvantages: The set may include vertices that lie inside the hull. While these do not affect the simulation outcome, they are still briefly considered during collision detection in each frame. We typically don't need an exact convex hull. Omitting a few vertices often has little effect on accuracy while significantly improving performance. Reducing the number of vertices can help speed up the simulation without sacrificing collision fidelity. Jitter provides a built-in method to simplify the vertex set: ShapeHelper.SampleHull. This function samples directions uniformly across the unit sphere and returns the vertices that are furthest away in those directions. These vertices, by definition, lie on the convex hull of the original shape. Replace the content of Program.cs with the following code: using System.Numerics; using Jitter2.Collision.Shapes; using Jitter2.LinearMath; using Raylib_cs; using static Raylib_cs.Raylib; // set a hint for anti-aliasing SetConfigFlags(ConfigFlags.Msaa4xHint); // initialize a 1200x800 px window with a title InitWindow(1200, 800, \"TeaDrop example\"); // load the teapot model from a file Model teapotModel = LoadModel(\"teapot.obj\"); // load the mesh vertices if (teapotModel.MeshCount == 0) throw new Exception(\"Model could not be loaded!\"); Mesh mesh; unsafe { mesh = teapotModel.Meshes[0]; } var allVertices = mesh.VerticesAs<JVector>(); var vertices = ShapeHelper.SampleHull(allVertices, 4); // just for visualization - // we will not need to construct the explicit hull for the simulation! var debugHull = ShapeHelper.Tessellate(vertices, 4); // create a camera Camera3D camera = new () { Position = new Vector3(-5.0f, 2.0f, 3.0f), Target = new Vector3(0.0f, 1.0f, 0.0f), Up = new Vector3(0.0f, 1.0f, 0.0f), FovY = 45.0f, Projection = CameraProjection.Perspective }; // 100 fps target SetTargetFPS(100); // simple render loop while (!WindowShouldClose()) { BeginDrawing(); ClearBackground(Color.Blue); // make the scene rotate UpdateCamera(ref camera, CameraMode.Orbital); BeginMode3D(camera); // draw the teapot model DrawModelWires(teapotModel, Vector3.Zero, 1.0f, Color.White); // draw the sample vertices of the convex hull foreach (var vertex in vertices) { DrawSphere(vertex, 0.02f, Color.Red); } // for debugging: draw the explicit hull foreach (var vertex in debugHull) { DrawLine3D(vertex.V0, vertex.V1, Color.Green); DrawLine3D(vertex.V1, vertex.V2, Color.Green); DrawLine3D(vertex.V2, vertex.V0, Color.Green); } EndMode3D(); DrawText($\"{GetFPS()} fps\", 10, 10, 20, Color.White); EndDrawing(); } CloseWindow(); The teapot's wireframe is drawn in white, the green wireframe shows the convex hull, and the sampled hull vertices are depicted as red dots."
  },
  "docs/tutorials/teapots/project-setup.html": {
    "href": "docs/tutorials/teapots/project-setup.html",
    "title": "Project Setup | Jitter2",
    "summary": "Project Setup In the previous section, we created a simulation of falling boxes. Jitter includes several default shapes, such as capsules, cylinders, and spheres. These shapes can be transformed and/or combined, and they are already sufficient to represent many types of collidable entities. In this section, we will add a custom convex shape to the simulationspecifically, the famous Utah teapot. We'll construct this shape from its visual representation by loading a teapot.obj file and using its vertices to create the convex shape. Requirements Install the .NET 10 SDK. Ensure that dotnet is correctly set up by executing the following command: dotnet --version Create a New Console Application and Add Jitter and Raylib First, create a new directory named \"TeaDrop\" and navigate into it: mkdir TeaDrop && cd TeaDrop Download and unzip the teapot.obj model. wget https://github.com/notgiven688/jitterphysics2/raw/refs/heads/main/src/JitterDemo/assets/teapot.obj.zip unzip teapot.obj.zip Next, create a new console application in this directory and add Raylib-cs and Jitter2: dotnet new console dotnet add package Raylib-cs --version 6.1.1 dotnet add package Jitter2 Add the following code to TeaDrop.csproj to allow unsafe code, and to copy teapot.obj automatically to the output directory: <PropertyGroup> <AllowUnsafeBlocks>true</AllowUnsafeBlocks> </PropertyGroup> <ItemGroup> <None Update=\"teapot.obj\"> <CopyToOutputDirectory>Always</CopyToOutputDirectory> </None> </ItemGroup> You have completed the setup. If you now execute the following command: dotnet run Your console should display: \"Hello, World!\"."
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "summary": ""
  }
}