"use strict";(self.webpackChunkjitterphysics=self.webpackChunkjitterphysics||[]).push([[119],{8743:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var n=t(4848),i=t(8453);const a={},r="Jitter World",l={id:"documentation/world",title:"Jitter World",description:"An instance of the Jitter World class contains all entities in the physics simulation and provides the World.Step method to advance the simulation by a single time step.",source:"@site/docs/02_documentation/01-world.md",sourceDirName:"02_documentation",slug:"/documentation/world",permalink:"/docs/documentation/world",draft:!1,unlisted:!1,editUrl:"https://github.com/notgiven688/jitterphysics2/tree/main/docs/docs/02_documentation/01-world.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/docs/category/overview"},next:{title:"Rigid Bodies",permalink:"/docs/documentation/bodies"}},o={},d=[{value:"World.Step",id:"worldstep",level:2},{value:"Time step size",id:"time-step-size",level:3},{value:"Multithreading",id:"multithreading",level:3},{value:"Solver Iterations",id:"solver-iterations",level:2},{value:"Substep Count",id:"substep-count",level:2},{value:"Auxiliary Contacts",id:"auxiliary-contacts",level:2},{value:"Rigid Bodies",id:"rigid-bodies",level:2},{value:"Raw Data",id:"raw-data",level:2}];function c(e){const s={admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"jitter-world",children:"Jitter World"})}),"\n",(0,n.jsxs)(s.p,{children:["An instance of the Jitter ",(0,n.jsx)(s.code,{children:"World"})," class contains all entities in the physics simulation and provides the ",(0,n.jsx)(s.code,{children:"World.Step"})," method to advance the simulation by a single time step."]}),"\n",(0,n.jsx)(s.h2,{id:"worldstep",children:"World.Step"}),"\n",(0,n.jsx)(s.p,{children:"Forward the world by a single time step using"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"Step(float dt, bool multiThread = true)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"time-step-size",children:"Time step size"}),"\n",(0,n.jsx)(s.admonition,{title:"Units in Jitter",type:"info",children:(0,n.jsx)(s.p,{children:"The unit system of Jitter is not explicitly defined.\nThe engine utilizes 32-bit floating-point arithmetic and is optimized for objects with a size of 1 [len_unit].\nFor example, the collision system uses length thresholds on the order of 1e-04 [len_unit].\nIt assumes a unit density of 1 [mass_unit/len_unit\xb3] for the mass properties of shapes.\nConsequently, the default mass of a unit cube is 1 [mass_unit].\nThe default value for gravity in Jitter is 9.81 [len_unit/time_unit\xb2], which aligns with the gravitational acceleration on Earth in metric units (m/s\xb2).\nTherefore, it is reasonable to use metric units (kg, m, s) when conceptualizing these values."})}),"\n",(0,n.jsxs)(s.p,{children:["The smaller the time step size, the more stable the simulation.\nTimesteps larger then ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{mathvariant:"normal",children:"d"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"t"})]}),(0,n.jsx)(s.mo,{children:"="}),(0,n.jsx)(s.mn,{children:"1"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"/"}),(0,n.jsx)(s.mn,{children:"60"}),(0,n.jsx)(s.mtext,{children:"\u2009"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"s"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\mathrm{dt}=1/60\\,\\mathrm{s}"})]})})}),(0,n.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6944em"}}),(0,n.jsx)(s.span,{className:"mord",children:(0,n.jsx)(s.span,{className:"mord mathrm",children:"dt"})}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,n.jsx)(s.span,{className:"mrel",children:"="}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord",children:"1/60"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord mathrm",children:"s"})]})]})]})," are not adviced.\nIt is also recommend to use fixed time steps.\nTypical code accumulates delta times and calls ",(0,n.jsx)(s.code,{children:"world.Step"})," only at fixed time intervals, as shown in the following example."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"private float accumulatedTime = 0.0f;\n\npublic void FixedTimeStep(float dt, int maxSteps = 4)\n{\n    const float fixedStep = 1.0f / 100.0f;\n\n    int steps = 0;\n    accumulatedTime += dt;\n\n    while (accumulatedTime > fixedStep)\n    {\n        world.Step(fixedStep, multiThread);\n        accumulatedTime -= fixedStep;\n\n        // we can not keep up with the real time, i.e. the simulation\n        // is running slower than the real time is passing.\n        if (++steps >= maxSteps) return;\n    }\n}\n"})}),"\n",(0,n.jsx)(s.h3,{id:"multithreading",children:"Multithreading"}),"\n",(0,n.jsxs)(s.p,{children:["Jitter employs its own thread pool (",(0,n.jsx)(s.code,{children:"Parallelization.ThreadPool"}),") to distribute tasks across multiple threads, potentially processed by multiple cores.\nJitter utilizes the thread pool when the ",(0,n.jsx)(s.code,{children:"world.Step"})," method is invoked with the multiThread argument set to true.\nBy default Jitter spawns ",(0,n.jsx)(s.code,{children:"ThreadPool.ThreadCountSuggestion"}),(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mo,{children:"\u2212"}),(0,n.jsx)(s.mn,{children:"1"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"-1"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u2212"}),(0,n.jsx)(s.span,{className:"mord",children:"1"})]})})]})," additional threads, where the suggestion is caculated by"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"public const float ThreadsPerProcessor = 0.9f;\npublic static int ThreadCountSuggestion => Math.Max((int)(Environment.ProcessorCount * ThreadsPerProcessor), 1);\n"})}),"\n",(0,n.jsxs)(s.p,{children:["The number of worker threads managed by the thread pool can be adjusted using ",(0,n.jsx)(s.code,{children:"ChangeThreadCount(int numThreads)"}),".\nA singleton pattern is used here, as demonstrated below:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"ThreadPool.Instance.ChangeThreadCount(4);\n"})}),"\n",(0,n.jsxs)(s.p,{children:["This adjusts the number of additional (with respect to the main thread) worker threads to ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mn,{children:"4"}),(0,n.jsx)(s.mo,{children:"\u2212"}),(0,n.jsx)(s.mn,{children:"1"}),(0,n.jsx)(s.mo,{children:"="}),(0,n.jsx)(s.mn,{children:"3"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"4-1=3"})]})})}),(0,n.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,n.jsx)(s.span,{className:"mord",children:"4"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,n.jsx)(s.span,{className:"mbin",children:"\u2212"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,n.jsx)(s.span,{className:"mord",children:"1"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,n.jsx)(s.span,{className:"mrel",children:"="}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,n.jsx)(s.span,{className:"mord",children:"3"})]})]})]}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"world.ThreadModel"})," property may be used to keep the thread pool in a tight loop waiting for work to be processed after ",(0,n.jsx)(s.code,{children:"world.Step"})," has been run (",(0,n.jsx)(s.code,{children:"ThreadModelType.Persistent"}),"), or to yield threads afterwards (",(0,n.jsx)(s.code,{children:"ThreadModelType.Regular"}),").\nThe latter option is recommend to free processing power for other code, such as rendering."]}),"\n",(0,n.jsx)(s.h2,{id:"solver-iterations",children:"Solver Iterations"}),"\n",(0,n.jsxs)(s.p,{children:["Jitter employs an iterative solver to solve contacts and constraints.\nThe number of iterations can be raised to improve simulation quality (",(0,n.jsx)(s.code,{children:"world.SolverIterations"}),")."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"world.SolverIterations = (solver: 6, relaxation: 4);\n"})}),"\n",(0,n.jsx)(s.p,{children:"Jitter solves physical contacts (and constraints) on the velocity level ('solver iterations').\nJitter also adds velocities to rigid bodies to resolve unphysical interpenetrations of bodies.\nThese additional velocities add unwanted energy to the system which can be removed by an additional relaxation phase after integrating the new positions from these velocities.\nThe number of iterations in the relaxation phase ('relaxation iterations') is specified here as well.\nThe runtime for solving contacts and constraints scales linearly with the number of iterations."}),"\n",(0,n.jsx)(s.h2,{id:"substep-count",children:"Substep Count"}),"\n",(0,n.jsxs)(s.p,{children:["The time step can be divided into smaller steps, defined by ",(0,n.jsx)(s.code,{children:"world.SubstepCount"}),".\nThese smaller time steps are solved similiar to a regular full steps, however collision information is not updated.\nEach sub step is solved with the number of solver iterations specified in ",(0,n.jsx)(s.code,{children:"world.SolverIterations"}),".\nFor example"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"world.SubstepCount = 4;\nworld.SolverIterations = (solver: 2, relaxation: 1);\n"})}),"\n",(0,n.jsxs)(s.p,{children:["does perform ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mn,{children:"12"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"12"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,n.jsx)(s.span,{className:"mord",children:"12"})]})})]})," solver iterations in total for each call to ",(0,n.jsx)(s.code,{children:"world.Step"}),".\nThe runtime is slower than a single regular step with ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mn,{children:"12"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"12"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,n.jsx)(s.span,{className:"mord",children:"12"})]})})]})," iterations but this approach enhances the stability of the simulation.\nSubstepping is excellent for enhancing the overall quality of constraints, stabilizing large stacks of objects, and simulating large mass ratios (like heavy objects resting on light objects) with greater accuracy."]}),"\n",(0,n.jsx)(s.h2,{id:"auxiliary-contacts",children:"Auxiliary Contacts"}),"\n",(0,n.jsxs)(s.p,{children:["Jitter employs a technique termed 'auxiliary contacts', where additional contacts are generated for the general case where two flat surfaces of shapes are in contact.\nThese additional contacts are calculated within one frame, generating the full contact manifold in a 'single pass' and preventing jitter commonly encountered with incrementally constructed collision manifolds.\nThe ",(0,n.jsx)(s.code,{children:"world.EnableAuxiliaryContactPoints"})," property can be used to enable or disable the usage of auxiliary contact point generation."]}),"\n",(0,n.jsx)(s.h2,{id:"rigid-bodies",children:"Rigid Bodies"}),"\n",(0,n.jsx)(s.p,{children:"All rigid bodies registered with the world can be accessed using"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"world.RigidBodies\n"})}),"\n",(0,n.jsxs)(s.p,{children:["where ",(0,n.jsx)(s.code,{children:"RigidBodies"})," is of type ",(0,n.jsx)(s.code,{children:"ReadOnlyActiveList<RigidBody>"}),".\nThe bodies are in no particular order and maybe reordered during calls to ",(0,n.jsx)(s.code,{children:"world.Step"}),"."]}),"\n",(0,n.jsx)(s.h2,{id:"raw-data",children:"Raw Data"}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"RigidBodie"}),"s, ",(0,n.jsx)(s.code,{children:"Arbiter"}),"s, and ",(0,n.jsx)(s.code,{children:"(Small)Constraints"})," are regular C# classes that reside on the managed heap.\nHowever, these objects are linked to their unmanaged counterparts: ",(0,n.jsx)(s.code,{children:"RigidBodyData"}),", ",(0,n.jsx)(s.code,{children:"ContactData"}),", and ",(0,n.jsx)(s.code,{children:"(Small)ConstraintData"})," which can be accessed using:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"world.RawData\n"})}),"\n",(0,n.jsx)(s.p,{children:"Jitter relocates native structures so that active objects are stored in contiguous memory, enabling efficient access by the iterative solver."}),"\n",(0,n.jsx)(s.admonition,{title:"Raw Memory Access",type:"danger",children:(0,n.jsx)(s.p,{children:"Accessing raw memory is generally not required when utilizing the standard functionalities of Jitter.\nAlthough reading the raw data of objects is generally safe, modifying data can corrupt the internal state of the engine."})}),"\n",(0,n.jsx)(s.admonition,{title:"Accessing Removed Entities",type:"warning",children:(0,n.jsxs)(s.p,{children:["Instances of ",(0,n.jsx)(s.code,{children:"RigidBody"}),", ",(0,n.jsx)(s.code,{children:"Arbiter"}),", and ",(0,n.jsx)(s.code,{children:"Constraint"})," store some of their data in unmanaged memory, which is automatically freed once the entities are removed (",(0,n.jsx)(s.code,{children:"world.Remove"}),") from the world.\nThese entities must not be used any longer, i.e., their functions and properties must not be called or accessed, otherwise, a ",(0,n.jsx)(s.code,{children:"NullReferenceException"})," is thrown."]})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>l});var n=t(6540);const i={},a=n.createContext(i);function r(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);