"use strict";(self.webpackChunkjitterphysics=self.webpackChunkjitterphysics||[]).push([[438],{263:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>c});var a=s(4848),i=s(8453);const t={},o="Shapes",r={id:"documentation/shapes",title:"Shapes",description:"Shapes in Jitter define how the rigid body collides with other objects.",source:"@site/docs/02_documentation/03-shapes.md",sourceDirName:"02_documentation",slug:"/documentation/shapes",permalink:"/docs/documentation/shapes",draft:!1,unlisted:!1,editUrl:"https://github.com/notgiven688/jitterphysics2/tree/main/docs/docs/02_documentation/03-shapes.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Rigid Bodies",permalink:"/docs/documentation/bodies"},next:{title:"Constraints",permalink:"/docs/documentation/constraints"}},l={},c=[{value:"Default types",id:"default-types",level:2},{value:"ConvexHullShape",id:"convexhullshape",level:3},{value:"PointCloudShape",id:"pointcloudshape",level:3},{value:"TransformedShape",id:"transformedshape",level:3},{value:"TriangleShape",id:"triangleshape",level:3},{value:"FatTriangleShape",id:"fattriangleshape",level:3},{value:"SoftBodyShape",id:"softbodyshape",level:3},{value:"Custom shapes",id:"custom-shapes",level:2}];function d(e){const n={admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",math:"math",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"shapes",children:"Shapes"})}),"\n",(0,a.jsxs)(n.p,{children:["Shapes in Jitter define how the rigid body collides with other objects.\nShapes implement the ",(0,a.jsx)(n.code,{children:"ISupportMappable"})," interface and are always convex.\nThey can be passed to static methods defined in the ",(0,a.jsx)(n.code,{children:"NarrowPhase"})," class for collision detection.\nThey also implement the ",(0,a.jsx)(n.code,{children:"IDynamicTreeEntry"})," interface and can therefore be added to the ",(0,a.jsx)(n.code,{children:"DynamicTree"})," class:\nWhen a shape is added to a rigid body this is done automatically (",(0,a.jsx)(n.code,{children:"world.DynamicTree"}),")."]}),"\n",(0,a.jsx)(n.admonition,{title:"Concave Shapes",type:"info",children:(0,a.jsx)(n.p,{children:"A concave shape can be represented by combining multiple convex shapes on a single rigid body.\nThird-party libraries for 'convex decomposition' can be used to generate convex hulls from arbitrary meshes."})}),"\n",(0,a.jsx)(n.h2,{id:"default-types",children:"Default types"}),"\n",(0,a.jsx)(n.p,{children:"The inheritance hierarchy for the default shapes in Jitter is shown here:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Shape\n\u251c\u2500\u2500 RigidBodyShape\n\u2502   \u251c\u2500\u2500 BoxShape\n\u2502   \u251c\u2500\u2500 CapsuleShape\n\u2502   \u251c\u2500\u2500 ConeShape\n\u2502   \u251c\u2500\u2500 ConvexHullShape\n\u2502   \u251c\u2500\u2500 CylinderShape\n\u2502   \u251c\u2500\u2500 PointCloudShape\n\u2502   \u251c\u2500\u2500 TransformedShape\n\u2502   \u2514\u2500\u2500 TriangleShape\n\u2502       \u2514\u2500\u2500 FatTriangleShape\n\u2514\u2500\u2500 SoftBodyShape\n    \u251c\u2500\u2500 SoftBodyTetrahedron\n    \u2514\u2500\u2500 SoftBodyTriangle\n"})}),"\n",(0,a.jsx)(n.p,{children:"Most shapes are self-explanatory (additional details are in the API documentation), while some specifics are outlined below."}),"\n",(0,a.jsx)(n.h3,{id:"convexhullshape",children:"ConvexHullShape"}),"\n",(0,a.jsxs)(n.p,{children:["The constructor of the ",(0,a.jsx)(n.code,{children:"ConvexHullShape"})," takes a list of triangles."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public ConvexHullShape(List<JTriangle> triangles)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The triangles provided ",(0,a.jsx)(n.em,{children:"must"})," form a convex hull.\nThe validity of the convex shape is not checked.\nInvalid shapes can lead to glitched\ncollisions and/or non-terminating algorithms during collision detection.\nThe triangles are used to construct an internal acceleration structure that speeds up collision detection for this shape through hill-climbing."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"convexHullShape.Clone()"})," method can be used to clone the shape:\nThe internal data structure is then used for both shapes."]}),"\n",(0,a.jsx)(n.h3,{id:"pointcloudshape",children:"PointCloudShape"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"PointCloudShape"})," is very similar to the ",(0,a.jsx)(n.code,{children:"ConvexHullShape"}),".\nThe constructor takes a list of vertices."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public PointCloudShape(List<JVector> vertices)\n"})}),"\n",(0,a.jsx)(n.p,{children:"The vertices do not need to form a convex hull; however, collision detection will 'shrink-wrap' these vertices, so the final collision shape is convex.\nFor example, passing the 8 vertices of a cube to the constructor generates a cube shape; adding a 9th vertex at the cube's center has no effect."}),"\n",(0,a.jsx)(n.admonition,{title:"Number of vertices",type:"warning",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"PointCloudShape"}),"s should only be used for a small to moderate number of vertices (",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mo,{children:"\u2248"}),(0,a.jsx)(n.mrow,{}),(0,a.jsx)(n.mn,{children:"30"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\approx{}30"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.4831em"}}),(0,a.jsx)(n.span,{className:"mrel",children:"\u2248"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord"}),(0,a.jsx)(n.span,{className:"mord",children:"30"})]})]})]}),"). Larger numbers of vertices can negatively impact performance.\n",(0,a.jsx)(n.code,{children:"ConvexHullShape"}),"s are the better choice for more complex hulls."]})}),"\n",(0,a.jsx)(n.h3,{id:"transformedshape",children:"TransformedShape"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"TransformedShape"})," takes another shape as input and transforms it."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public TransformedShape(RigidBodyShape shape, in JVector translation, in JMatrix transform)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Any affine transformation is possible.\nThe wrapped shape might be translated, rotated, scaled and sheared.\nFor example, a sphere shape could be transformed into an ellipsoid."}),"\n",(0,a.jsx)(n.h3,{id:"triangleshape",children:"TriangleShape"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"TriangleShape"})," has no volume.\nIt is mostly used for static geometry, although it can be added to non-static bodies. The ",(0,a.jsx)(n.code,{children:"TriangleShape"})," is constructed  with a ",(0,a.jsx)(n.code,{children:"TriangleMesh"})," and an index."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public TriangleShape(TriangleMesh mesh, int index)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"TriangleMesh.Triangle"})," stores information about neighbour triangles.\nThis information is used in the ",(0,a.jsx)(n.code,{children:"TriangleEdgeCollisionFilter"})," (enabled by default) to resolve collision artifacts that occur when shapes slide over the edges between connected triangles.\nThese edges are often referred to as 'internal edges' and can cause major problems when adding level geometry to a game."]}),"\n",(0,a.jsx)(n.h3,{id:"fattriangleshape",children:"FatTriangleShape"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"FatTriangleShape"})," is similiar to ",(0,a.jsx)(n.code,{children:"TriangleShape"}),", but has finite volume.\nA ",(0,a.jsx)(n.code,{children:"Thickness"}),"-parameter can be set, which defines how much the triangle expands in the negative normal direction.\nThis can help to improve simulation quality.\n",(0,a.jsx)(n.code,{children:"TriangleEdgeCollisionFilter"})," is also active for this type of shape."]}),"\n",(0,a.jsx)(n.h3,{id:"softbodyshape",children:"SoftBodyShape"}),"\n",(0,a.jsxs)(n.p,{children:["The vertices of the ",(0,a.jsx)(n.code,{children:"SoftBodyShape"})," are represented by rigid bodies.\nThe shapes (triangle and tetrahedron) are dynamically defined by the position of the vertices.\nA ",(0,a.jsx)(n.code,{children:"SoftBodyShape"})," is not added to a body."]}),"\n",(0,a.jsx)(n.h2,{id:"custom-shapes",children:"Custom shapes"}),"\n",(0,a.jsx)(n.p,{children:"Custom shapes can easily be implemented in Jitter.\nA shape is defined by its support function - which can be looked up or derived."}),"\n",(0,a.jsx)(n.p,{children:"The following example demonstrates implementing a half-sphere (symmetry axis aligned with the y-axis) with a radius of one in Jitter."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public class HalfSphereShape : RigidBodyShape\n{\n    public override void SupportMap(in JVector direction, out JVector result)\n    {\n        const float centerOfMassOffset = 3.0f / 8.0f;\n\n        if (direction.Y >= 0.0f)\n        {\n            result = JVector.Normalize(direction);\n        }\n        else\n        {\n            JVector pDir = new JVector(direction.X, 0.0f, direction.Z);\n            float pDirSq = pDir.LengthSquared();\n\n            if (pDirSq < 1e-12f) result = JVector.Zero;\n            else result = (1.0f / MathF.Sqrt(pDirSq)) * pDir;\n        }\n\n        // shift, such that (0, 0, 0) is the center of mass\n        result.Y -= centerOfMassOffset;\n    }\n\n    public override void GetCenter(out JVector point)\n    {\n        point = JVector.Zero;\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Mass properties and bounding boxes are automatically calculated from the support map using methods in the ",(0,a.jsx)(n.code,{children:"ShapeHelper"})," class.\nPerformance can be optimized by providing overrides directly in the shape class:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public override void CalculateBoundingBox(in JQuaternion orientation, in JVector position, out JBBox box)\n\npublic override void CalculateMassInertia(out JMatrix inertia, out JVector com, out float mass)\n\npublic override bool LocalRayCast(in JVector origin, in JVector direction, out JVector normal, out float lambda)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"ShapeHelper"})," class can also be used to generate a triangle mesh representation of the shape (or any class implementing ",(0,a.jsx)(n.code,{children:"ISupportMappable"}),"), via"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public static IEnumerable<JTriangle> MakeHull(ISupportMappable support, int subdivisions = 3)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var a=s(6540);const i={},t=a.createContext(i);function o(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);