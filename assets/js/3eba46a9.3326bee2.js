"use strict";(self.webpackChunkjitterphysics=self.webpackChunkjitterphysics||[]).push([[416],{1628:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>r});var n=i(4848),a=i(8453);const t={},d="Rigid Bodies",o={id:"documentation/bodies",title:"Rigid Bodies",description:"Rigid bodies represent the main entity of the dynamics system of the engine.",source:"@site/docs/02_documentation/02-bodies.md",sourceDirName:"02_documentation",slug:"/documentation/bodies",permalink:"/docs/documentation/bodies",draft:!1,unlisted:!1,editUrl:"https://github.com/notgiven688/jitterphysics2/tree/main/docs/docs/02_documentation/02-bodies.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Jitter World",permalink:"/docs/documentation/world"},next:{title:"Shapes",permalink:"/docs/documentation/shapes"}},c={},r=[{value:"Creating a body",id:"creating-a-body",level:2},{value:"Adding shapes",id:"adding-shapes",level:2},{value:"Debugging shapes",id:"debugging-shapes",level:3},{value:"Gravity",id:"gravity",level:2},{value:"Damping",id:"damping",level:2},{value:"Speculative contacts",id:"speculative-contacts",level:2},{value:"Friction and Restitution",id:"friction-and-restitution",level:2},{value:"Collide events",id:"collide-events",level:2},{value:"Activation/Deactivation",id:"activationdeactivation",level:2},{value:"Static bodies",id:"static-bodies",level:2},{value:"Kinematic bodies",id:"kinematic-bodies",level:2}];function l(e){const s={admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"rigid-bodies",children:"Rigid Bodies"})}),"\n",(0,n.jsx)(s.p,{children:"Rigid bodies represent the main entity of the dynamics system of the engine."}),"\n",(0,n.jsx)(s.h2,{id:"creating-a-body",children:"Creating a body"}),"\n",(0,n.jsxs)(s.p,{children:["Rigid bodies are associated to an instance of the ",(0,n.jsx)(s.code,{children:"World"})," class. They can be created like this:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"var world = new World();\nvar body = world.CreateRigidBody();\n"})}),"\n",(0,n.jsx)(s.h2,{id:"adding-shapes",children:"Adding shapes"}),"\n",(0,n.jsx)(s.p,{children:"Multiple shapes can be added to a rigid body, for example:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"body.AddShape([new SphereShape(radius: 2), new BoxShape(size: 1)]);\n"})}),"\n",(0,n.jsx)(s.p,{children:"Shapes determine how bodies collide with each other."}),"\n",(0,n.jsx)(s.admonition,{title:"Creating many bodies at once",type:"warning",children:(0,n.jsxs)(s.p,{children:["When calling body.AddShape(shape), the shape is registered in the collision system of the engine and immediately added to the spatial tree structure (",(0,n.jsx)(s.code,{children:"DynamicTree"}),") for efficient broad-phase collision detection.\nRegistering many objects at ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mo,{stretchy:"false",children:"("}),(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"(0, 0, 0)"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mopen",children:"("}),(0,n.jsx)(s.span,{className:"mord",children:"0"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"0"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"0"}),(0,n.jsx)(s.span,{className:"mclose",children:")"})]})})]})," must be prevented by specifying the rigid body position, before adding shapes."]})}),"\n",(0,n.jsx)(s.admonition,{title:"Passing the same instance to multiple bodies",type:"warning",children:(0,n.jsx)(s.p,{children:"Passing the same instance of a shape to multiple bodies is not allowed in Jitter and will throw an exception."})}),"\n",(0,n.jsxs)(s.p,{children:["In Jitter, the sphere shape is defined so that its geometric center aligns with the (local) coordinate system's center at ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mo,{stretchy:"false",children:"("}),(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"(0, 0, 0)"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mopen",children:"("}),(0,n.jsx)(s.span,{className:"mord",children:"0"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"0"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"0"}),(0,n.jsx)(s.span,{className:"mclose",children:")"})]})})]}),".\nThe same holds for all basic primitives (sphere, box, capsule, cone, cylinder)."]}),"\n",(0,n.jsx)(s.p,{children:"After adding a shape to Jitter the mass properties (mass and inertia) of the associated rigid body are calculated accordingly.\nJitter assumes unit density for the calculations."}),"\n",(0,n.jsx)(s.p,{children:"Adding just a sphere"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"body.AddShape(new SphereShape(radius: 1));\n"})}),"\n",(0,n.jsx)(s.p,{children:"will result in a body with the textbook inertia and mass of a unit-density sphere of radius one."}),"\n",(0,n.jsxs)(s.p,{children:["Of course, the mass properties of the body can be set directly, using ",(0,n.jsx)(s.code,{children:"body.SetMassInertia"}),".\nSetting ",(0,n.jsx)(s.code,{children:"setMassProperties: false"})," in ",(0,n.jsx)(s.code,{children:"body.AddShape(...)"})," prevents Jitter from using the shapes' mass properties."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsxs)(s.em,{children:[(0,n.jsx)(s.strong,{children:"In Jitter the position of the rigid body has to align with the center of mass."}),"\nSo in the local reference frame of the body, the center of mass is ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mo,{stretchy:"false",children:"("}),(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"(0, 0, 0)"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mopen",children:"("}),(0,n.jsx)(s.span,{className:"mord",children:"0"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"0"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"0"}),(0,n.jsx)(s.span,{className:"mclose",children:")"})]})})]}),". Shapes or combinations of shapes must be translated accordingly."]})}),"\n",(0,n.jsx)(s.h3,{id:"debugging-shapes",children:"Debugging shapes"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"RigidBody"})," class offers the ",(0,n.jsx)(s.code,{children:"body.DebugDraw(IDebugDrawer drawer)"})," method which creates a triangle hull for each shape added to the body and calls the ",(0,n.jsx)(s.code,{children:"drawer.DrawTriangle"})," method in the provided ",(0,n.jsx)(s.code,{children:"IDebugDrawer"})," implementation.\nThe coordinates of the triangles are in world space and can be drawn to debug the collision shape of the rigid body."]}),"\n",(0,n.jsx)(s.admonition,{title:"body.DebugDraw performance",type:"warning",children:(0,n.jsxs)(s.p,{children:["Every call to ",(0,n.jsx)(s.code,{children:"body.DebugDraw"})," the triangle hulls are generated on the fly.\nSince this is a slow operation the method should only be called for debugging purposes."]})}),"\n",(0,n.jsx)(s.h2,{id:"gravity",children:"Gravity"}),"\n",(0,n.jsxs)(s.p,{children:["The gravity for the world can be set using ",(0,n.jsx)(s.code,{children:"world.Gravity"}),".\nThe property ",(0,n.jsx)(s.code,{children:"body.AffectedByGravity"})," can be used to disable gravity for individual bodies."]}),"\n",(0,n.jsx)(s.h2,{id:"damping",children:"Damping"}),"\n",(0,n.jsxs)(s.p,{children:["Jitter uses a very simple damping system to slow rigid bodies down.\nThis improves simulation stability and also resembles mechanical systems 'losing' energy in the real world.\nIn Jitter there is a linear and an angular damping factor for each body which can be set using ",(0,n.jsx)(s.code,{children:"body.Damping"}),".\nWith each ",(0,n.jsx)(s.code,{children:"world.Step"}),", Jitter multiplies the angular and linear velocity of each rigid body by ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mn,{children:"1"}),(0,n.jsx)(s.mo,{children:"\u2212"}),(0,n.jsx)(s.mi,{children:"\u03b3"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"1-\\gamma"})]})})}),(0,n.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,n.jsx)(s.span,{className:"mord",children:"1"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,n.jsx)(s.span,{className:"mbin",children:"\u2212"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05556em"},children:"\u03b3"})]})]})]}),", where ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mi,{children:"\u03b3"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\gamma"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05556em"},children:"\u03b3"})]})})]})," is the damping factor.\nFor performance reasons there is no time dependency for the damping system.\nAs a result, bodies in a simulation with smaller timesteps experience greater damping."]}),"\n",(0,n.jsx)(s.h2,{id:"speculative-contacts",children:"Speculative contacts"}),"\n",(0,n.jsxs)(s.p,{children:["Speculative contacts can be utilized to prevent fast and small objects from tunneling through thin objects.\nAn object moving quickly enough might 'miss' a collision since the distance traveled between two frames exceeds the thickness of another object.\nSpeculative contacts can be enabled on a per-body basis using ",(0,n.jsx)(s.code,{children:"body.EnableSpeculativeContacts"}),".\nThe ",(0,n.jsx)(s.code,{children:"world.SpeculativeRelaxationFactor"})," and ",(0,n.jsx)(s.code,{children:"world.SpeculativeVelocityThreshold"})," can be adjusted to fine-tune speculative contacts for specific use cases.\nHowever, it should be noted that an accurate simulation of fast-moving objects is only possible using smaller time steps.\nSpeculative contacts may involve a trade-off of less accurate collision detection and response."]}),"\n",(0,n.jsx)(s.h2,{id:"friction-and-restitution",children:"Friction and Restitution"}),"\n",(0,n.jsxs)(s.p,{children:["Friction and restitution coefficients may be set through ",(0,n.jsx)(s.code,{children:"body.Friction"})," and ",(0,n.jsx)(s.code,{children:"body.Restitution"}),".\nFor a collision of two bodies with different coefficients the maximum value of each body is taken."]}),"\n",(0,n.jsx)(s.h2,{id:"collide-events",children:"Collide events"}),"\n",(0,n.jsxs)(s.p,{children:["An instance of ",(0,n.jsx)(s.code,{children:"RigidBody"})," provides two events: ",(0,n.jsx)(s.code,{children:"BeginCollide"})," and ",(0,n.jsx)(s.code,{children:"EndCollide"}),".\nThese events are triggered whenever an arbiter (Contact) is created or removed which involves the rigid body.\nBy default, arbiters are created between colliding shapes.\nFor example, the ",(0,n.jsx)(s.code,{children:"BeginCollide"})," event can be used to modify the coefficient of friction of a contact:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"body.BeginCollide += BodyOnBeginCollide;\n\nprivate void BodyOnBeginCollide(Arbiter arb)\n{\n    arb.Handle.Data.Friction = 0.0f;\n}\n"})}),"\n",(0,n.jsx)(s.h2,{id:"activationdeactivation",children:"Activation/Deactivation"}),"\n",(0,n.jsx)(s.p,{children:"A rigid body is always assigned to an island.\nIslands are formed by bodies which are pairwise interacting with each other trough contacts or constraints.\nDifferent islands are not interacting with each other in any way."}),"\n",(0,n.jsxs)(s.p,{children:["Active rigid bodies may be marked for deactivation by the world once their angular and linear velocity remain below the thresholds defined in ",(0,n.jsx)(s.code,{children:"body.DeactivationThreshold"})," for a period defined by ",(0,n.jsx)(s.code,{children:"body.DeactivationTime"}),".\nIf all bodies within an island are marked for deactivation the whole island gets deactivated.\nThe simulation cost for inactive bodies is effectively zero.\nIslands (and their associated bodies) might get waken up, as soon as a collision with an active body is registered."]}),"\n",(0,n.jsxs)(s.p,{children:["Using ",(0,n.jsx)(s.code,{children:"body.SetActivationState"}),", the user can reset the internal deactivation time clock for the rigid body.\nIt will not immediately change the activation state of the body (",(0,n.jsx)(s.code,{children:"body.IsActive"}),").\nJitter will then in the next ",(0,n.jsx)(s.code,{children:"world.Step"})," consider this body and it's connected island for activation or deactivation.\nCalling e.g. ",(0,n.jsx)(s.code,{children:"body.SetActivationState(false)"})," on a falling body with a velocity greater than ",(0,n.jsx)(s.code,{children:"body.DeactivationThreshold"})," will have no effect."]}),"\n",(0,n.jsx)(s.h2,{id:"static-bodies",children:"Static bodies"}),"\n",(0,n.jsx)(s.p,{children:"Static bodies have infinite mass and therefore are not affected by collisions or constraints.\nThey also do not join islands.\nStatic bodies do not generate collisions with other static or inactive bodies.\nBecause of this, the position of static bodies should not be altered while in contact with other bodies."}),"\n",(0,n.jsx)(s.h2,{id:"kinematic-bodies",children:"Kinematic bodies"}),"\n",(0,n.jsxs)(s.p,{children:["There is no explicit concept of kinematic bodies in Jitter.\nIn game physics kinematic bodies are bodies which can have a velocity and therefore change their position.\nThey act similiar to static bodies during collisions - their velocity is not changed when colliding with a regular body.\nTheir velocity if often set directly using ",(0,n.jsx)(s.code,{children:"body.Velocity"}),".\nIn Jitter kinematic bodies are just regular rigid bodies with infinite (or very high) mass.\nThis can be achieved using ",(0,n.jsx)(s.code,{children:"body.SetMassInertia"})," like in this example:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"body.SetMassInertia(JMatrix.Zero, 1e-3f, setAsInverse: true);\n"})}),"\n",(0,n.jsx)(s.p,{children:"Additionaly, damping can be disabled:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"body.Damping = (linear: 0.0f, angular: 0.0f);\n"})}),"\n",(0,n.jsx)(s.admonition,{title:"Kinematic bodies",type:"danger",children:(0,n.jsx)(s.p,{children:"Setting the mass of a rigid body to infinity makes a body unstoppable.\nHaving an unstoppable object colliding with a static (immovable object) or another unstoppable object might crash the solver.\nIt must be ensured that no contact points are generated in such cases."})})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,s,i)=>{i.d(s,{R:()=>d,x:()=>o});var n=i(6540);const a={},t=n.createContext(a);function d(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:d(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);